<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2018-05-28T21:33:51+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[HuKai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android相机开发 - 1)基础概览篇]]></title>
    <link href="http://hukai.me/android-dev-camera-basics/"/>
    <updated>2017-01-30T21:24:00+08:00</updated>
    <id>http://hukai.me/android-dev-camera-basics</id>
    <content type="html"><![CDATA[<p>在Android平台上面实现自定义相机，根据业务的复杂度，涉及到的知识范畴大致如下，开篇优先描述下基础概览的部分:</p>

<p><img src="/images/android_dev_custom_camera_basic.jpeg" alt="android_dev_custom_camera_basic.jpeg" /></p>

<h2>0)开始之前</h2>

<p>在应用中开启Android设备的相机功能之前，应该考虑如下几个问题：</p>

<ul>
<li><strong>必须的相机硬件</strong> - 当然不能把一个包含相机功能的应用安装到一个连相机硬件都没有的设备上。因此，应该在mainfest文件中声明需要使用到相机。</li>
<li><strong>快速获取图片还是自定义相机</strong> - 应用将如何使用相机？是想实现一个快速的抓拍功能还是录制一小段视频剪辑？还是说想提供一种全新的相机使用方式？如果是快速的获取一张抓拍图片或者是一小段视频剪辑，建议查看下面的<strong>3)使用已经存在的相机应用。</strong>如果是为了开发一个自定义的相机功能的应用，查看下面的<strong>4)创建自定义相机应用</strong>。</li>
<li><strong>存储位置</strong> - 生成的图片与视频是只对自己的应用可见还是其它相册Gallery类的应用也可以访问？即使自己的应用被卸载后也不能被其他应用访问吗？建议查看<strong>5)保存媒体文件</strong></li>
</ul>


<h2>1)简要概述</h2>

<p>Android framework通过提供Camera API来支持拍照与录制视频的功能。下面是相关的类：</p>

<ul>
<li><a href="https://developer.android.com/reference/android/hardware/camera2/package-summary.html"><strong>android.hardware.camera2</strong></a><br/>
这里列举了控制相机的核心API，使用它可以实现拍照和录制视频的功能。</li>
<li><a href="https://developer.android.com/reference/android/hardware/Camera.html"><strong>Camera</strong></a><br/>
该类是已经被废弃的控制相机的基础的API。</li>
<li><a href="http://developer.android.com/reference/android/view/SurfaceView.html"><strong>SurfaceView</strong></a><br/>
该类用来呈现一个动态的相机预览界面。</li>
<li><a href="http://developer.android.com/reference/android/media/MediaRecorder.html"><strong>MediaRecorder</strong></a><br/>
该类用来使用相机录制视频(后续的文章中都不会对视频录制的部分进行过多描述，不属于该系列文章的主要讨论范畴)</li>
<li><a href="http://developer.android.com/reference/android/content/Intent.html"><strong>Intent</strong></a><br/>
使用<a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> 或者 <a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a>作为Intent的action可以用来拍照与录制视频。</li>
</ul>


<!-- More -->


<h2>2)AndroidManifest.xml声明</h2>

<p>在使用Camera API开发应用之前，应该确保应用的mainfest中有做恰当的权限声明，表明此应用需要使用相机或者是相机的相关功能。</p>

<ul>
<li><p><strong>Camera Permission</strong> - 为了使用相机硬件，你的应用必须请求使用Camera的权限。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</code><br/>
<strong>Note:</strong>如果你是通过Intent来调用其他已经存在的Camera应用，自己的应用程序是不需要声明这个权限的。</p></li>
<li><p><strong>Camera Features</strong> - 你的应用还必须声明使用相机功能，例如：<br/>
<code>xml
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</code><br/>
关于相机功能列表，请参考<a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">功能引用</a>。增加相机功能到你的mainfest文件，这样Google Play可以阻止那些没有相机硬件或者没有相机特定功能的设备安装你的应用。关于Google Play如何做过滤的信息，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#market-feature-filtering">Google Play and Feature-Based Filtering</a>(关于这一点，国内的分发市场暂时都没有做一条的过滤)。你还可以为每个相机特性设置<code>android:required</code>的属性，表示这个功能是否为必须的。</p></li>
<li><p><strong>Storage Permission</strong> - 如果你的应用需要保存图片或者视频到设备的外置存储空间(SDCard)上，你也需要在manifest中指定存储的读写权限。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
</code></p></li>
<li><p><strong>Location Permission</strong> - 如果你的应用需要为图片添加位置信息，你还需要请求location permission，如果应用需要执行在Android 5.0及更高的的版本上，还需要声明GPS权限。
```xml
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
...</p></li>
</ul>


<!-- Needed only if your app targets Android 5.0 (API level 21) or higher. -->


<p><uses-feature android:name="android.hardware.location.gps" />
```</p>

<p>关于获取用户位置信息的更多细节信息，请参考<a href="https://developer.android.com/guide/topics/location/strategies.html">Location Strategies</a>。</p>

<h2>3)使用已经存在的相机应用</h2>

<p>在你的应用中快速的实现拍照与录制视频的方法是使用一个Intent来调用已经存在系统中的相机程序。通过已经存在的相机程序拍照或者录制视频，然后返回数据给请求方。这一部分会演示如何使用这种技术。</p>

<p>触发Camera Intent需要遵守如下几个步骤：</p>

<ul>
<li><p><strong>Compose a Camera Intent</strong> - 创建一个请求拍照或者录像的Intent，使用下面的intent类型：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> - 请求拍照的Intent。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a> - 请求录像的Intent。</li>
</ul>
</li>
<li><p><strong>Start the Camera Intent</strong> - 使用<a href="http://developer.android.com/reference/android/app/Activity.html#startActivityForResult(android.content.Intent,%20int">startActivityForResult()</a>)方法来执行这个Intent。在启动这个Intent之后，相机程序会被唤起并提供拍照或者录像的功能。</p></li>
<li><p><strong>Receive the Intent Result</strong> - 在你的程序里面实现<a href="http://developer.android.com/reference/android/app/Activity.html#onActivityResult(int,%20int,%20android.content.Intent">onActivityResult()</a>)的方法用来接收相机程序返回的数据。当用户结束拍照或者录像之后，系统会调用到这个方法。</p></li>
</ul>


<h3>3.1)Image capture intent</h3>

<p>使用Camera Intent是一种使用最少的代码为你的程序开启拍照功能的一种简便的方法。一个拍照程序可以包含下面的附加信息：</p>

<p><strong><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a></strong> - 这定义了一个Uri对象来指定存放图片的路径与文件名。这个设置信息是可选的，但是强烈建议添加。如果你不指定这个值，相机程序会使用默认的文件名保存图片到默认的位置，这个值可以从Intent.getData()的字段中获取到。</p>

<p>下面的示例代码演示了如何构建一个拍照Intent并执行它。<code>getOutputMediaFileUri()</code>方法可以从<strong>Saving Media Files</strong>的段落中涉及到。</p>

<p>```java
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private Uri fileUri;</p>

<p>@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

// create Intent to take a picture and return control to the calling application
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

fileUri = getOutputMediaFileUri(MEDIA_TYPE_IMAGE); // create a file to save the image
intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri); // set the image file name

// start the image capture Intent
startActivityForResult(intent, CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE);
</code></pre>

<p>}
```</p>

<p>当startActivityForResult()方法被执行，用户会看到一个相机拍照的界面。用户执行了拍照(或者取消操作)，用户界面会回退到你的程序，你必须在onActivityResult()方法里面接收返回的数据。关于如何接受完整的intent，可以参考下面的<strong>Receiving camera intent result</strong>段落。</p>

<h3>3.2)Video capture intent</h3>

<p>视频录制的原理和拍照一致。一个视频录制的Intent可以包含如下的参数信息：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a> - 和拍照类似，这里指定保存视频的位置。同样这个字段是可选的，但是也被强烈建议进行填写。如果没有传递这个参数，相机程序会使用默认的文件名保存文件到默认的存储位置。你可以通过在返回的Intent.getData()字段中获取到这个值。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_VIDEO_QUALITY">MediaStore.EXTRA_VIDEO_QUALITY</a> - 这里的值可以为0或者1，分别表示低质量与高质量。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_DURATION_LIMIT">MediaStore.EXTRA_DURATION_LIMIT</a> - 设置这个值用来限制视频的长度，用毫秒计算。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_SIZE_LIMIT">MediaStore.EXTRA_SIZE_LIMIT</a> - 设置这个值用来限制文件的大小，用btye做单位。</li>
</ul>


<p>下面演示了如何构建一个Video Intent并执行：
```java
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;
private Uri fileUri;</p>

<p>@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

//create new Intent
Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);

fileUri = getOutputMediaFileUri(MEDIA_TYPE_VIDEO);  // create a file to save the video
intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);  // set the image file name

intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1); // set the video image quality to high

// start the Video Capture Intent
startActivityForResult(intent, CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE);
</code></pre>

<p>}
```
和拍照类似，也需要在activity的onActivityResult里面去接收数据并做处理。</p>

<h3>3.3)Receiving camera intent result</h3>

<p>一旦你构建并执行了一个拍照或者录像的Intent，你的程序必须确保能够正确接收返回的数据。为了正确的接收到Intent，你必须重写onActivityResult()的方法，下面会演示如何获取到上面示例代码返回的数据。</p>

<p>```java
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;</p>

<p>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {</p>

<pre><code>if (requestCode == CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
        // Image captured and saved to fileUri specified in the Intent
        Toast.makeText(this, "Image saved to:\n" +
                 data.getData(), Toast.LENGTH_LONG).show();
    } else if (resultCode == RESULT_CANCELED) {
        // User cancelled the image capture
    } else {
        // Image capture failed, advise user
    }
}

if (requestCode == CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
        // Video captured and saved to fileUri specified in the Intent
        Toast.makeText(this, "Video saved to:\n" +
                 data.getData(), Toast.LENGTH_LONG).show();
    } else if (resultCode == RESULT_CANCELED) {
        // User cancelled the video capture
    } else {
        // Video capture failed, advise user
    }
}
</code></pre>

<p>}
```</p>

<p>一旦你的activity成功接收了数据，那么你的程序就可以在指定的位置获取到图片或者视频了。</p>

<h2>4)创建自定义相机应用</h2>

<p>很多时候，我们都会需要开发自定义的相机应用，它能够提供更多特殊的相机功能并带来不同的用户体验。创建一个自定义的相机应用比起使用Intent调用已经存在的相机应用会复杂许多，后续我们都会基于自定义的相机扩展描述其他的相关内容。</p>

<p>通常来说创建一个自定义的相机有如下几个步骤：</p>

<ul>
<li><strong>Detect and Access Camera</strong> - 检查相机是否存在并可访问。</li>
<li><strong>Create a Preview Class</strong> - 创建一个继承自SurfaceView的preview类，并实现SurfaceHolder的接口，用这个类用来预览相机的画面。</li>
<li><strong>Build a Preview Layout</strong> - 一旦你拥有了预览组件。创建一个Layout用来承载preview并提供交互控制界面。</li>
<li><strong>Setup Listeners for Capture</strong> - 为控制界面建立监听器，用来启动拍照或者录像。</li>
<li><strong>Capture and Save Files</strong> - 建立拍照录像的代码并进行保存。</li>
<li><strong>Release the Camera</strong> - 使用完相机之后，你的程序必须正确的释放它，以便其他程序使用。</li>
</ul>


<p>相机硬件是一个共享资源，必须谨慎正确的使用，我们的程序不应该和其他可能使用相机硬件的程序有冲突。下面的段落会介绍如何检测相机硬件，如何请求获取权限，如何拍照录像以及如何在使用完毕时释放相机。</p>

<p><strong>注意:</strong> 当你的程序执行完任务之后，切记需要通过执行Camera.release()来释放相机对象。如果你的相机没有合理的释放相机，后续包括你自己的应用在内的所有的相机应用，都将无法正常打开相机并且可能导致程序崩溃。</p>

<h3>4.1)Detecting camera hardware</h3>

<p>如果你的程序没有在manifest中声明需要使用相机，你应该在运行时去检查相机是否可用。为了执行这个检查，需要使用到<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String">PackageManager.hasSystemFeature()</a>) 方法，如下所示：</p>

<p>```java
/<em>* Check if this device has a camera </em>/
private boolean checkCameraHardware(Context context) {</p>

<pre><code>if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)){
    // this device has a camera
    return true;
} else {
    // no camera on this device
    return false;
}
</code></pre>

<p>}
```</p>

<p>Android设备可以拥有多个摄像头，例如前置与后置摄像头。从Android 2.3 (API level 9)开始，可以通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#getNumberOfCameras(">Camera.getNumberOfCameras()</a>)方法获取到摄像头的个数。</p>

<h3>4.2)Accessing cameras</h3>

<p>如果已经判断到程序运行的设备上存在摄像头，接下去想要获取到某个具体的摄像头实例，需要通过先打开这个摄像头的实例来进行访问操作。</p>

<p>为了访问到主摄像头，如下所示，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(">Camera.open()</a>)方法。
```java
/<em>* A safe way to get an instance of the Camera object. </em>/
public static Camera getCameraInstance(){</p>

<pre><code>Camera c = null;
try {
    c = Camera.open(); // attempt to get a Camera instance
}
catch (Exception e){
    // Camera is not available (in use or does not exist)
}
return c; // returns null if camera is unavailable
</code></pre>

<p>}
```</p>

<p><strong>注意:</strong>当使用<code>Camera.open()</code>方法时总是需要做异常捕获。如果没有进行检查捕获，很有可能会因为相机正在使用或者相机不存在而使得程序崩溃。</p>

<p>在Android 2.3 (API level 9)开始, 可以使用通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(int">Camera.open(int)</a>)方法来访问指定的摄像头。上面演示的代码会优先获取主摄像头。</p>

<h3>4.3)Checking camera features</h3>

<p>一旦获取到相机实例，可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getParameters(">Camera.getParameters()</a>)方法来获取到更多的相机信息。也可以通过获取到的相机参数对象得到相机能够支持的功能。从android 2.3开始，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getCameraInfo(int,%20android.hardware.Camera.CameraInfo">Camera.getCameraInfo()</a>)可以获取到相机是前置还是后置摄像头以及将要拍摄出来的图片角度。</p>

<h3>4.4)Creating a preview class</h3>

<p>为了给用户提供有效的拍照与录像体验，用户需要能够对摄像头捕获的数据进行预览。相机预览是使用SurfaceView，它用来显示来自摄像头硬件传递过来的画面数据。</p>

<p>下面的示例代码演示了如何创建一个基础的相机预览类，该类可以included到另外一个layout中。为了捕获拍照事件的回调，需要实现<a href="http://developer.android.com/reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a>，之后可以在这些回调里面进行创建与销毁View的操作。</p>

<p>```java
/<em>* A basic Camera preview class </em>/
public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {</p>

<pre><code>private SurfaceHolder mHolder;
private Camera mCamera;

public CameraPreview(Context context, Camera camera) {
    super(context);
    mCamera = camera;

    // Install a SurfaceHolder.Callback so we get notified when the
    // underlying surface is created and destroyed.
    mHolder = getHolder();
    mHolder.addCallback(this);
    // deprecated setting, but required on Android versions prior to 3.0
    mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
}

public void surfaceCreated(SurfaceHolder holder) {
    // The Surface has been created, now tell the camera where to draw the preview.
    try {
        mCamera.setPreviewDisplay(holder);
        mCamera.startPreview();
    } catch (IOException e) {
        Log.d(TAG, "Error setting camera preview: " + e.getMessage());
    }
}

public void surfaceDestroyed(SurfaceHolder holder) {
    // empty. Take care of releasing the Camera preview in your activity.
}

public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
    // If your preview can change or rotate, take care of those events here.
    // Make sure to stop the preview before resizing or reformatting it.

    if (mHolder.getSurface() == null){
      // preview surface does not exist
      return;
    }

    // stop preview before making changes
    try {
        mCamera.stopPreview();
    } catch (Exception e){
      // ignore: tried to stop a non-existent preview
    }

    // set preview size and make any resize, rotate or
    // reformatting changes here

    // start preview with new settings
    try {
        mCamera.setPreviewDisplay(mHolder);
        mCamera.startPreview();

    } catch (Exception e){
        Log.d(TAG, "Error starting camera preview: " + e.getMessage());
    }
}
</code></pre>

<p>}
```</p>

<p>如果你想为你的相机预览界面设置特定的预览大小，可以在<code>surfaceChanged()</code>的回调里面进行操作(注意上面演示代码的注释)。设置预览大小时，你<strong>必须</strong>使用从<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#getSupportedPreviewSizes(">getSupportedPreviewSizes()</a>)方法获取到的预览值，不能在<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#setPreviewSize(int,%20int">setPreviewSize()</a>)方法里设置随意的预览值。</p>

<p><strong>Notes:</strong>请注意这里只是为了演示操作相机的基础步骤，实际项目中很少用下面这么简单的结构来进行操作。</p>

<h3>4.5)Placing preview in a layout</h3>

<p>在上一段落演示的Camera Preview Class，必须放置在一个activity的layout中。这一段落会演示为了预览如何创建一个基础的layout与activity。</p>

<p>下面的代码提供了一个能够显示相机预览界面的基础layout。在这段代码中，FrameLayout是相机预览类的container。使用framelayout可以在相机预览界面上叠加额外的图片信息或者是操作控制组件。</p>

<p>```xml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:orientation="horizontal"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
&gt;
</code></pre>

<p>  &lt;FrameLayout</p>

<pre><code>android:id="@+id/camera_preview"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:layout_weight="1"
/&gt;
</code></pre>

<p>  &lt;Button</p>

<pre><code>android:id="@+id/button_capture"
android:text="Capture"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_gravity="center"
/&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>在大多数设备上，相机预览的角度默认是横屏的。演示的layout指定了horizontal，并且下面的代码使得activity固定成横屏的模式。</p>

<p>```xml
&lt;activity android:name=".CameraActivity"</p>

<pre><code>      android:label="@string/app_name"

      android:screenOrientation="landscape"&gt;
      &lt;!-- configure this activity to use landscape orientation --&gt;

      &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
</code></pre>

<p></activity>
```</p>

<p><strong>Note:</strong> 相机预览界面不一定是要横屏的。从android 2.2开始，你可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation(int">setDisplayOrientation()</a>)方法来设置预览图片的角度。为了在用户旋转手机时改变相机预览的角度，在<code>surfaceChanged()</code>方法里面，首先要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#stopPreview(">Camera.stopPreview()</a>)停止预览，然后再使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#startPreview(">Camera.startPreview()</a>)方法来重新开启相机预览，后面会新写文章展开来讲这一部分的细节。</p>

<p>为了在activity中添加相机界面，你的Camera Activity必须确保在activity pause或者是destory的时候释放相机资源。下面的代码演示了如何添加camera preview class到camera activity中。</p>

<p>```java
public class CameraActivity extends Activity {</p>

<pre><code>private Camera mCamera;
private CameraPreview mPreview;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // Create an instance of Camera
    mCamera = getCameraInstance();

    // Create our Preview view and set it as the content of our activity.
    mPreview = new CameraPreview(this, mCamera);
    FrameLayout preview = (FrameLayout) findViewById(R.id.camera_preview);
    preview.addView(mPreview);
}
</code></pre>

<p>}
```</p>

<p><strong>Note:</strong> 上面演示的<code>getCameraInstance()</code>方法出现在4.2)Accessing camera段落中。</p>

<h3>4.6)触发拍照行为</h3>

<p>一旦你建立了preview class并且创建好了显示的layout。那么就可以开始做拍照的动作了。</p>

<p>为了获取到一张图片，需要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#takePicture(android.hardware.Camera.ShutterCallback,%20android.hardware.Camera.PictureCallback,%20android.hardware.Camera.PictureCallback">Camera.takePicture()</a>)方法。为了获取到JPEG格式的图片数据，你必须implement一个<a href="http://developer.android.com/reference/android/hardware/Camera.PictureCallback.html">Camera.PictureCallback</a>接口来接收图片数据并把它写到文件中。</p>

<p>```java
private PictureCallback mPicture = new PictureCallback() {</p>

<pre><code>@Override
public void onPictureTaken(byte[] data, Camera camera) {

    File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
    if (pictureFile == null){
        Log.d(TAG, "Error creating media file, check storage permissions: " +
            e.getMessage());
        return;
    }

    try {
        FileOutputStream fos = new FileOutputStream(pictureFile);
        fos.write(data);
        fos.close();
    } catch (FileNotFoundException e) {
        Log.d(TAG, "File not found: " + e.getMessage());
    } catch (IOException e) {
        Log.d(TAG, "Error accessing file: " + e.getMessage());
    }
}
</code></pre>

<p>};
```</p>

<p>触发拍照的动作，需要使用下面演示到的方法。</p>

<p>```java
// Add a listener to the Capture button
Button captureButton = (Button) findViewById(id.button_capture);
captureButton.setOnClickListener(</p>

<pre><code>new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // get an image from the camera
        mCamera.takePicture(null, null, mPicture);
    }
}
</code></pre>

<p>);
```</p>

<h3>4.7)释放相机实例</h3>

<p>相机实例是被共享的系统资源。获取到相机实例之后，程序才可以使用相机，但是，在使用完相机的时候，程序必须谨慎的释放它。建议在程序进入到pause状态时，立即释放相机资源。如果你的程序没有合理的释放相机资源，包括自己程序本身在内，后续所有的相机请求都将失败，甚至可能会导致程序崩溃。下面的代码演示了如何释放相机资源。</p>

<p>```java
public class CameraActivity extends Activity {</p>

<pre><code>private Camera mCamera;
private SurfaceView mPreview;
private MediaRecorder mMediaRecorder;

...

@Override
protected void onPause() {
    super.onPause();
    releaseMediaRecorder();       // if you are using MediaRecorder, release it first
    releaseCamera();              // release the camera immediately on pause event
}

private void releaseMediaRecorder(){
    if (mMediaRecorder != null) {
        mMediaRecorder.reset();   // clear recorder configuration
        mMediaRecorder.release(); // release the recorder object
        mMediaRecorder = null;
        mCamera.lock();           // lock camera for later use
    }
}

private void releaseCamera(){
    if (mCamera != null){
        mCamera.release();        // release the camera for other applications
        mCamera = null;
    }
}
</code></pre>

<p>}
```</p>

<h2>5)保存媒体文件</h2>

<p>前面介绍了自定义相机，使用相机拍摄的照片或者视频都需要保存到设备的external storage目录下(SDCard)。可以有多种可能的位置用来保存文件，但是作为一个开发人员，建议使用下面两种标准的路径进行保存。</p>

<ul>
<li><a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String">Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回用来保存图片与视频所推荐使用的标准共享目录。这个目录是共享开放的，所有其他的程序都可以轻易的访问，读取并删除这个目录下的文件。如果你的程序被用户卸载，在这个目录下的文件不会被移除。为了避免干扰到用户已经存在的图片与视频目录，你应该为你的程序创建一个子目录。如下面的代码所示。这个方法从Android 2.2 (API level 8)开始就可以使用。</li>
<li><a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String">Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回一个和你的程序相关联的，用来保存图片与视频的，标准目录。如果你的程序被卸载，在这个目录下的文件也会被一起移除。这个目录并不能阻止其他程序的读写。</li>
</ul>


<p>```java
public static final int MEDIA_TYPE_IMAGE = 1;
public static final int MEDIA_TYPE_VIDEO = 2;</p>

<p>/<em>* Create a file Uri for saving an image or video </em>/
private static Uri getOutputMediaFileUri(int type){</p>

<pre><code>  return Uri.fromFile(getOutputMediaFile(type));
</code></pre>

<p>}</p>

<p>/<em>* Create a File for saving an image or video </em>/
private static File getOutputMediaFile(int type){</p>

<pre><code>// To be safe, you should check that the SDCard is mounted
// using Environment.getExternalStorageState() before doing this.

File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
          Environment.DIRECTORY_PICTURES), "MyCameraApp");
// This location works best if you want the created images to be shared
// between applications and persist after your app has been uninstalled.

// Create the storage directory if it does not exist
if (! mediaStorageDir.exists()){
    if (! mediaStorageDir.mkdirs()){
        Log.d("MyCameraApp", "failed to create directory");
        return null;
    }
}

// Create a media file name
String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
File mediaFile;
if (type == MEDIA_TYPE_IMAGE){
    mediaFile = new File(mediaStorageDir.getPath() + File.separator +
    "IMG_"+ timeStamp + ".jpg");
} else if(type == MEDIA_TYPE_VIDEO) {
    mediaFile = new File(mediaStorageDir.getPath() + File.separator +
    "VID_"+ timeStamp + ".mp4");
} else {
    return null;
}
return mediaFile;
</code></pre>

<p>}
```</p>

<h2>6)相机相关特性</h2>

<p>Android提供了控制相机特性的方法，例如图片格式，闪光灯模式，聚焦模式等等。这一段落列出了大部分相机共有的功能并简短的介绍如何使用这些功能。大多数相机特性可以通过<strong>Camera.Parameters</strong>对象来获取并进行相关的设置。然而，有几个重要的功能不仅仅是通过<strong>Camera.Parameters</strong>能够实现的。请看下面的内容介绍：</p>

<ul>
<li>Metering and focus areas：测光并进行聚焦</li>
<li>Face detection：人脸检测</li>
</ul>


<p>关于上面2个常用的功能会在以后的文章中进行更加详细的介绍，除此之外的其他相机特性功能，请参考下面这张表：</p>

<p><img src="/images/articles/camera_features_table.png" title="Camera Common Features" alt="camera_features_table.png" /></p>

<p><strong>Note:</strong> 因为软硬件的差异性，那些功能并不一定都是支持的。对于检查功能是否可用，请参考下面的Checking feature availability.</p>

<h3>6.1)Checking feature availability</h3>

<p>相机的有些功能在所有手机上并不一定是都支持的。在开发相机应用时就需要提前考虑应该适配到哪个level。然后开发的时候需要动态的去根据功能是否支持来做不同的处理。</p>

<p>你可以通过获取到相机参数的对象来做检测。下面的例子演示了如何检查autofocus功能是否可用：
```java
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();</p>

<p>List<String> focusModes = params.getSupportedFocusModes();
if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
  // Autofocus mode is supported
}
```</p>

<p>对于大多数的相机特性，都可以使用类型上面的代码来处理。Camera.Parameters对象提供了一系列的类似<code>getSupported...()</code>, <code>is...Supported()</code> 与 <code>getMax...()</code> 方法来判断某个功能是否可用的。</p>

<p>如果你的程序确定需要相机的某个特性，你可以在mainfest文件中就进声明。例如你声明了flash与auto-focus的功能，那么Google Play会阻止那些不支持这些功能的设备安装这个应用。关于相机功能的声明列表，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">Features Reference.</a></p>

<h3>6.2)Using camera features</h3>

<p>前面已经提到过，通过Camera.Parameters对象来操控相机。如下所示：
<code>java
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();
// set the focus mode
params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
// set Camera parameters
mCamera.setParameters(params);
</code>
上面这种方法对大多数相机功能都是可用的，在你获取到相机的实例之后，大多数参数都是在任意时间均可以修改的。参数修改的效果在相机预览的界面是可以立即看到效果的。在软件层面，实际上可能是需要花几帧的时间来产生效果的，因为需要发送指令给相机硬件产生效果。</p>

<p><strong>Important:</strong> 有部分相机特性不是想要修改的时候就可以直接修改的。尤其是，修改相机预览的角度与相机预览大小，很多时候是需要先停止预览，设置参数，再重启预览的。从Android Android 4.0(API level 14)开始，预览角度可以不用重启预览就可以进行修改。</p>

<hr />

<p><strong>后记:</strong>这篇概览大致介绍了Android平台上相机开发相关的基础概念，上面的演示代码仅仅是为了说明问题，在真实项目的实践中，相机实例的相关操作都会放在单独的线程中，很多基础的操作都可能遇到复杂的兼容性问题，为了解决兼容性的问题，提高性能等等的需要，会做很大的调整，更多细节请期待后续的文章，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第6季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-6/"/>
    <updated>2016-10-04T23:12:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-6</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_common.png" alt="android_perf_patterns_season_common" /></p>

<blockquote><p>这里是<a href="https://www.youtube.com/watch?v=Vw1G1s73DsY&amp;index=74&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第6季的课程学习笔记，从被@知会到有连载更新，这篇学习笔记就一直被惦记着，现在学习记录分享一下，请多多指教包涵！这次一共才6个小段落，涉及的内容主要有：程序启动时间性能优化的三个方面：优化activity的创建过程，优化application对象的启动过程，正确使用启动显屏达到优化程序启动性能的目的。另外还介绍了减少安装包大小的checklist以及如何使用VectorDrawable来减少安装包的大小。</p></blockquote>

<h2>1）App Launch time 101</h2>

<p>提高程序的启动速度意义重大，很显然，启动时间越短，用户才越有耐心等待打开这个APP进行使用，反之启动时间越长，用户则越有可能来不及等到APP打开就已经切换到其他APP了。程序启动过程中的那些复杂错误的操作很可能导致严重的性能问题。Android系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他APP界面切换回来）。那么关键的问题是，用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他APP了。更严重的是，如果启动时间过长，可能导致程序出现ANR。我们应该避免出现这两种糟糕的情况。</p>

<p>从技术角度来说，当用户点击桌面图标开始，系统会立即为这个APP创建独立的专属进程，然后显示启动窗口，直到APP在自己的进程里面完成了程序的创建以及主线程完成了Activity的初始化显示操作，再然后系统进程就会把启动窗口替换成APP的显示窗口。</p>

<p><img src="/images/android_perf_6_launch_time_start_process.png" alt="android_perf_6_launch_time_start_process" /></p>

<!-- More -->


<p>上述流程里面的绝大多数步骤都是由系统控制的，一般来说不会出现什么问题，可是对于启动速度，我们能够控制并且需要特别关注的地方主要有三处：</p>

<ul>
<li>1）Activity的onCreate流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题。</li>
<li>2）Application的onCreate流程，对于大型的APP来说，通常会在这里做大量的通用组件的初始化操作。</li>
<li>3）目前有部分APP会提供自定义的启动窗口，这里可以做成品牌宣传界面或者是给用户提供一种程序已经启动的视觉效果。</li>
</ul>


<p>在正式着手解决问题之前，我们需要掌握一套正确测量评估启动性能的方法。所幸的是，Android系统有提供一些工具来帮助我们定位问题。</p>

<ul>
<li>1）首先是<strong>display time</strong>：从Android KitKat版本开始，Logcat中会输出从程序启动到某个Activity显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_display_time.png" alt="android_perf_6_launch_time_display_time" /></p>

<ul>
<li>2）其次是<strong>reportFullyDrawn</strong>方法：我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用<code>activity.reportFullyDrawn()</code>方法来告诉系统此时的状态，以便获取整个加载的耗时。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_report_fully_drawn.png" alt="android_perf_6_launch_time_report_fully_drawn" /></p>

<ul>
<li>3）然后是<strong>Method Tracing</strong>：前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用Method Tracing工具来进行详细的测量。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_method_tracing.png" alt="android_perf_6_launch_time_method_tracing" /></p>

<ul>
<li>4）最后是<strong>Systrace</strong>：我们可以在onCreate方法里面添加trace.beginSection()与trace.endSection()方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_systrace.png" alt="android_perf_6_launch_time_systrace" /></p>

<h2>2）App Launch Time &amp; Activity Creation</h2>

<p>提升Activity的创建速度是优化APP启动速度的首要关注目标。从桌面点击APP图标启动应用开始，程序会显示一个启动窗口等待Activity的创建加载完毕再进行显示。在Activity的创建加载过程中，会执行很多的操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写Preference等等。</p>

<p><img src="/images/android_perf_6_activity_creation_0.png" alt="android_perf_6_activity_creation_0" /></p>

<p>上述操作的任何一个环节出现性能问题都可能导致画面不能及时显示，影响了程序的启动速度。上一个段落我们介绍了使用Method Tracing来发现那些耗时占比相对较多的方法。假设我们发现某个方法执行时间过长，接下去就可以使用Systrace来帮忙定位到底是什么原因导致那个方法执行时间过长。</p>

<p>除了使用工具进行具体定位分析性能问题之外，以下两点经验可以帮助我们对Activity启动做性能优化：</p>

<ul>
<li>1）优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！</li>
<li>2）异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。</li>
</ul>


<h2>3）App Launch Time &amp; Bloated Application Objects</h2>

<p>在Application初始化的地方做太多繁重的事情是可能导致严重启动性能问题的元凶之一。Application里面的初始化操作不结束，其他任意的程序操作都无法进行。</p>

<p><img src="/images/android_perf_6_application_objs.png" alt="android_perf_6_application_objs" /></p>

<p>有时候，我们会一股脑的把绝大多数全局组件的初始化操作都放在Application的onCreate里面，但其实很多组件是需要做区队对待的，有些可以做延迟加载，有些可以放到其他的地方做初始化操作，特别需要留意包含Disk IO操作，网络访问等严重耗时的任务，他们会严重阻塞程序的启动。</p>

<p><img src="/images/android_perf_6_application_create.png" alt="android_perf_6_application_create" /></p>

<p>优化这些问题的解决方案是做延迟加载，可以在application里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。</p>

<p><img src="/images/android_perf_6_application_lazyload.png" alt="android_perf_6_application_lazyload" /></p>

<h2>4）App Launch Time &amp; Theme Launch Screens</h2>

<p>启动闪屏不仅仅可以作为品牌宣传页，还能够减轻用户对启动耗时的感知，但是如果使用不恰当，将适得其反。前面介绍过当点击桌面图标启动APP的时候，程序会显示一个启动窗口，一直到页面的渲染加载完毕。如果程序的启动速度足够快，我们看的闪屏窗口停留显示的时间则会很短，但是当程序启动速度偏慢的时候，这个启动闪屏可以一定程度上减轻用户等待的焦虑感，避免用户过于轻易的关闭应用。</p>

<p>目前大多数开发者都会通过设置启动窗口主题的方式来替换系统默认的启动窗口，通过这种方式只是使用『障眼法』弱化了用户对启动时间的感知，但本质上并没有对启动速度做什么优化。也有些APP通过关闭启动窗口属性<code>android:windowDisablePreview</code>的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，这样的用户体验是十分糟糕的！</p>

<p><img src="/images/android_perf_6_launch_screen.png" alt="android_perf_6_launch_screen" />
<img src="/images/android_perf_6_launch_screen2.png" alt="android_perf_6_launch_screen2" /></p>

<p>对于启动闪屏，正确的使用方法是自定义一张图片，把这张图片通过设置主题的方式显示为启动闪屏，代码执行到主页面的onCreate的时候设置为程序正常的主题。</p>

<p><img src="/images/android_perf_6_launch_screen3.png" alt="android_perf_6_launch_screen3" />
<img src="/images/android_perf_6_launch_screen4.png" alt="android_perf_6_launch_screen4" /></p>

<h2>5）Smaller APKs: A Checklist</h2>

<p>减少应用程序安装包的大小，不仅仅减少了用户的网络数据流量还减少了下载等待的时间。毋庸置疑，尽量减少程序安装包的大小是十分有必要的。通常来说，减少程序安装包的大小有两条规律：要么减少程序资源的大小，要么就是减少程序的代码量。这里总结一个简易版的减少安装包大小的Checklist:</p>

<h3>减少程序图片资源的大小</h3>

<ul>
<li>1）确保在build.gradle文件中开启了<code>minifEnabled</code>与<code>shrinkResources</code>的属性，这两个属性可以帮助移除那些在程序中使用不到的代码与资源，帮助减少APP的安装包大小。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_gradle.png" alt="android_perf_6_smaller_apks_gradle" /></p>

<ul>
<li>2）有选择性的提供对应分辨率的图片资源，系统会自动匹配最合适分辨率的图片并执行拉伸或者压缩的处理。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_dpi.png" alt="android_perf_6_smaller_apks_dpi" /></p>

<ul>
<li>3）在符合条件的情况下，使用Vertor Drawable替代传统的PNG/JPEG图片，能够极大的减少图片资源的大小。传统模式下，针对不同dpi的手机都需要提供一套PNG/JPEG的图片，而如果使用Vector Drawable的话，只需要一个XML文件即可。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_vector.png" alt="android_perf_6_smaller_apks_vector" /></p>

<ul>
<li>4）尽量复用已经存在的资源图片，使用代码的方式对已有的资源进行复用，如下图所示：</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_reuse.png" alt="android_perf_6_smaller_apks_reuse" /></p>

<p>以上几点虽然看起来都微不足道，但是真正执行之后，能够显著减少安装包的资源图片大小。</p>

<h3>减少程序的代码量</h3>

<ul>
<li><p>1）开启MinifEnabled，Proguard。打开这些编译属性之后，程序在打包的时候就不会把没有引用到的代码编译进来，以此达到减少安装包大小的目的。</p></li>
<li><p>2）注意因为编译行为额外产生的方法数，例如类似Enum，Protocal Buffer可能导致方法数与类的个数增加。</p></li>
<li><p>3）部分引入到工程中的jar类库可能并不是专门针对移动端APP而设计的，他们最开始可能是运用在PC或者Server上的。使用这些类库不仅仅额外增加了包的大小，还增加了编译时间。单纯依靠Proguard可能无法完全移除那些使用不到的方法，最佳的方式是使用一些更加轻量化，专门为Android APP设计的jar类库。</p></li>
</ul>


<h3>安装包的拆分</h3>

<p>设想一下，一个low dpi，API&lt;14的用户手机下载安装的APK里面却包含了大量xxhdpi的资源文件，对于这个用户来说，这个APK是存在很大的资源浪费的。幸好Android平台为我们提供了拆分APK的方法，它能够根据API Level，屏幕大小以及GPU版本的不同进行拆分，使得对应平台的用户下载到最合适自己手机的安装包。</p>

<p><img src="/images/android_perf_6_smaller_apks_split.png" alt="android_perf_6_smaller_apks_split" /></p>

<p>更多关于安装包拆分的信息，请查看<a href="https://developer.android.com/studio/build/configure-apk-splits.html">Configure APK Splits</a>与<a href="https://developer.android.com/training/multiple-apks/index.html">Maintaining Multiple APKs</a>(由于国内应用分发市场的现状，这一条几乎没有办法执行)。</p>

<h2>6）VectorDrawable for smaller APKs</h2>

<p>针对不同的分辨率提供多张精度的图片会额外增加APK的大小，针对这个问题的解决方案是考虑使用VectorDrawable，它仅仅只需要一个文件，能够动态生成对应分辨率的图片。</p>

<p><a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html">VectorDrawable</a>通过XML文件描述图片的形状，大小，样式。</p>

<p><img src="/images/android_perf_6_vectordrawable_origin.png" alt="android_perf_6_vectordrawable_origin" /></p>

<p>通过这种方式，我们可以显著减少图片资源对安装包大小的影响。</p>

<p><img src="/images/android_perf_6_vectordrawable_dpi.png" alt="android_perf_6_vectordrawable_dpi" />
<img src="/images/android_perf_6_vectordrawable_dpi2.png" alt="android_perf_6_vectordrawable_dpi2" /></p>

<p>使用VectorDrawable还可以避免因为使用帧动画导致的图片资源过多的情况，如下图所示</p>

<p><img src="/images/android_perf_6_vectordrawable_animation.png" alt="android_perf_6_vectordrawable_animation" /></p>

<p>前面介绍了VectorDrawable(VD)的优势，但是在使用VectorDrawable的时候，还是有以下的问题需要特别注意的？</p>

<ul>
<li>首先VD的加载有异于JPEG/PNG文件，图片文件可以依靠硬件进行纹理的渲染，而VD文件需要先进行加载解析，然后才能够进行纹理的渲染。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_load.png" alt="android_perf_6_vectordrawable_load" /></p>

<ul>
<li>其次VD文件适用于简单有规则的图片渲染，不适用于那些纹理过于复杂的图片，这样不仅仅会过度增加描述文件的复杂度还可能无法获取到想要的渲染效果。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_simple.png" alt="android_perf_6_vectordrawable_simple" /></p>

<ul>
<li>最后VD文件中关于Path的描述需要尽量简化，复杂冗余的Path信息不仅对得到想要的图片没有益处，还增加了加载渲染的难度。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_path.png" alt="android_perf_6_vectordrawable_path" /></p>

<hr />

<p>首发于CSDN：<a href="http://geek.csdn.net/news/detail/106513">Android性能优化典范（六）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google I/O 2016随笔]]></title>
    <link href="http://hukai.me/google-io-2016/"/>
    <updated>2016-05-24T05:06:01+08:00</updated>
    <id>http://hukai.me/google-io-2016</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/oasisfeng">冯老师</a>，<a href="https://github.com/liaohuqiu">秋百万</a>，<a href="http://www.race604.com/">吴晶</a>还有我！四人约好从北京转机一起前往旧金山。</p>

<p><img src="/images/google_io_2016_00.JPG" alt="google_io_2016_00" /></p>

<p>在航班上研究KMP算法的同学</p>

<p><img src="/images/google_io_2016_01.JPG" alt="google_io_2016_01" /></p>

<p>到达旧金山机场，去提取事先租好的车，自驾</p>

<!-- More -->


<p><img src="/images/google_io_2016_02.JPG" alt="google_io_2016_02" /></p>

<p><img src="/images/google_io_2016_03.JPG" alt="google_io_2016_03" /></p>

<p><img src="/images/google_io_2016_04.JPG" alt="google_io_2016_04" /></p>

<p>入住通过Airbnb上找的房子</p>

<p><img src="/images/google_io_2016_05.JPG" alt="google_io_2016_05" /></p>

<p><img src="/images/google_io_2016_06.JPG" alt="google_io_2016_06" /></p>

<p>到美国吃的第一顿（中式餐馆）没预料到这会是之后几天我吃的最满意的一次了</p>

<p><img src="/images/google_io_2016_07.JPG" alt="google_io_2016_07" /></p>

<p>第二天一早清晨，在海边小镇上闲逛</p>

<p><img src="/images/google_io_2016_08.JPG" alt="google_io_2016_08" />
<img src="/images/google_io_2016_09.JPG" alt="google_io_2016_09" />
<img src="/images/google_io_2016_10.JPG" alt="google_io_2016_10" />
<img src="/images/google_io_2016_11.JPG" alt="google_io_2016_11" />
<img src="/images/google_io_2016_12.JPG" alt="google_io_2016_12" /></p>

<p>之后去了旁边的半月湾海边走走，以及不远处的森林公园爬山</p>

<p><img src="/images/google_io_2016_13.JPG" alt="google_io_2016_13" />
<img src="/images/google_io_2016_14.JPG" alt="google_io_2016_14" />
<img src="/images/google_io_2016_15.JPG" alt="google_io_2016_15" /></p>

<p>晚上跑到旧金山最高点，看全市夜景</p>

<p><img src="/images/google_io_2016_16.JPG" alt="google_io_2016_16" /></p>

<p>离开半月湾海边公寓之前的合影（从左至右，依次为吴晶，冯老师，秋百万和我）</p>

<p><img src="/images/google_io_2016_17.JPG" alt="google_io_2016_17" /></p>

<p>窗外的全景</p>

<p><img src="/images/google_io_2016_19.JPG" alt="google_io_2016_19" /></p>

<p>I/O的头一天签到</p>

<p><img src="/images/google_io_2016_21.JPG" alt="google_io_2016_21" />
<img src="/images/google_io_2016_20.JPG" alt="google_io_2016_20" />
<img src="/images/google_io_2016_22.JPG" alt="google_io_2016_22" />
<img src="/images/google_io_2016_23.JPG" alt="google_io_2016_23" />
<img src="/images/google_io_2016_24.JPG" alt="google_io_2016_24" /></p>

<p>顺便参观了下Google总部</p>

<p><img src="/images/google_io_2016_25.JPG" alt="google_io_2016_25" />
<img src="/images/google_io_2016_26.JPG" alt="google_io_2016_26" />
<img src="/images/google_io_2016_27.JPG" alt="google_io_2016_27" />
<img src="/images/google_io_2016_28.JPG" alt="google_io_2016_28" />
<img src="/images/google_io_2016_29.JPG" alt="google_io_2016_29" />
<img src="/images/google_io_2016_30.JPG" alt="google_io_2016_30" /></p>

<p>签到当天晚上，又是一群聚会聊天</p>

<p><img src="/images/google_io_2016_32.JPG" alt="google_io_2016_32" />
<img src="/images/google_io_2016_31.JPG" alt="google_io_2016_31" /></p>

<p>次日I/O正式开场，主会场，分会场持续三天</p>

<p><img src="/images/google_io_2016_33.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_34.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_35.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_36.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_37.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_38.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_39.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_40.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_41.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_42.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_43.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_44.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_45.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_46.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_47.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_48.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_49.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_50.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_51.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_52.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_53.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_54.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_55.JPG" alt="google_io_2016_31" /></p>

<p>用一张合影结尾</p>

<p><img src="/images/google_io_2016_18.JPG" alt="google_io_2016_18" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第5季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-5/"/>
    <updated>2016-04-28T00:08:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-5</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_5.png" alt="android_perf_patterns_season_5" /></p>

<blockquote><p>这是<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第5季的课程学习笔记，拖拖拉拉很久，记录分享给大家，请多多包涵担待指正！文章共10个段落，涉及的内容有：多线程并发的性能问题，介绍了AsyncTask，HandlerThread，IntentService与ThreadPool分别适合的使用场景以及各自的使用注意事项，这是一篇了解Android多线程编程不可多得的基础文章，清楚的了解这些Android系统提供的多线程基础组件之间的差异以及优缺点，才能够在项目实战中做出最恰当的选择。</p></blockquote>

<h2>1)Threading Performance</h2>

<p>在程序开发的实践当中，为了让程序表现得更加流畅，我们肯定会需要使用到多线程来提升程序的并发执行性能。但是编写多线程并发的代码一直以来都是一个相对棘手的问题，所以想要获得更佳的程序性能，我们非常有必要掌握多线程并发编程的基础技能。</p>

<p>众所周知，Android程序的大多数代码操作都必须执行在主线程，例如系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程。</p>

<p><img src="/images/android_perf_5_threading_main_thread.png" alt="android_perf_5_threading_main_thread" /></p>

<!-- More -->


<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的UI绘制等等。我们知道，为了让屏幕的刷新帧率达到60fps，我们需要确保16ms内完成单次刷新的操作。一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了(一旦刷新帧率降到20fps左右，用户就可以明显感知到卡顿不流畅了)。</p>

<p><img src="/images/android_perf_5_threading_dropframe.png" alt="android_perf_5_threading_dropframe" /></p>

<p>为了避免上面提到的掉帧问题，我们需要使用多线程的技术方案，把那些操作复杂的任务移动到其他线程当中执行，这样就不容易阻塞主线程的操作，也就减小了出现掉帧的可能性。</p>

<p><img src="/images/android_perf_5_threading_workthread.png" alt="android_perf_5_threading_workthread" /></p>

<p>那么问题来了，为主线程减轻负的多线程方案有哪些呢？这些方案分别适合在什么场景下使用？Android系统为我们提供了若干组工具类来帮助解决这个问题。</p>

<ul>
<li><strong>AsyncTask</strong>: 为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li><strong>HandlerThread</strong>: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li><strong>ThreadPool</strong>: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li><strong>IntentService</strong>: 适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。</li>
</ul>


<p>了解这些系统提供的多线程工具类分别适合在什么场景下，可以帮助我们选择合适的解决方案，避免出现不可预期的麻烦。虽然使用多线程可以提高程序的并发量，但是我们需要特别注意因为引入多线程而可能伴随而来的内存问题。举个例子，在Activity内部定义的一个AsyncTask，它属于一个内部类，该类本身和外面的Activity是有引用关系的，如果Activity要销毁的时候，AsyncTask还仍然在运行，这会导致Activity没有办法完全释放，从而引发内存泄漏。所以说，多线程是提升程序性能的有效手段之一，但是使用多线程却需要十分谨慎小心，如果不了解背后的执行机制以及使用的注意事项，很可能引起严重的问题。</p>

<h2>2)Understanding Android Threading</h2>

<p>通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。</p>

<p><img src="/images/android_perf_5_thread_lifecycle.png" alt="android_perf_5_thread_lifecycle" /></p>

<p>在很多时候，线程不仅仅是线性执行一系列的任务就结束那么简单的，我们会需要增加一个任务队列，让线程不断的从任务队列中获取任务去进行执行，另外我们还可能在线程执行的任务过程中与其他的线程进行协作。如果这些细节都交给我们自己来处理，这将会是件极其繁琐又容易出错的事情。</p>

<p><img src="/images/android_perf_5_thread_thread.png" alt="android_perf_5_thread_thread" /></p>

<p>所幸的是，Android系统为我们提供了Looper，Handler，MessageQueue来帮助实现上面的线程任务模型：</p>

<p><strong>Looper</strong>: 能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。</p>

<p><img src="/images/android_perf_5_thread_looper.png" alt="android_perf_5_thread_looper" /></p>

<p><strong>Handler</strong>: 能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。</p>

<p><img src="/images/android_perf_5_thread_handler.png" alt="android_perf_5_thread_handler" /></p>

<p><strong>MessageQueue</strong>: 使用Intent，Message，Runnable作为任务的载体在不同的线程之间进行传递。</p>

<p><img src="/images/android_perf_5_thread_messagequeue.png" alt="android_perf_5_thread_messagequeue" /></p>

<p>把上面三个组件打包到一起进行协作，这就是<strong>HandlerThread</strong></p>

<p><img src="/images/android_perf_5_thread_handlerthread.png" alt="android_perf_5_thread_handlerthread" /></p>

<p>我们知道，当程序被启动，系统会帮忙创建进程以及相应的主线程，而这个主线程其实就是一个HandlerThread。这个主线程会需要处理系统事件，输入事件，系统回调的任务，UI绘制等等任务，为了避免主线程任务过重，我们就会需要不断的开启新的工作线程来处理那些子任务。</p>

<h2>3)Memory &amp; Threading</h2>

<p>增加并发的线程数会导致内存消耗的增加，平衡好这两者的关系是非常重要的。我们知道，多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a>等等。为了解决这些问题，我们会需要引入<strong>锁</strong>的概念。</p>

<p>在Android系统中也无法避免因为多线程的引入而导致出现诸如上文提到的种种问题。Android UI对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>

<p> <img src="/images/android_perf_5_memory_thread_update.png" alt="android_perf_5_memory_thread_update" /></p>

<p>另外，在非UI线程中直接持有UI对象的引用也很可能出现问题。例如Work线程中持有某个UI对象的引用，在Work线程执行完毕之前，UI对象在主线程中被从ViewHierarchy中移除了，这个时候UI对象的任何属性都已经不再可用了，另外对这个UI对象的更新操作也都没有任何意义了，因为它已经从ViewHierarchy中被移除，不再绘制到画面上了。</p>

<p><img src="/images/android_perf_5_memory_view_remove.png" alt="android_perf_5_memory_view_remove" /></p>

<p>不仅如此，View对象本身对所属的Activity是有引用关系的，如果工作线程持续保有View的引用，这就可能导致Activity无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。例如通常我们会看到在Activity里面定义的一个AsyncTask，这种类型的AsyncTask与外部的Activity是存在隐式引用关系的，只要Task没有结束，引用关系就会一直存在，这很容易导致Activity的泄漏。更糟糕的情况是，它不仅仅发生了内存泄漏，还可能导致程序异常或者崩溃。</p>

<p><img src="/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>为了解决上面的问题，我们需要谨记的原则就是：不要在任何非UI线程里面去持有UI对象的引用。系统为了确保所有的UI对象都只会被UI线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当Activity被销毁的时候，由该Activity所触发的非UI线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止UI对象被错误的使用。</p>

<h2>4)Good AsyncTask Hunting</h2>

<p>AsyncTask是一个让人既爱又恨的组件，它提供了一种简便的异步处理机制，但是它又同时引入了一些令人厌恶的麻烦。一旦对AsyncTask使用不当，很可能对程序的性能带来负面影响，同时还可能导致内存泄露。</p>

<p>举个例子，常遇到的一个典型的使用场景：用户切换到某个界面，触发了界面上的图片的加载操作，因为图片的加载相对来说耗时比较长，我们需要在子线程中处理图片的加载，当图片在子线程中处理完成之后，再把处理好的图片返回给主线程，交给UI更新到画面上。</p>

<p><img src="/images/android_perf_5_asynctask_main.png" alt="android_perf_5_asynctask_main" /></p>

<p>AsyncTask的出现就是为了快速的实现上面的使用场景，AsyncTask把在主线程里面的准备工作放到<code>onPreExecute()</code>方法里面进行执行，<code>doInBackground()</code>方法执行在工作线程中，用来处理那些繁重的任务，一旦任务执行完毕，就会调用<code>onPostExecute()</code>方法返回到主线程。</p>

<p><img src="/images/android_perf_5_asynctask_mode.png" alt="android_perf_5_asynctask_mode" /></p>

<p>使用AsyncTask需要注意的问题有哪些呢？请关注以下几点：</p>

<ul>
<li>首先，默认情况下，所有的AsyncTask任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个AsyncTask，一旦其中的某个AsyncTask执行时间过长，队列中的其他剩余AsyncTask都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。情况如下图所示：</li>
</ul>


<p><img src="/images/android_perf_5_asynctask_single_queue.png" alt="android_perf_5_asynctask_single_queue" /></p>

<p>为了解决上面提到的线性队列等待的问题，我们可以使用<code>AsyncTask.executeOnExecutor()</code>强制指定AsyncTask使用线程池并发调度任务。</p>

<p><img src="/images/android_perf_5_asynctask_thread_pool.png" alt="android_perf_5_asynctask_thread_pool" /></p>

<ul>
<li>其次，如何才能够真正的取消一个AsyncTask的执行呢？我们知道AsyncTaks有提供<code>cancel()</code>的方法，但是这个方法实际上做了什么事情呢？线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在<code>doInBackground()</code>的代码中不断的添加程序是否被中止的判断逻辑，如下图所示：</li>
</ul>


<p><img src="/images/android_perf_5_asynctask_cancel.png" alt="android_perf_5_asynctask_cancel" /></p>

<p>一旦任务被成功中止，AsyncTask就不会继续调用<code>onPostExecute()</code>，而是通过调用<code>onCancelled()</code>的回调方法反馈任务执行取消的结果。我们可以根据任务回调到哪个方法（是onPostExecute还是onCancelled）来决定是对UI进行正常的更新还是把对应的任务所占用的内存进行销毁等。</p>

<ul>
<li>最后，使用AsyncTask很容易导致内存泄漏，一旦把AsyncTask写成Activity的内部类的形式就很容易因为AsyncTask生命周期的不确定而导致Activity发生泄漏。</li>
</ul>


<p><img src="/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>综上所述，AsyncTask虽然提供了一种简单便捷的异步机制，但是我们还是很有必要特别关注到他的缺点，避免出现因为使用错误而导致的严重系统性能问题。</p>

<h2>5）Getting a HandlerThread</h2>

<p>大多数情况下，AsyncTask都能够满足多线程并发的场景需要（在工作线程执行任务并返回结果到主线程），但是它并不是万能的。例如打开相机之后的预览帧数据是通过<code>onPreviewFrame()</code>的方法进行回调的，<code>onPreviewFrame()</code>和<code>open()</code>相机的方法是执行在同一个线程的。</p>

<p><img src="/images/android_perf_5_handlerthread_camera_open.png" alt="android_perf_5_handlerthread_camera_open" /></p>

<p>如果这个回调方法执行在UI线程，那么在onPreviewFrame()里面将要执行的数据转换操作将和主线程的界面绘制，事件传递等操作争抢系统资源，这就有可能影响到主界面的表现性能。</p>

<p><img src="/images/android_perf_5_handlerthread_main_thread2.png" alt="android_perf_5_handlerthread_main_thread2" /></p>

<p>我们需要确保onPreviewFrame()执行在工作线程。如果使用AsyncTask，会因为AsyncTask默认的线性执行的特性(即使换成并发执行)会导致因为无法把任务及时传递给工作线程而导致任务在主线程中被延迟，直到工作线程空闲，才可以把任务切换到工作线程中进行执行。</p>

<p><img src="/images/android_perf_5_handlerthread_asynctask.png" alt="android_perf_5_handlerthread_asynctask" /></p>

<p>所以我们需要的是一个执行在工作线程，同时又能够处理队列中的复杂任务的功能，而HandlerThread的出现就是为了实现这个功能的，它组合了Handler，MessageQueue，Looper实现了一个长时间运行的线程，不断的从队列中获取任务进行执行的功能。</p>

<p><img src="/images/android_perf_5_handlerthread_outline.png" alt="android_perf_5_handlerthread_outline" /></p>

<p>回到刚才的处理相机回调数据的例子，使用HandlerThread我们可以把open()操作与onPreviewFrame()的操作执行在同一个线程，同时还避免了AsyncTask的弊端。如果需要在onPreviewFrame()里面更新UI，只需要调用runOnUiThread()方法把任务回调给主线程就够了。</p>

<p><img src="/images/android_perf_5_handlerthread_camera.png" alt="android_perf_5_handlerthread_camera" /></p>

<p>HandlerThread比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。</p>

<p>另外很重要的一点是，一旦我们使用了HandlerThread，需要特别注意给HandlerThread设置不同的线程优先级，CPU会根据设置的不同线程优先级对所有的线程进行调度优化。</p>

<p><img src="/images/android_perf_5_handlerthread_priority.png" alt="android_perf_5_handlerthread_priority" /></p>

<p>掌握HandlerThread与AsyncTask之间的优缺点，可以帮助我们选择合适的方案。</p>

<h2>6）Swimming in Threadpools</h2>

<p>线程池适合用在把任务进行分解，并发进行执行的场景。通常来说，系统里面会针对不同的任务设置一个单独的守护线程用来专门处理这项任务。例如使用Networking Thread用来专门处理网络请求的操作，使用IO Thread用来专门处理系统的I\O操作。针对那些场景，这样设计是没有问题的，因为对应的任务单次执行的时间并不长而且可以是顺序执行的。但是这种专属的单线程并不能满足所有的情况，例如我们需要一次性decode 40张图片，每个线程需要执行4ms的时间，如果我们使用专属单线程的方案，所有图片执行完毕会需要花费160ms(40*4)，但是如果我们创建10个线程，每个线程执行4个任务，那么我们就只需要16ms就能够把所有的图片处理完毕。</p>

<p><img src="/images/android_perf_5_threadpool_1.png" alt="android_perf_5_threadpool_1" /></p>

<p>为了能够实现上面的线程池模型，系统为我们提供了<code>ThreadPoolExecutor</code>帮助类来简化实现，剩下需要做的就只是对任务进行分解就好了。</p>

<p><img src="/images/android_perf_5_threadpool_2.png" alt="android_perf_5_threadpool_2" /></p>

<p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为CPU只能同时执行固定数量的线程数，一旦同时并发的线程数量超过CPU能够同时执行的阈值，CPU就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>

<p><img src="/images/android_perf_5_threadpool_3.png" alt="android_perf_5_threadpool_3" /></p>

<p>一旦同时并发的线程数量达到一定的量级，这个时候CPU在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少64K+的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>

<p><img src="/images/android_perf_5_threadpool_4.png" alt="android_perf_5_threadpool_4" /></p>

<p>另外需要关注的一个问题是：<code>Runtime.getRuntime().availableProcesser()</code>方法并不可靠，他返回的值并不是真实的CPU核心数，因为CPU会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的CPU核心数。</p>

<h2>7）The Zen of IntentService</h2>

<p>默认的Service是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的AsyncTask与HandlerThread，我们还可以选择使用IntentService来实现异步操作。IntentService继承自普通Service同时又在内部创建了一个HandlerThread，在<code>onHandlerIntent()</code>的回调里面处理扔到IntentService的任务。所以IntentService就不仅仅具备了异步线程的特性，还同时保留了Service不受主页面生命周期影响的特点。</p>

<p><img src="/images/android_perf_5_intentservice_outline.png" alt="android_perf_5_intentservice_outline" /></p>

<p>如此一来，我们可以在IntentService里面通过设置闹钟间隔性的触发异步任务，例如刷新数据，更新缓存的图片或者是分析用户操作行为等等，当然处理这些任务需要小心谨慎。</p>

<p>使用IntentService需要特别留意以下几点：</p>

<ul>
<li>首先，因为IntentService内置的是HandlerThread作为异步线程，所以每一个交给IntentService的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</li>
<li>其次，通常使用到IntentService的时候，我们会结合使用BroadcastReceiver把工作线程的任务执行结果返回给主UI线程。使用广播容易引起性能问题，我们可以使用LocalBroadcastManager来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用<code>runOnUiThread()</code>快速回调到主UI线程。</li>
<li>最后，包含正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>


<h2>8）Threading and Loaders</h2>

<p>当启动工作线程的Activity被销毁的时候，我们应该做点什么呢？为了方便的控制工作线程的启动与结束，Android为我们引入了Loader来解决这个问题。我们知道Activity有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在Activity不停的创建与销毁的过程当中，很有可能因为工作线程持有Activity的View而导致内存泄漏(因为工作线程很可能持有View的强引用，另外工作线程的生命周期还无法保证和Activity的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在Activity被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。</p>

<p><img src="/images/android_perf_5_loader_bad.png" alt="android_perf_5_loader_bad" /></p>

<p>Loader的出现就是为了确保工作线程能够和Activity的生命周期保持一致，同时避免出现前面提到的问题。</p>

<p><img src="/images/android_perf_5_loader_good.png" alt="android_perf_5_loader_good" /></p>

<p>LoaderManager会对查询的操作进行缓存，只要对应Cursor上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader可以直接把缓存的数据回调到<code>onLoadFinished()</code>，从而避免重新查询数据。另外系统会在Loader不再需要使用到的时候(例如使用Back按钮退出当前页面)回调<code>onLoaderReset()</code>方法，我们可以在这里做数据的清除等等操作。</p>

<p>在Activity或者Fragment中使用Loader可以方便的实现异步加载的框架，Loader有诸多优点。但是实现Loader的这套代码还是稍微有点点复杂，Android官方为我们提供了使用Loader的<a href="http://developer.android.com/intl/zh-cn/reference/android/content/AsyncTaskLoader.html">示例代码</a>进行参考学习。</p>

<h2>9）The Importance of Thread Priority</h2>

<p>理论上来说，我们的程序可以创建出非常多的子线程一起并发执行的，可是基于CPU时间片轮转调度的机制，不可能所有的线程都可以同时被调度执行，CPU需要根据线程的优先级赋予不同的时间片。</p>

<p><img src="/images/android_perf_5_threadpriority_CPU.png" alt="android_perf_5_threadpriority_CPU" /></p>

<p>Android系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为forground的那部分线程会大致占用掉CPU的90%左右的时间片，background的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为forground的程序本身的优先级就更高，理应得到更多的执行时间。</p>

<p><img src="/images/android_perf_5_threadpriority_90.png" alt="android_perf_5_threadpriority_90" /></p>

<p>默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主UI线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占CPU资源，需要把这些线程的优先级进行降低处理，这样才能给帮组CPU识别主次，提高主线程所能得到的系统资源。</p>

<p><img src="/images/android_perf_5_threadpriority_less.png" alt="android_perf_5_threadpriority_less" /></p>

<p>在Android系统里面，我们可以通过<code>android.os.Process.setThreadPriority(int)</code>设置线程的优先级，参数范围从-20到24，数值越小优先级越高。Android系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。</p>

<p><img src="/images/android_perf_5_threadpriority_const.png" alt="android_perf_5_threadpriority_const" /></p>

<p>大多数情况下，新创建的线程优先级会被设置为默认的0，主线程设置为0的时候，新创建的线程还可以利用<code>THREAD_PRIORITY_LESS_FAVORABLE</code>或者<code>THREAD_PRIORITY_MORE_FAVORABLE</code>来控制线程的优先级。</p>

<p><img src="/images/android_perf_5_threadpriority_value.png" alt="android_perf_5_threadpriority_value" /></p>

<p>Android系统里面的AsyncTask与IntentService已经默认帮助我们设置线程的优先级，但是对于那些非官方提供的多线程工具类，我们需要特别留意根据需要自己手动来设置线程的优先级。</p>

<p><img src="/images/android_perf_5_threadpriority_asynctask.png" alt="android_perf_5_threadpriority_asynctask" />
<img src="/images/android_perf_5_threadpriority_intentservice.png" alt="android_perf_5_threadpriority_intentservice" /></p>

<h2>10）Profile GPU Rendering : M Update</h2>

<p>从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process，Execute，Update三大步骤的时间耗费情况。</p>

<p><img src="/images/android_perf_5_gpu_profiling_old.png" alt="android_perf_5_gpu_profiling_old" /></p>

<p>但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在Android M版本开始，GPU Profiling工具把渲染操作拆解成如下8个详细的步骤进行显示。</p>

<p><img src="/images/android_perf_5_gpu_profiling_8steps.png" alt="android_perf_5_gpu_profiling_8steps" /></p>

<p>旧版本中提到的Proces，Execute，Update还是继续得到了保留，他们的对应关系如下：</p>

<p><img src="/images/android_perf_5_gpu_profiling_3steps.png" alt="android_perf_5_gpu_profiling_3steps" /></p>

<p>接下去我们看下其他五个步骤分别代表了什么含义：</p>

<ul>
<li><strong>Sync &amp; Upload</strong>：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</li>
<li><strong>Measure &amp; Layout</strong>：这里表示的是布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</li>
<li><strong>Animation</strong>：表示的是计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</li>
<li><strong>Input Handling</strong>：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</li>
<li><strong>Misc/Vsync Delay</strong>：如果稍加注意，我们可以在开发应用的Log日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况。</li>
</ul>


<!-- ![android_perf_5_gpu_profiling_sync_upload](/images/android_perf_5_gpu_profiling_sync_upload.png) -->


<!-- ![android_perf_5_gpu_profiling_vsync](/images/android_perf_5_gpu_profiling_vsync.png)
 -->


<!-- ![android_perf_5_gpu_profiling_measure](/images/android_perf_5_gpu_profiling_measure.png) -->


<p>上面八种不同的颜色区分了不同的操作所耗费的时间，为了便于我们迅速找出那些有问题的步骤，GPU Profiling工具会显示16ms的阈值线，这样就很容易找出那些不合理的性能问题，再仔细看对应具体哪个步骤相对来说耗费时间比例更大，结合上面介绍的细化步骤，从而快速定位问题，修复问题。</p>

<hr />

<p>首发于CSDN：<a href="http://ms.csdn.net/geek/71031">Android性能优化典范（五）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第4季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-4/"/>
    <updated>2015-12-31T23:39:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-4</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_4.png" alt="android_perf_patterns_season_4" /></p>

<blockquote><p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第4季的课程学习笔记终于在2015年的最后一天完成了，文章共17个段落，包含的内容大致有：优化网络请求的行为，优化安装包的资源文件，优化数据传输的效率，性能优化的几大基础原理等等。因为学习认知水平有限，肯定存在不少理解偏差甚至错误的地方，请多多交流指正！</p></blockquote>

<h2>1)Cachematters for networking</h2>

<p>想要使得Android系统上的网络访问操作更加的高效就必须做好网络数据的缓存。这是提高网络访问性能最基础的步骤之一。从手机的缓存中直接读取数据肯定比从网络上获取数据要更加的便捷高效，特别是对于那些会被频繁访问到的数据，需要把这些数据缓存到设备上，以便更加快速的进行访问。</p>

<p>Android系统上关于网络请求的Http Response Cache是默认关闭的，这样会导致每次即使请求的数据内容是一样的也会需要重复被调用执行，效率低下。我们可以通过下面的代码示例开启<a href="http://developer.android.com/reference/android/net/http/HttpResponseCache.html">HttpResponseCache</a>。</p>

<!-- More -->


<p><img src="/images/android_perf_4_network_cache_enable.png" alt="android_perf_4_network_cache_enable" /></p>

<p>开启Http Response Cache之后，Http操作相关的返回数据就会缓存到文件系统上，不仅仅是主程序自己编写的网络请求相关的数据会被缓存，另外引入的library库中的网络相关的请求数据也会被缓存到这个Cache中。</p>

<p>网络请求的场景有可以是普通的http请求，也可以打开某个URL去获取数据，如下图所示：</p>

<p><img src="/images/android_perf_4_network_cache_code.png" alt="android_perf_4_network_cache_code" /></p>

<p>我们有两种方式来清除<code>HttpResponseCache</code>的缓存数据：第一种方式是缓存溢出的时候删除最旧最老的文件，第二种方式是通过Http返回Header中的<code>Cache-Control</code>字段来进行控制的。如下图所示：</p>

<p><img src="/images/android_perf_4_network_cache_control.png" alt="android_perf_4_network_cache_control" /></p>

<p>通常来说，<code>HttpResponseCache</code>会缓存所有的返回信息，包括实际的数据与Header的部分.一般情况下，这个Cache会自动根据协议返回<code>Cache-Control</code>的内容与当前缓存的数据量来决定哪些数据应该继续保留，哪些数据应该删除。但是在一些极端的情况下，例如服务器返回的数据没有设置Cache废弃的时间，或者是本地的Cache文件系统与返回的缓存数据有冲突，或者是某些特殊的网络环境导致HttpResponseCache工作异常，在这些情况下就需要我们自己来实现Http的缓存Cache。</p>

<p>实现自定义的http缓存，需要解决两个问题：第一个是实现一个DiskCacheManager，另外一个是制定Cache的缓存策略。关于DiskCacheManager，我们可以扩展Android系统提供的<a href="https://developer.android.com/intl/zh-cn/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">DiskLruCache</a>来实现。而Cache的缓存策略，相对来说复杂一些，我们可能需要把部分JSON数据设计成不能缓存的，另外一些JSON数据设计成可以缓存几天的，把缩略图设计成缓存一两天的等等，为不同的数据类型根据他们的使用特点制定不同的缓存策略。</p>

<p><img src="/images/android_perf_4_network_cache_diff.png" alt="android_perf_4_network_cache_diff" /></p>

<p>想要比较好的实现这两件事情，如果全部自己从头开始写会比较繁琐复杂，所幸的是，有不少著名的开源框架帮助我们快速的解决了那些问题。我们可以使用<a href="https://developer.android.com/training/volley/index.html">Volly</a>，<a href="http://square.github.io/okhttp/">okHTTP</a>，<a href="http://square.github.io/picasso/">Picasso</a>来实现网络缓存。</p>

<p>实现好网络缓存之后，我们可以使用Android Studio里面的<code>Network Traffic Tools</code>来查看网络数据的请求与返回情况，另外我们还可以使用<a href="https://developer.att.com/application-resource-optimizer">AT&amp;T ARO</a>工具来抓取网络数据包进行分析查看。</p>

<h2>2)Optimizing Network Request Frequencies</h2>

<p>应用程序的一个基础功能是能够保持确保界面上呈现的信息是即时最新的，例如呈现最新的新闻，天气，信息流等等信息。但是，过于频繁的促使手机客户端应用去同步最新的服务器数据会对性能产生很大的负面影响，不仅仅使得CPU不停的在工作，内存，网络流量，电量等等都会持续的被消耗，所以在进行网络请求操作的时候一定要避免多度同步操作。</p>

<p>退到后台的应用为了能够在切换回前台的时候呈现最新的数据，会偷偷在后台不停的做同步的操作。这种行为会带来很严重的问题，首先因为网络请求的行为异常的耗电，其次不停的进行网络同步会耗费很多带宽流量。</p>

<p>为了能够尽量的减少不必要的同步操作，我们需要遵守下面的一些规则：</p>

<ul>
<li>首先我们要对网络行为进行分类，区分需要立即更新数据的行为和其他可以进行延迟的更新行为，为不同的场景进行差异化处理。</li>
<li>其次要避免客户端对服务器的轮询操作，这样会浪费很多的电量与带宽流量。解决这个问题，我们可以使用Google Cloud Message来对更新的数据进行推送。</li>
<li>然后在某些必须做同步的场景下，需要避免使用固定的间隔频率来进行更新操作，我们应该在返回的数据无更新的时候，使用双倍的间隔时间来进行下一次同步。</li>
<li>最后更进一步，我们还可以通过判断当前设备的状态来决定同步的频率，例如判断设备处于休眠，运动等不同的状态设计各自不同时间间隔的同步频率。</li>
</ul>


<p><img src="/images/android_perf_4_network_frequencies_backoff.png" alt="android_perf_4_network_frequencies_backoff" /></p>

<p>另外，我们还可以通过判断设备是否连接上WiFi，是否正在充电来决定更新的频率。为了能够方便的实现这个功能，Android为我们提供了<a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmNetworkManager">GCMNetworkManager</a>来判断设备当下的状态，从而设计更加高效的网络同步操作，如下图所示：</p>

<p><img src="/images/android_perf_4_network_frequencies_gcm.png" alt="android_perf_4_network_frequencies_gcm" /></p>

<h2>3)Effective Prefetching</h2>

<p>关于提升网络操作的性能，除了避免频繁的网络同步操作之外，还可以使用捆绑批量访问的方式来减少访问的频率，为了达到这个目的，我们就需要了解Prefetching。</p>

<p>举个例子，在某个场景下，一开始发出了网络请求得到了某张图片，隔了10s之后，发出第二次请求想要拿到另外一张图片，再隔了6s发出第三张图片的网络请求。这会导致设备的无线蜂窝一直处于高消耗的状态。Prefetching就是预先判定那些可能马上就会使用到的网络资源，捆绑一起集中进行网络请求。这样能够极大的减少电量的消耗，提升设备的续航时间。</p>

<p><img src="/images/android_perf_4_prefetching_bundle.png" alt="android_perf_4_prefetching_bundle" /></p>

<p>使用Prefetching的难点在于如何判断事先获取的数据量到底是多少，如果预取的数据量偏少，那么就起不到什么效果，但是如果预取过多，又可能导致访问的时间过长。</p>

<p><img src="/images/android_perf_4_prefetching_tricky.png" alt="android_perf_4_prefetching_tricky" /></p>

<p>那么问题来了，到底预取多少才比较合适呢？一个比较普适的规则是，在3G网络下可以预取1-5Mb的数据量，或者是按照提前预期后续1-2分钟的数据作为基线标准。在实际的操作当中，我们还需要考虑当前的网络速度来决定预取的数据量，例如在同样的时间下，4G网络可以获取到12张图片的数据，而2G网络则只能拿到3张图片的数据。所以，我们还需要把当前的网络环境情况添加到设计预取数据量的策略当中去。判断当前设备的状态与网络情况，可以使用前面提到过的<a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmNetworkManager">GCMNetworkManager</a>。</p>

<h2>4)Adapting to Latency</h2>

<p>网络延迟通常来说很容易被用户察觉到，严重的网络延迟会对用户体验造成很大的影响，用户很容易抱怨应用程序写的不好。</p>

<p>一个典型的网络操作行为，通常包含以下几个步骤：首先手机端发起网络请求，到达网络服务运营商的基站，再转移到服务提供者的服务器上，经过解码之后，接着访问本地的存储数据库，获取到数据之后，进行编码，最后按照原来传递的路径逐层返回。如下图所示：</p>

<p><img src="/images/android_perf_4_network_latency.png" alt="android_perf_4_network_latency" /></p>

<p>在上面的网络请求链路当中的任何一个环节都有可能导致严重的延迟，成为性能瓶颈，但是这些环节可能出现的问题，客户端应用是无法进行调节控制的，应用能够做的就只是根据当前的网络环境选择当下最佳的策略来降低出现网络延迟的概率。主要的实施步骤有两步：第1步检测收集当前的网络环境信息，第2步根据当前收集到的信息进行网络请求行为的调整。</p>

<p>关于第1步检测当前的网络环境，我们可以使用系统提供的API来获取到相关的信息，如下图所示：</p>

<p><img src="/images/android_perf_4_network_latency_detect.png" alt="android_perf_4_network_latency_detect" /></p>

<p>通过上面的示例，我们可以获取到移动网络的详细子类型，例如4G(LTE),3G等等，详细分类见下图，获取到详细的移动网络类型之后，我们可以根据当前网络的速率来调整网络请求的行为：</p>

<p><img src="/images/android_perf_4_network_latency_subtype.png" alt="android_perf_4_network_latency_subtype" /></p>

<p>关于第2步根据收集到的信息进行策略的调整，通常来说，我们可以把网络请求延迟划分为三档：例如把网络延迟小于60ms的划分为GOOD，大于220ms的划分为BAD，介于两者之间的划分为OK（这里的60ms，220ms会需要根据不同的场景提前进行预算推测）。如果网络延迟属于GOOD的范畴，我们就可以做更多比较激进的预取数据的操作，如果网络延迟属于BAD的范畴，我们就应该考虑把当下的网络请求操作Hold住等待网络状况恢复到GOOD的状态再进行处理。</p>

<p><img src="/images/android_perf_4_network_latency_three_category.png" alt="android_perf_4_network_latency_three_category" /></p>

<p>前面提到说60ms，220ms是需要提前自己预测的，可是预测的工作相当复杂。首先针对不同的机器与网络环境，网络延迟的三档阈值都不太一样，出现的概率也不尽相同，我们会需要针对这些不同的用户与设备选择不同的阈值进行差异化处理：</p>

<p><img src="/images/android_perf_4_network_latency_three_level.png" alt="android_perf_4_network_latency_three_level" /></p>

<p>Android官方为了帮助我们设计自己的网络请求策略，为我们提供了模拟器的网络流量控制功能来对实际环境进行模拟测量，或者还可以使用AT&amp;T提供的<a href="http://developer.att.com/developer/legalAgreementPage.jsp?passedItemId=14500040">AT&amp;T Network Attenuator</a>来帮助预估网络延迟。</p>

<h2>5)Minimizing Asset Payload</h2>

<p>为了能够减小网络传输的数据量，我们需要对传输的数据做压缩的处理，这样能够提高网络操作的性能。首先不同的网络环境，下载速度以及网络延迟是存在差异的，如下图所示：</p>

<p><img src="/images/android_perf_4_min_asset_load.png" alt="android_perf_4_min_asset_load" /></p>

<p>如果我们选择在网速更低的网络环境下进行数据传输，这就意味着需要执行更长的时间，而更长的网络操作行为，会导致电量消耗更加严重。另外传输的数据如果不做压缩处理，也同样会增加网络传输的时间，消耗更多的电量。不仅如此，未经过压缩的数据，也会消耗更多的流量，使得用户需要付出更多的流量费。</p>

<p>通常来说，网络传输数据量的大小主要由两部分组成：图片与序列化的数据，那么我们需要做的就是减少这两部分的数据传输大小，分下面两个方面来讨论。</p>

<ul>
<li>A)首先需要做的是减少图片的大小，选择合适的图片保存格式是第一步。下图展示了PNG,JPEG,WEBP三种主流格式在占用空间与图片质量之间的对比：</li>
</ul>


<p><img src="/images/android_perf_4_min_asset_png_jpeg_webp.png" alt="android_perf_4_min_asset_png_jpeg_webp" /></p>

<p>对于JPEG与WEBP格式的图片，不同的清晰度对占用空间的大小也会产生很大的影响，适当的减少JPG Quality，可以大大的缩小图片占用的空间大小。</p>

<p>另外，我们需要为不同的使用场景提供当前场景下最合适的图片大小，例如针对全屏显示的情况我们会需要一张清晰度比较高的图片，而如果只是显示为缩略图的形式，就只需要服务器提供一个相对清晰度低很多的图片即可。服务器应该支持到为不同的使用场景分别准备多套清晰度不一样的图片，以便在对应的场景下能够获取到最适合自己的图片。这虽然会增加服务端的工作量，可是这个付出却十分值得！</p>

<ul>
<li>B)其次需要做的是减少序列化数据的大小。JSON与XML为了提高可读性，在文件中加入了大量的符号，空格等等字符，而这些字符对于程序来说是没有任何意义的。我们应该使用Protocal Buffers，Nano-Proto-Buffers，FlatBuffer来减小序列化的数据的大小。</li>
</ul>


<p>Android系统为我们提供了工具来查看网络传输的数据情况，打开Android Studio的Monitor，里面有网络访问的模块。或者是打开AT&amp;T提供的<a href="https://developer.att.com/application-resource-optimizer">ARO</a>工具来查看网络请求状态。</p>

<h2>6)Service Performance Patterns</h2>

<p>Service是Android程序里面最常用的基础组件之一，但是使用Service很容易引起电量的过度消耗以及系统资源的未及时释放。学会在何时启用Service以及使用何种方式杀掉Service就显得十分有必要了。</p>

<p>简要过一下Service的特性：Service和UI没有关联，Service的创建，执行，销毁Service都是需要占用系统时间和内存的。另外Service是默认运行在UI线程的，这意味着Service可能会影响到系统的流畅度。</p>

<p>使用Service应该遵循下面的一些规则：</p>

<ul>
<li>避免错误的使用Service，例如我们不应该使用Service来监听某些事件的变化，不应该搞一个Service在后台对服务器不断的进行轮询(应该使用Google Cloud Messaging)</li>
<li>如果已经事先知道Service里面的任务应该执行在后台线程(非默认的主线程)的时候，我们应该使用IntentService或者结合HanderThread，AsycnTask Loader实现的Service。</li>
</ul>


<p>Android系统为我们提供了以下的一些异步相关的工具类</p>

<ul>
<li>GCM</li>
<li>BroadcastReciever</li>
<li>LocalBroadcastReciever</li>
<li>WakefulBroadcastReciver</li>
<li>HandlerThreads</li>
<li>AsyncTaskLoaders</li>
<li>IntentService</li>
</ul>


<p>如果使用上面的诸多方案还是无法替代普通的Service，那么需要注意的就是如何正确的关闭Service。</p>

<ul>
<li>普通的Started Service，需要通过stopSelf()来停止Service</li>
</ul>


<p><img src="/images/android_perf_4_service_started.png" alt="android_perf_4_service_started" /></p>

<ul>
<li>另外一种Bound Service，会在其他组件都unBind之后自动关闭自己</li>
</ul>


<p><img src="/images/android_perf_4_service_bound.png" alt="android_perf_4_service_bound" /></p>

<p>把上面两种Service进行合并之后，我们可以得到如下图所示的Service(相关知识，还可以参考<a href="http://hukai.me/android-notes-services/">http://hukai.me/android-notes-services/</a>, <a href="http://hukai.me/android-notes-bound-services/">http://hukai.me/android-notes-bound-services/</a>)</p>

<p><img src="/images/android_perf_4_service_mix.png" alt="android_perf_4_service_mix" /></p>

<h2>7)Removing unused code</h2>

<p>使用第三方库(library)可以在不用自己编写大量代码的前提下帮助我们解决一些难题，节约大量的时间，但是这些引入的第三方库很可能会导致主程序代码臃肿冗余。</p>

<p>如果我们处在人力，财力都相对匮乏的情况下，通常会倾向大量使用第三方库来帮助编写应用程序。这其实是无可厚非的，那些著名的第三方库的可行性早就被很多应用所采用并实践证明过。但是这里面存在的问题是，如果我们因为只需要某个library的一小部分功能而把整个library都导入自己的项目，这就会引起代码臃肿。一旦发生代码臃肿，用户就会下载到安装包偏大的应用程序，另外因为代码臃肿，还很有可能会超过单个编译文件只能有65536个方法的上限。解决这个问题的办法是使用<strong>MultiDex</strong>的方案，可是这实在是无奈之举，原则上，我们还是应该尽量避免出现这种情况。</p>

<p>Android为我们提供了Proguard的工具来帮助应用程序对代码进行瘦身，优化，混淆的处理。它会帮助移除那些没有使用到的代码，还可以对类名，方法名进行混淆处理以避免程序被反编译。举个例子，Google I/O 2015这个应用使用了大量的library，没有经过Proguard处理之前编译出来的包是8.4Mb大小，经过处理之后的包仅仅是4.1Mb大小。</p>

<p>使用Proguard相当的简单，只需要在build.gradle文件中配置minifEnable为true即可，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_code_proguard.png" alt="android_perf_4_remove_unused_code_proguard" /></p>

<p>但是Proguard还是不足够聪明到能够判断哪些类，哪些方法是不能够被混淆的，针对这些情况，我们需要手动的把这些需要保留的类名与方法名添加到Proguard的配置文件中，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_code_proguard_setting.png" alt="android_perf_4_remove_unused_code_proguard_setting" /></p>

<p>在使用library的时候，需要特别注意这些library在proguard配置上的说明文档，我们需要把这些配置信息添加到自己的主项目中。关于Proguard的详细说明，请看官方文档<a href="http://developer.android.com/tools/help/proguard.html">http://developer.android.com/tools/help/proguard.html</a></p>

<h2>8)Removing unused resources</h2>

<p>减少APK安装包的大小也是Android程序优化中很重要的一个方面，我们不应该给用户下载到一个臃肿的安装包。假设这样一个场景，我们引入了Google Play Service的library，是想要使用里面的Maps的功能，但是里面的登入等等其他功能是不需要的，可是这些功能相关的代码与图片资源，布局资源如果也被引入我们的项目，这样就会导致我们的程序安装包臃肿。</p>

<p>所幸的是，我们可以使用Gradle来帮助我们分析代码，分析引用的资源，对于那些没有被引用到的资源，会在编译阶段被排除在APK安装包之外，要实现这个功能，对我们来说仅仅只需要在build.gradle文件中配置shrinkResource为true就好了，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_resource.png" alt="android_perf_4_remove_unused_resource" /></p>

<p>为了辅助gradle对资源进行瘦身，或者是某些时候的特殊需要，我们可以通过tools:keep或者是tools:discard标签来实现对特定资源的保留与废弃，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_resource_tools.png" alt="android_perf_4_remove_unused_resource_tools" /></p>

<p>Gradle目前无法对values，drawable等根据运行时来决定使用的资源进行优化，对于这些资源，需要我们自己来确保资源不会有冗余。</p>

<h2>9)Perf Theory: Caching</h2>

<p>当我们讨论性能优化的时候，缓存是最常见最有效的策略之一。无论是为了提高CPU的计算速度还是提高数据的访问速度，在绝大多数的场景下，我们都会使用到缓存。关于缓存是如何提高效率的，这里就不赘述了。</p>

<p>那么在什么地方，在何时应该利用好缓存来提高效率呢？请看下面的例子，很明显的演示了在某些细节上是如何利用缓存的原理来提高代码的执行效率的：</p>

<p><img src="/images/android_perf_4_cache_1.png" alt="android_perf_4_cache_1" />
<img src="/images/android_perf_4_cache_2.png" alt="android_perf_4_cache_2" /></p>

<p>类似上面的例子采用缓存原理的地方还有很多，例如缓存到内存里面的图片资源，网络请求返回数据的缓存等等。总之，使用缓存就是为了减少不必要的操作，尽量复用已有的对象来提高效率。</p>

<h2>10)Perf Theory: Approximation(近似法)</h2>

<p>很多时候，我们都需要学会在性能更优与体验更好之间做一定的权衡取舍。为了获取更好的表现性能，我们可能会需要牺牲一些用户体验，例如把某些细节做删除或者是降级处理以便有更好的性能。例如，导航类的应用，如果在导航期间是不停的执行定位的操作，这样能够很及时的获取到最新的位置信息以及当下位置相关的其他提示信息，但是这样会导致网络流量以及手机电量的过度消耗。所以我们可以做一定的降级处理，每隔固定的一段时间才去获取一次位置信息，损失一点及时性来换取更长的续航时间。</p>

<p>还有很多地方都会用到近似法则来优化程序的性能，例如使用一张比较接近实际大小的图片来替代原图，换取更快的加载速度。所以对于那些对计算结果要求不需要十分精确的场景，我们可以使用近似法则来提高程序的性能。</p>

<h2>11)Perf Theory: Culling(遴选，挑选)</h2>

<p>在以前的性能优化课程里面，我们知道可以通过减少Overdraw来提高程序的渲染性能（主要手段有移除非必须的background，减少重叠的布局，使用clipRect来提高自定义View的绘制性能），今天在这里要介绍的另外一个提高性能的方法是逐步对数据进行过滤筛选，减小搜索的数据集，以此提高程序的执行性能。例如我们需要搜索到居住在某个地方，年龄是多少，符合某些特定条件的候选人，就可以通过逐层过滤筛选的方式来提高后续搜索的执行效率。</p>

<h2>12)Perf Theory: Threading</h2>

<p>使用多线程并发处理任务，从某种程度上可以快速提高程序的执行性能。对于Android程序来说，主线程通常也成为UI线程，需要处理UI的渲染，响应用户的操作等等。对于那些可能影响到UI线程的任务都需要特别留意是否有必要放到其他的线程来进行处理。如果处理不当，很有可能引起程序ANR。关于多线程的使用建议，可以参考官方的培训课程<a href="http://developer.android.com/training/best-background.html">http://developer.android.com/training/best-background.html</a></p>

<h2>13)Perf Theory: Batching</h2>

<p>关于Batching，在前几季的性能优化课程里面也不止一次提到，下面使用一张图演示下Batching的原理：</p>

<p><img src="/images/android_perf_4_batching.png" alt="android_perf_4_batching" /></p>

<p>网络请求的批量执行是另外一个比较适合说明batching使用场景的例子，因为每次发起网络请求都相对来说比较耗时耗电，如果能够做到批量一起执行，可以大大的减少电量的消耗。</p>

<p><img src="/images/android_perf_4_batching_network.png" alt="android_perf_4_batching_network" /></p>

<h2>14)Serialization performance</h2>

<p>数据的序列化是程序代码里面必不可少的组成部分，当我们讨论到数据序列化的性能的时候，需要了解有哪些候选的方案，他们各自的优缺点是什么。首先什么是序列化？用下面的图来解释一下：</p>

<p><img src="/images/android_perf_4_serialIzation.png" alt="android_perf_4_serialIzation" /></p>

<p>数据序列化的行为可能发生在数据传递过程中的任何阶段，例如网络传输，不同进程间数据传递，不同类之间的参数传递，把数据存储到磁盘上等等。通常情况下，我们会把那些需要序列化的类实现Serializable接口(如下图所示)，但是这种传统的做法效率不高，实施的过程会消耗更多的内存。</p>

<p><img src="/images/android_perf_4_serialIzation_implement.png" alt="android_perf_4_serialIzation_implement" /></p>

<p>但是我们如果使用GSON库来处理这个序列化的问题，不仅仅执行速度更快，内存的使用效率也更高。Android的XML布局文件会在编译的阶段被转换成更加复杂的格式，具备更加高效的执行性能与更高的内存使用效率。</p>

<p><img src="/images/android_perf_4_serialIzation_gson.png" alt="android_perf_4_serialIzation_gson" /></p>

<p>下面介绍三个数据序列化的候选方案：</p>

<ul>
<li><strong><a href="https://developers.google.com/protocol-buffers/?utm_campaign=android_series_serialization_performance_101315&amp;utm_source=anddev&amp;utm_medium=yt-annt">Protocal Buffers</a></strong>：强大，灵活，但是对内存的消耗会比较大，并不是移动终端上的最佳选择。</li>
<li><strong><a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt?utm_campaign=android_series_serialization_performance_101315&amp;utm_source=anddev&amp;utm_medium=yt-annt">Nano-Proto-Buffers</a></strong>：基于Protocal，为移动终端做了特殊的优化，代码执行效率更高，内存使用效率更佳。</li>
<li><strong><a href="https://google.github.io/flatbuffers/">FlatBuffers</a></strong>：这个开源库最开始是由Google研发的，专注于提供更优秀的性能。</li>
</ul>


<p>上面这些方案在性能方面的数据对比如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_filesize.png" alt="android_perf_4_serialIzation_filesize" />
<img src="/images/android_perf_4_serialIzation_encode.png" alt="android_perf_4_serialIzation_encode" /></p>

<p>为了避免序列化带来的性能问题，我们其实可以考虑使用SharedPreference或者SQLite来存储那些数据，避免需要先把那些复杂的数据进行序列化的操作。</p>

<h2>15)Smaller Serialized Data</h2>

<p>数据呈现的顺序以及结构会对序列化之后的空间产生不小的影响。通常来说，一般的数据序列化的过程如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json.png" alt="android_perf_4_serialIzation_java_2_json" /></p>

<p>上面的过程，存在两个弊端，第一个是重复的属性名称：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json_dup.png" alt="android_perf_4_serialIzation_java_2_json_dup" /></p>

<p>另外一个是GZIP没有办法对上面的数据进行更加有效的压缩，假如相似数据间隔了32k的数据量，这样GZIP就无法进行更加有效的压缩：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json_gzip.png" alt="android_perf_4_serialIzation_java_2_json_gzip" /></p>

<p>但是我们稍微改变下数据的记录方式，就可以得到占用空间更小的数据，如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json2.png" alt="android_perf_4_serialIzation_java_2_json2" /></p>

<p>通过优化，至少有三方面的性能提升，如下图所示：</p>

<p>1）减少了重复的属性名：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_1.png" alt="android_perf_4_serialIzation_opt_1" /></p>

<p>2）使得GZIP的压缩效率更高：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_2.png" alt="android_perf_4_serialIzation_opt_2" /></p>

<p>3）同样的数据类型可以批量优化：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_3.png" alt="android_perf_4_serialIzation_opt_3" /></p>

<h2>16)Caching UI data</h2>

<p>如今绝大多数的应用界面上呈现的数据都依赖于网络请求返回的结果，如何做到在网络数据返回之前避免呈现一个空白的等待页面呢（当然这里说的是非首次冷启动的情况）？这就会涉及到如何缓存UI界面上的数据。</p>

<p>缓存UI界面上的数据，可以采用方案有存储到文件系统，Preference，SQLite等等，做了缓存之后，这样就可以在请求数据返回结果之前，呈现给用户旧的数据，而不是使用正在加载的方式让用户什么数据都看不到，当然在请求网络最新数据的过程中，需要有正在刷新的提示。至于到底选择哪个方案来对数据进行缓存，就需要根据具体情况来做选择了。</p>

<h2>17)CPU Frequency Scaling</h2>

<p>调节CPU的频率会执行的性能产生较大的影响，为了最大化的延长设备的续航时间，系统会动态调整CPU的频率，频率越高执行代码的速度自然就越快。</p>

<p><img src="/images/android_perf_4_CPU.png" alt="android_perf_4_CPU" /></p>

<p>Android系统会在电量消耗与表现性能之间不断的做权衡，当有需要的时候会迅速调整CPU的频率到一个比较高负荷的状态，当程序不需要高性能的时候就会降低频率来确保更长的续航时间。</p>

<p><img src="/images/android_perf_4_CPU_adjust.png" alt="android_perf_4_CPU_adjust" /></p>

<p>Android系统检测到需要调整CPU的频率到CPU频率真的达到对应频率会需要花费大概20ms的时间，在此期间很有可能会因为CPU频率不够而导致代码执行偏慢。</p>

<p><img src="/images/android_perf_4_CPU_gap.png" alt="android_perf_4_CPU_gap" /></p>

<p>我们可以使用Systrace工具来导出CPU的执行情况，以便帮助定位性能问题。</p>

<hr />

<p>首发于CSDN：<a href="http://geek.csdn.net/news/detail/50692">Android性能优化典范（四）</a></p>
]]></content>
  </entry>
  
</feed>
