<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2014-06-26T22:53:15+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[Kesen Hoo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Training - Volley(Lesson 4 - 实现自定义的请求)]]></title>
    <link href="http://hukai.me/blog/android-training-volley-custom-request/"/>
    <updated>2014-06-25T23:20:00+08:00</updated>
    <id>http://hukai.me/blog/android-training-volley-custom-request</id>
    <content type="html"><![CDATA[<p>这节课会介绍如何实现你自定义的请求类型，这些自定义的类型不属于Volley内置支持包里面。</p>

<h2>编写一个自定义的请求Write a Custom Request</h2>

<p>大多数的请求类型都已经包含在Volley的工具箱里面。如果你的请求返回数值是一个string，image或者JSON，那么你是不需要自己去实现请求类的。</p>

<p>对于那些你需要自定义的请求类型，下面是你需要做得步骤：</p>

<ul>
<li>继承<code>Request&lt;T&gt;</code>类，<code>&lt;T&gt;</code>表示了请求返回的数据类型。因此如果你需要解析的响应类型是一个String，可以通过继承<code>Request&lt;String&gt;</code>来创建你自定义的请求。请参考Volley工具类中的StringRequest与 ImageRequest来学习如何继承Request<T>。</li>
<li>实现抽象方法<code>parseNetworkResponse()</code>与<code>deliverResponse()</code>，下面会详细介绍。</li>
</ul>


<h3>parseNetworkResponse</h3>

<p>为了能够提交一种指定类型的数据(例如，string，image，JSON等)，需要对解析后的结果进行封装。下面会演示如何实现<code>parseNetworkResponse()</code>。</p>

<p>```java
@Override
protected Response<T> parseNetworkResponse(</p>

<pre><code>    NetworkResponse response) {
try {
    String json = new String(response.data,
    HttpHeaderParser.parseCharset(response.headers));
return Response.success(gson.fromJson(json, clazz),
HttpHeaderParser.parseCacheHeaders(response));
}
// handle errors
</code></pre>

<p>...
}
```</p>

<!-- More -->


<p>请注意：</p>

<ul>
<li><code>parseNetworkResponse()</code>的参数是类型是<code>NetworkResponse</code>，这种参数包含了的响应数据内容有一个byte[]，HTTP status code以及response headers.</li>
<li>你实现的方法必须返回一个Response<T>，它包含了你响应对象与缓存metadata或者是一个错误。</li>
</ul>


<p>如果你的协议没有标准的cache机制，你可以自己建立一个<code>Cache.Entry</code>, 但是大多数请求都可以用下面的方式来处理:</p>

<p>```java
return Response.success(myDecodedObject,</p>

<pre><code>    HttpHeaderParser.parseCacheHeaders(response));
</code></pre>

<p>```</p>

<p>Volley在工作线程中执行parseNetworkResponse()方法。这确保了耗时的解析操作，例如decode一张JPEG图片成bitmap，不会阻塞UI线程。</p>

<h3>deliverResponse</h3>

<p>Volley会把parseNetworkResponse()方法返回的数据带到主线程的回调中。如下所示：</p>

<p>```java
protected void deliverResponse(T response) {</p>

<pre><code>    listener.onResponse(response);
</code></pre>

<p>```</p>

<h3>Example: GsonRequest</h3>

<p><a href="http://code.google.com/p/google-gson/">Gson</a>是一个使用映射支持JSON与Java对象之间相互转换的库文件。你可以定义和JSON keys想对应名称的Java对象。把对象传递给传递Gson，然后Gson会帮你为对象填充字段值。 下面是一个完整的示例：演示了使用Gson解析Volley数据：</p>

<p>```java
public class GsonRequest<T> extends Request<T> {</p>

<pre><code>private final Gson gson = new Gson();
private final Class&lt;T&gt; clazz;
private final Map&lt;String, String&gt; headers;
private final Listener&lt;T&gt; listener;

/**
 * Make a GET request and return a parsed object from JSON.
 *
 * @param url URL of the request to make
 * @param clazz Relevant class object, for Gson's reflection
 * @param headers Map of request headers
 */
public GsonRequest(String url, Class&lt;T&gt; clazz, Map&lt;String, String&gt; headers,
        Listener&lt;T&gt; listener, ErrorListener errorListener) {
    super(Method.GET, url, errorListener);
    this.clazz = clazz;
    this.headers = headers;
    this.listener = listener;
}

@Override
public Map&lt;String, String&gt; getHeaders() throws AuthFailureError {
    return headers != null ? headers : super.getHeaders();
}

@Override
protected void deliverResponse(T response) {
    listener.onResponse(response);
}

@Override
protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) {
    try {
        String json = new String(
                response.data,
                HttpHeaderParser.parseCharset(response.headers));
        return Response.success(
                gson.fromJson(json, clazz),
                HttpHeaderParser.parseCacheHeaders(response));
    } catch (UnsupportedEncodingException e) {
        return Response.error(new ParseError(e));
    } catch (JsonSyntaxException e) {
        return Response.error(new ParseError(e));
    }
}
</code></pre>

<p>}
```</p>

<p>如果你愿意使用的话，Volley提供了现成的<code>JsonArrayRequest</code>与<code>JsonArrayObject</code>类。参考上一课:创建标准的请求</p>

<hr />

<p><strong>学习自<a href="http://developer.android.com/training/volley/request-custom.html">http://developer.android.com/training/volley/request-custom.html</a>,欢迎交流讨论</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training - Volley(Lesson 3 - 创建标准的请求)]]></title>
    <link href="http://hukai.me/blog/android-training-volley-standard-request/"/>
    <updated>2014-06-24T22:10:00+08:00</updated>
    <id>http://hukai.me/blog/android-training-volley-standard-request</id>
    <content type="html"><![CDATA[<p>这一课会介绍如何使用Volley支持的常用请求类型：</p>

<ul>
<li><code>StringRequest</code>。指定一个URL并在相应回调中接受一个原始的raw string数据。请参考前一课的示例。</li>
<li><code>ImageRequest</code>。指定一个URL并在相应回调中接受一个image。</li>
<li><code>JsonObjectRequest</code>与<code>JsonArrayRequest</code> (均为<code>JsonRequest</code>的子类)。指定一个URL并在相应回调中获取到一个JSON对象或者JSON数组。</li>
</ul>


<p>如果你需要的是上面演示的请求类型，那么你应该不需要自己实现一个自定义的请求。这节课会演示如何使用那些标准的请求类型。关于如何实现自定义的请求，请看下一课：<a href="request-costom.html">实现自定义的请求</a>。</p>

<h2>1)Request an Image</h2>

<p>Volley为请求图片提供了如下的类。这些类依次有着依赖关系，用来支持在不同的层级进行图片处理：</p>

<ul>
<li><p><code>ImageRequest</code> - 一个封装好的，用来处理URL请求图片并且返回一张decode好的bitmap的类。它同样提供了一些简便的接口方法，例如指定一个大小进行重新裁剪。它的主要好处是Volley回确保类似decode，resize等耗时的操作执行在工作线程中。</p></li>
<li><p><code>ImageLoader</code> - 一个用来处理加载与缓存从网络上获取到的图片的帮助类。ImageLoader是管理协调大量的ImageRequest的类。例如，在ListView中需要显示大量缩略图的时候。ImageLoader为通常的Volley cache提供了更加前瞻的内存缓存，这个缓存对于防止图片抖动非常有用。。这还使得能够在避免阻挡或者延迟主线程的前提下在缓存中能够被Hit到。ImageLoader还能够实现响应联合Coalescing，每一个响应回调里面都可以设置bitmap到view上面。联合Coalescing使得能够同时提交多个响应，这提升了性能。</p></li>
<li><p><code>NetworkImageView</code> - 在ImageLoader的基础上建立，替换ImageView进行使用。对于需要对ImageView设置网络图片的情况下使用很有效。NetworkImageView同样可以在view被detached的时候取消pending的请求。</p></li>
</ul>


<!-- More -->


<h3>1.1)Use ImageRequest</h3>

<p>下面是一个使用ImageRequest的示例。它会获取指定URL的image病显示到app上。里面演示的RequestQueue是通过上一课提到的单例类实现的。</p>

<p>```java
ImageView mImageView;
String url = "http://i.imgur.com/7spzG.png";
mImageView = (ImageView) findViewById(R.id.myImage);
...</p>

<p>// Retrieves an image specified by the URL, displays it in the UI.
ImageRequest request = new ImageRequest(url,</p>

<pre><code>new Response.Listener() {
    @Override
    public void onResponse(Bitmap bitmap) {
        mImageView.setImageBitmap(bitmap);
    }
}, 0, 0, null,
new Response.ErrorListener() {
    public void onErrorResponse(VolleyError error) {
        mImageView.setImageResource(R.drawable.image_load_error);
    }
});
</code></pre>

<p>// Access the RequestQueue through your singleton class.
MySingleton.getInstance(this).addToRequestQueue(request);
```</p>

<h3>1.2)Use ImageLoader and NetworkImageView</h3>

<p>你可以使用ImageLoader与NetworkImageView用来处理类似ListView等大量显示图片的情况。在你的layout XML文件中，你可以使用NetworkImageView来替代通常的ImageView， 例如:</p>

<p>```xml
&lt;com.android.volley.toolbox.NetworkImageView</p>

<pre><code>    android:id="@+id/networkImageView"
    android:layout_width="150dp"
    android:layout_height="170dp"
    android:layout_centerHorizontal="true" /&gt;
</code></pre>

<p>```</p>

<p>你可以使用ImageLoader来显示一张图片，例如：</p>

<p>```java
ImageLoader mImageLoader;
ImageView mImageView;
// The URL for the image that is being loaded.
private static final String IMAGE_URL =</p>

<pre><code>"http://developer.android.com/images/training/system-ui.png";
</code></pre>

<p>...
mImageView = (ImageView) findViewById(R.id.regularImageView);</p>

<p>// Get the ImageLoader through your singleton class.
mImageLoader = MySingleton.getInstance(this).getImageLoader();
mImageLoader.get(IMAGE_URL, ImageLoader.getImageListener(mImageView,</p>

<pre><code>     R.drawable.def_image, R.drawable.err_image));
</code></pre>

<p>```</p>

<p>然而，如果你要做得是为ImageView进行图片设置，你可以使用NetworkImageView来实现，例如：</p>

<p>```java
ImageLoader mImageLoader;
NetworkImageView mNetworkImageView;
private static final String IMAGE_URL =</p>

<pre><code>"http://developer.android.com/images/training/system-ui.png";
</code></pre>

<p>...</p>

<p>// Get the NetworkImageView that will display the image.
mNetworkImageView = (NetworkImageView) findViewById(R.id.networkImageView);</p>

<p>// Get the ImageLoader through your singleton class.
mImageLoader = MySingleton.getInstance(this).getImageLoader();</p>

<p>// Set the URL of the image that should be loaded into this view, and
// specify the ImageLoader that will be used to make the request.
mNetworkImageView.setImageUrl(IMAGE_URL, mImageLoader);
```</p>

<p>上面的代码是通过前一节课的单例模式来实现访问到RequestQueue与ImageLoader的。之所以这样做得原因是：对于ImageLoader(一个用来处理加载与缓存图片的帮助类)来说，单例模式可以避免旋转所带来的抖动。使用单例模式可以使得bitmap的缓存与activity的生命周期无关。如果你在activity中创建ImageLoader，这个ImageLoader有可能会在手机进行旋转的时候被重新创建。这可能会导致抖动。</p>

<h3>1.3)Example LRU cache</h3>

<p>Volley工具箱中提供了通过DiskBasedCache实现的一种标准缓存。这个类能够缓存文件到磁盘的制定目录。但是为了使用ImageLoader，你应该提供一个自定义的内存LRC缓存，这个缓存需要实现<code>ImageLoader.ImageCache</code>的接口。你可能想把你的缓存设置成一个单例。关于更多的有关内容，请参考<a href="request.html">建立请求队列Setting Up a RequestQueue</a>.</p>

<p>下面是一个内存LRU Cache的实例。它继承自LruCache并实现了ImageLoader.ImageCache的接口：</p>

<p>```java
import android.graphics.Bitmap;
import android.support.v4.util.LruCache;
import android.util.DisplayMetrics;
import com.android.volley.toolbox.ImageLoader.ImageCache;</p>

<p>public class LruBitmapCache extends LruCache&lt;String, Bitmap></p>

<pre><code>    implements ImageCache {

public LruBitmapCache(int maxSize) {
    super(maxSize);
}

public LruBitmapCache(Context ctx) {
    this(getCacheSize(ctx));
}

@Override
protected int sizeOf(String key, Bitmap value) {
    return value.getRowBytes() * value.getHeight();
}

@Override
public Bitmap getBitmap(String url) {
    return get(url);
}

@Override
public void putBitmap(String url, Bitmap bitmap) {
    put(url, bitmap);
}

// Returns a cache size equal to approximately three screens worth of images.
public static int getCacheSize(Context ctx) {
    final DisplayMetrics displayMetrics = ctx.getResources().
            getDisplayMetrics();
    final int screenWidth = displayMetrics.widthPixels;
    final int screenHeight = displayMetrics.heightPixels;
    // 4 bytes per pixel
    final int screenBytes = screenWidth * screenHeight * 4;

    return screenBytes * 3;
}
</code></pre>

<p>}
```</p>

<p>下面是如何初始化ImageLoader并使用cache的实例:</p>

<p><code>java
RequestQueue mRequestQueue; // assume this exists.
ImageLoader mImageLoader = new ImageLoader(mRequestQueue, new LruBitmapCache(LruBitmapCache.getCacheSize()));
</code></p>

<h2>2)Request JSON</h2>

<p>Volley提供了以下的类用来执行JSON请求：</p>

<ul>
<li><code>JsonArrayRequest</code> - 一个为了获取JSONArray返回数据的请求。</li>
<li><code>JsonObjectRequest</code> - 一个为了获取JSONObject返回数据的请求。允许把一个JSONObject作为请求参数。</li>
</ul>


<p>这两个类都是继承自JsonRequest的。你可以使用类似的方法来处理这两种类型的请求。如下演示了如果获取一个JSON feed并显示到UI上：</p>

<p>```java
TextView mTxtDisplay;
ImageView mImageView;
mTxtDisplay = (TextView) findViewById(R.id.txtDisplay);
String url = "http://my-json-feed";</p>

<p>JsonObjectRequest jsObjRequest = new JsonObjectRequest</p>

<pre><code>    (Request.Method.GET, url, null, new Response.Listener() {

@Override
public void onResponse(JSONObject response) {
    mTxtDisplay.setText("Response: " + response.toString());
}
</code></pre>

<p>}, new Response.ErrorListener() {</p>

<pre><code>@Override
public void onErrorResponse(VolleyError error) {
    // TODO Auto-generated method stub

}
</code></pre>

<p>});</p>

<p>// Access the RequestQueue through your singleton class.
MySingleton.getInstance(this).addToRequestQueue(jsObjRequest);
```</p>

<p>关于基于<a href="http://code.google.com/p/google-gson/">Gson</a>实现一个自定义的JSON请求对象，请参考下一节课：<a href="request-custom.html">实现一个自定义的请求Implementing a Custom Request</a>.</p>

<hr />

<p><strong>学习自<a href="http://developer.android.com/training/volley/request.html">http://developer.android.com/training/volley/request.html</a>,欢迎交流讨论</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training - Volley(Lesson 2 - 建立请求队列)]]></title>
    <link href="http://hukai.me/blog/android-training-volley-request-queue/"/>
    <updated>2014-06-24T21:03:00+08:00</updated>
    <id>http://hukai.me/blog/android-training-volley-request-queue</id>
    <content type="html"><![CDATA[<p>前一节课演示了如何使用<code>Volley.newRequestQueue</code>这一简便的方法来建立一个<code>RequestQueue</code>，这是利用了Volley默认的优势。这节课会介绍如何显式的建立一个RequestQueue，以便满足你自定义的需求。</p>

<p>这节课同样会介绍一种推荐的实现方式：创建一个单例的RequestQueue，这使得RequestQueue能够持续保持在你的app的生命周期中。</p>

<h2>Set Up a Network and Cache</h2>

<p>一个RequestQueue需要两部分来支持它的工作：一部分是网络操作用来执行请求的数据传输，另外一个是用来处理缓存操作的Cache。在Volley的工具箱中包含了标准的实现方式：<code>DiskBasedCache</code>提供了每个文件与对应响应数据一一映射的缓存实现。 <code>BasicNetwork</code>提供了一个网络传输的实现，连接方式可以是<a href="http://developer.android.com/reference/android/net/http/AndroidHttpClient.html">AndroidHttpClient</a> 或者是 <a href="http://developer.android.com/reference/java/net/HttpURLConnection.html">HttpURLConnection</a>.</p>

<p><code>BasicNetwork</code>是Volley默认的网络操作实现方式。一个BasicNetwork必须使用HTTP Client进行初始化。这个Client通常是AndroidHttpClient 或者 HttpURLConnection:</p>

<!-- More -->


<ul>
<li>对于app target API level低于API 9(Gingerbread)的使用AndroidHttpClient。在Gingerbread之前，HttpURLConnection是不可靠的。对于这个的细节，请参考<a href="http://android-developers.blogspot.com/2011/09/androids-http-clients.html">Android's HTTP Clients</a>。</li>
<li>对于API Level 9以及以上的，会使用HttpURLConnection。</li>
</ul>


<p>为了创建一个能够执行在所有Android版本上的应用，你可以通过检查系统版本选择合适的HTTP Client。例如：</p>

<p>```java
HttpStack stack;
...
// If the device is running a version >= Gingerbread...
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {</p>

<pre><code>// ...use HttpURLConnection for stack.
</code></pre>

<p>} else {</p>

<pre><code>// ...use AndroidHttpClient for stack.
</code></pre>

<p>}
Network network = new BasicNetwork(stack);
```</p>

<p>下面的代码片段会掩饰如何一步步建立一个RequestQueue:</p>

<p>```java
RequestQueue mRequestQueue;</p>

<p>// Instantiate the cache
Cache cache = new DiskBasedCache(getCacheDir(), 1024 * 1024); // 1MB cap</p>

<p>// Set up the network to use HttpURLConnection as the HTTP client.
Network network = new BasicNetwork(new HurlStack());</p>

<p>// Instantiate the RequestQueue with the cache and network.
mRequestQueue = new RequestQueue(cache, network);</p>

<p>// Start the queue
mRequestQueue.start();</p>

<p>String url ="http://www.myurl.com";</p>

<p>// Formulate the request and handle the response.
StringRequest stringRequest = new StringRequest(Request.Method.GET, url,</p>

<pre><code>    new Response.Listener&lt;String&gt;() {
@Override
public void onResponse(String response) {
    // Do something with the response
}
</code></pre>

<p>},</p>

<pre><code>new Response.ErrorListener() {
    @Override
    public void onErrorResponse(VolleyError error) {
        // Handle error
}
</code></pre>

<p>});</p>

<p>// Add the request to the RequestQueue.
mRequestQueue.add(stringRequest);
...
```</p>

<p>如果你仅仅是想做一个单次的请求并且不想要线程池一直保留，你可以通过使用在前面一课：<a href="simple.html">发送一个简单的请求(Sending a Simple Request)</a>文章中提到<code>Volley.newRequestQueue()</code>方法在任何需要的时刻创建RequestQueue，然后在你的响应回调里面执行<code>stop()</code>方法来停止操作。但是更通常的做法是创建一个RequestQueue并设置为一个单例。下面将演示这种做法。</p>

<h2>Use a Singleton Pattern</h2>

<p>如果你的程序需要持续的使用网络，更加高效的方式应该是建立一个RequestQueue的单例，这样它能够持续保持在整个app的生命周期中。你可以通过多种方式来实现这个单例。推荐的方式是实现一个单例类，里面封装了RequestQueue对象与其他Volley的方法。另外一个方法是继承Application类，并在<code>Application.OnCreate()</code>方法里面建立RequestQueue。但是这个方法是不推荐的。因为一个static的单例能够以一种更加模块化的方式提供同样的功能。</p>

<p>一个关键的概念是RequestQueue必须和Application context所关联的。而不是Activity的context。这可以确保RequestQueue可以在你的app生命周期中一直存活，而不会因为activity的重新创建而重新创建RequestQueue。(例如，当用户旋转设备时)。</p>

<p>下面是一个单例类，提供了RequestQueue与ImageLoader的功能：</p>

<p>```java
private static MySingleton mInstance;</p>

<pre><code>private RequestQueue mRequestQueue;
private ImageLoader mImageLoader;
private static Context mCtx;

private MySingleton(Context context) {
    mCtx = context;
    mRequestQueue = getRequestQueue();

    mImageLoader = new ImageLoader(mRequestQueue,
            new ImageLoader.ImageCache() {
        private final LruCache&lt;String, Bitmap&gt;
                cache = new LruCache&lt;String, Bitmap&gt;(20);

        @Override
        public Bitmap getBitmap(String url) {
            return cache.get(url);
        }

        @Override
        public void putBitmap(String url, Bitmap bitmap) {
            cache.put(url, bitmap);
        }
    });
}

public static synchronized MySingleton getInstance(Context context) {
    if (mInstance == null) {
        mInstance = new MySingleton(context);
    }
    return mInstance;
}

public RequestQueue getRequestQueue() {
    if (mRequestQueue == null) {
        // getApplicationContext() is key, it keeps you from leaking the
        // Activity or BroadcastReceiver if someone passes one in.
        mRequestQueue = Volley.newRequestQueue(mCtx.getApplicationContext());
    }
    return mRequestQueue;
}

public &lt;T&gt; void addToRequestQueue(Request&lt;T&gt; req) {
    getRequestQueue().add(req);
}

public ImageLoader getImageLoader() {
    return mImageLoader;
}
</code></pre>

<p>}
```</p>

<p>下面演示了利用单例类来执行RequestQueue的操作：</p>

<p>```java
// Get a RequestQueue
RequestQueue queue = MySingleton.getInstance(this.getApplicationContext()).</p>

<pre><code>getRequestQueue();
</code></pre>

<p>...</p>

<p>// Add a request (in this example, called stringRequest) to your RequestQueue.
MySingleton.getInstance(this).addToRequestQueue(stringRequest);
```</p>

<hr />

<p><strong>学习自<a href="http://developer.android.com/training/volley/request-queue.html">http://developer.android.com/training/volley/request-queue.html</a>,欢迎交流讨论</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training - Volley(Lesson 1 - 发送简单的请求)]]></title>
    <link href="http://hukai.me/blog/android-training-volley-simple-request/"/>
    <updated>2014-06-24T09:00:00+08:00</updated>
    <id>http://hukai.me/blog/android-training-volley-simple-request</id>
    <content type="html"><![CDATA[<p>使用Volley的方式是，你通过创建一个<code>RequestQueue</code>并传递<code>Request</code>对象给它。RequestQueue管理工作线程用来执行网络操作，从Cache中读取与写入数据，以及解析Http的响应内容。<code>Requests</code>执行raw responses的解析，Volley会把响应的数据分发给主线程。</p>

<p>这节课会介绍如何使用<code>Volley.newRequestQueue</code>这个建立请求队列的方法来发送一个请求，在下一节课<a href="request-queue.html">建立一个请求队列Setting Up a RequestQueue</a>中会介绍你自己如何建立一个请求队列。</p>

<p>这节课也会介绍如何添加一个请求到RequesutQueue以及如何取消一个请求。</p>

<h2>Add the INTERNET Permission</h2>

<p>为了使用Volley，你必须添加<code>android.permission.INTERNET</code>权限到你的manifest文件中。没有这个权限，你的app将无法访问网络。</p>

<h2>Use newRequestQueue</h2>

<p>Volley提供了一个简便的方法：<code>Volley.newRequestQueue</code>用来为你建立一个<code>RequestQueue</code>，使用默认值，并启动这个队列。例如：</p>

<!-- More -->


<p>```java
final TextView mTextView = (TextView) findViewById(R.id.text);
...</p>

<p>// Instantiate the RequestQueue.
RequestQueue queue = Volley.newRequestQueue(this);
String url ="http://www.google.com";</p>

<p>// Request a string response from the provided URL.
StringRequest stringRequest = new StringRequest(Request.Method.GET, url,</p>

<pre><code>        new Response.Listener() {
@Override
public void onResponse(String response) {
    // Display the first 500 characters of the response string.
    mTextView.setText("Response is: "+ response.substring(0,500));
}
</code></pre>

<p>}, new Response.ErrorListener() {</p>

<pre><code>@Override
public void onErrorResponse(VolleyError error) {
    mTextView.setText("That didn't work!");
}
</code></pre>

<p>});
// Add the request to the RequestQueue.
queue.add(stringRequest);
```</p>

<p>Volley总是把解析过后的数据返回到主线程中。在主线程中更加合适使用接收到到的数据用来操作UI控件，这样你可以在响应的handler中轻松的修改UI，但是对于库提供的一些其他方法是有些特殊的，例如与取消有关的。</p>

<p>关于如何创建你自己的请求队列，不要使用Volley.newRequestQueue方法，请查看<a href="request-queue.html">建立一个请求队列Setting Up a RequestQueue</a>。</p>

<h2>Send a Request</h2>

<p>为了发送一个请求，你只需要构造一个请求并通过<code>add()</code>方法添加到<code>RequestQueue</code>中。一旦你添加了这个请求，它会通过队列，得到处理，然后得到原始的响应数据并返回。</p>

<p>当你执行<code>add()</code>方法时，Volley触发执行一个缓存处理线程以及网络一系列的网络处理线程。当你添加一个请求到队列中，它将被缓存线程所捕获并触发：如果这个请求可以被缓存处理，那么会在缓存线程中执行响应数据的解析并返回到主线程。如果请求不能被缓存所处理，它会被放到网络队列中。网络线程池中的第一个可用的网络线程会从队列中获取到这个请求并执行HTTP操作，解析响应数据，把数据写到缓存中之后再把解析之后的数据返回到主线程。</p>

<p>请注意那些比较耗时的操作，例如I/O与解析parsing/decoding都是执行在工作线程。<strong>你可以在任何线程中添加一个请求，但是响应结果都是返回到主线程的。</strong></p>

<p>下图1，演示了一个请求的生命周期：</p>

<p><img src="/images/articles/volley-request.png" alt="volley-request" /></p>

<h2>Cancel a Request</h2>

<p>为了取消一个请求，对你的请求对象执行<code>cancel()</code>方法。一旦取消，Volley会确保你的响应Handler不会被执行。这意味着在实际操作中你可以在activity的<code>onStop()</code>方法中取消所有pending在队列中的请求。你不需要通过检测<code>getActivity() == null</code>来丢弃你的响应handler，其他类似<code>onSaveInstanceState()</code>等保护性的方法里面也都不需要检测。</p>

<p>为了利用这种优势，你应该跟踪所有已经发送的请求，以便在需要的时候，可以取消他们。<strong>有一个简便的方法</strong>：你可以为每一个请求对象都绑定一个tag对象。你可以使用这个tag来提供取消的范围。例如，你可以为你的所有请求都绑定到执行的Activity上，然后你可以在<code>onStop()</code>方法执行<code>requestQueue.cancelAll(this)</code> 。同样的，你可以为ViewPager中的所有请求缩略图Request对象分别打上对应Tab的tag。并在滑动时取消这些请求，用来确保新生成的tab不会被前面tab的请求任务所卡到。</p>

<p>下面一个使用String来打Tag的例子：</p>

<ul>
<li>定义你的tag并添加到你的请求任务中。</li>
</ul>


<p>```java
public static final String TAG = "MyTag";
StringRequest stringRequest; // Assume this exists.
RequestQueue mRequestQueue;  // Assume this exists.</p>

<p>// Set the tag on the request.
stringRequest.setTag(TAG);</p>

<p>// Add the request to the RequestQueue.
mRequestQueue.add(stringRequest);
```</p>

<ul>
<li>在activity的onStop()方法里面，取消所有的包含这个tag的请求任务。</li>
</ul>


<p>```java
@Override
protected void onStop () {</p>

<pre><code>super.onStop();
if (mRequestQueue != null) {
    mRequestQueue.cancelAll(TAG);
}
</code></pre>

<p>}
```</p>

<p>当取消请求时请注意：如果你依赖你的响应handler来标记状态或者触发另外一个进程，你需要为此给出有力的解释。再说一次，response handler是不会被执行的。</p>

<hr />

<p><strong>学习自<a href="http://developer.android.com/training/volley/simple.html">http://developer.android.com/training/volley/simple.html</a>,欢迎交流讨论</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training - Volley(Lesson 0 - 序言)]]></title>
    <link href="http://hukai.me/blog/android-training-volley-index/"/>
    <updated>2014-06-24T08:30:00+08:00</updated>
    <id>http://hukai.me/blog/android-training-volley-index</id>
    <content type="html"><![CDATA[<p><code>Volley</code> 是一个HTTP库，它能够帮助Android apps更方便的执行网络操作，最重要的是，它更快速高效。可以通过开源的 <a href="https://android.googlesource.com/platform/frameworks/volley">AOSP</a> 仓库获取到Volley 。</p>

<hr />

<p><strong>DEPENDENCIES AND PREREQUISITES</strong></p>

<p>Android 1.6 (API Level 4) or higher</p>

<p><strong>YOU SHOULD ALSO SEE</strong></p>

<p>使用Volley来编写一个app，请参考<a href="https://github.com/google/iosched">2013 Google I/O schedule app</a>. 另外需要特别关注下面2个部分：
* <a href="https://github.com/google/iosched/blob/master/android/src/main/java/com/google/android/apps/iosched/util/ImageLoader.java">ImageLoader</a>
* <a href="https://github.com/google/iosched/blob/master/android/src/main/java/com/google/android/apps/iosched/util/BitmapCache.java">BitmapCache</a></p>

<p><strong> <a href="https://developers.google.com/events/io/sessions/325304728">VIDEO - Volley:Easy,Fast Networking for Android</a> </strong></p>

<hr />

<p>Volley 有如下的优点：</p>

<!-- More -->


<ul>
<li>自动执行网络请求。</li>
<li>高并发网络连接。</li>
<li>通过标准的HTTP的<a href="http://en.wikipedia.org/wiki/Cache_coherence%22">cache coherence</a>(高速缓存一致性)使得磁盘与内存缓存不可见(Transparent)。</li>
<li>支持指定请求的优先级。</li>
<li>支持取消已经发出的请求。你可以取消单个请求，或者指定取消请求队列中的一个区域。</li>
<li>框架容易被定制，例如，定制重试或者回退功能。</li>
<li>强大的指令(Strong ordering)可以使得异步加载网络数据并显示到UI的操作更加简单。</li>
<li>包含了Debugging与tracing工具。</li>
</ul>


<p>Volley擅长执行用来显示UI的RPC操作， 例如获取搜索结果的数据。它轻松的整合了任何协议，并输出操作结果的数据，可以是raw strings，也可以是images，或者是JSON。通过提供内置你可能使用到得功能，Volley可以使得你免去重复编写样板代码，使你可以把关注点放在你的app的功能逻辑上。</p>

<p>Volley不适合用来下载大的数据文件。因为Volley会在解析的过程中保留持有所有的响应数据在内存中。对于下载大量的数据操作，请考虑使用<a href="http://developer.android.com/reference/android/app/DownloadManager.html">DownloadManager</a>。</p>

<p>Volley框架的核心代码是托管在AOSP仓库的<code>frameworks/volley</code>中，相关的工具放在<code>toolbox</code>下。把Volley添加到你的项目中的最简便的方法是Clone仓库然后把它设置为一个library project：</p>

<ul>
<li>通过下面的命令来Clone仓库：</li>
</ul>


<p><code>git clone https://android.googlesource.com/platform/frameworks/volley</code></p>

<ul>
<li>以一个Android library project的方式导入下载的源代码到你的项目中。(如果你是使用Eclipse，请参考<a href="http://developer.android.com/tools/projects/projects-eclipse.html">Managing Projects from Eclipse with ADT</a>)，或者编译成一个<code>.jar</code>文件。</li>
</ul>


<h2>Lessons</h2>

<ul>
<li><a href="simple.html">发送一个简单的网络请求(Sending a Simple Request)</a></li>
</ul>


<p>学习如何通过Volley默认的行为发送一个简单的请求，以及如何取消一个请求。</p>

<ul>
<li><a href="request-queue.html">建立一个请求队列(Setting Up a RequestQueue)</a></li>
</ul>


<p>学习如何建立一个请求队列，以及如何实现一个单例模式来创建一个请求队列。</p>

<ul>
<li><a href="request.html">生成一个标准的请求(Making a Standard Request)</a></li>
</ul>


<p>学习如何使用Volley的out-of-the-box的请求类型(raw strings, images, and JSON)来发送一个请求。</p>

<ul>
<li><a href="request-custom.html">实现自定义的请求(Implementing a Custom Request)</a></li>
</ul>


<p>学习如何实现一个自定义的请求</p>

<hr />

<p><strong>学习自<a href="http://developer.android.com/training/volley/index.html">http://developer.android.com/training/volley/index.html</a>,欢迎交流讨论</strong></p>
]]></content>
  </entry>
  
</feed>
