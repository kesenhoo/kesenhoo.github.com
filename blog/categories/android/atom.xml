<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2018-07-19T00:28:08+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[HuKai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Jetpack - 使用WorkManager处理简单的后台任务]]></title>
    <link href="http://hukai.me/google-io-2018-android-jetpack-workmanager/"/>
    <updated>2018-05-28T23:24:00+08:00</updated>
    <id>http://hukai.me/google-io-2018-android-jetpack-workmanager</id>
    <content type="html"><![CDATA[<p>时间来到2018年的当下，当我们讨论后台处理任务的时候，一般可能涉及的行为类型有下面一些类型，例如：</p>

<ul>
<li>发送程序运行日志</li>
<li>上传图片和视频</li>
<li>同步数据</li>
<li>处理数据</li>
</ul>


<p>这些行为都需要在后台进行操作，在Android平台上，我们可以利用如下的这些可选方式来实现后台任务：</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_01.png" alt="google_io_2018_android_jetpack_workmanager_01" /></p>

<p>那么到底我们如何做出合理的选择呢？过去的几年，Android系统随着版本的更新针对电量优化这一块做出了不同程度的限制优化，例如在Android M上的<code>Doze Mode</code>，Android N上的<code>Limit Implicit  Broadcast</code>，Android O上的<code>Background Service Limitations</code>以及最新的Android P上面的<code>App Standby Buckets</code>。为了确保后台任务对电量的消耗影响足够小，对待后台任务的处理要更加的慎重小心。</p>

<h2>0）Types of Background Work</h2>

<p>通常来说，我们可以把所有的后台任务按照任务紧迫性(是马上需要执行的任务/还是可以缓期执行的任务)和任务重要性(是确保一定要被执行的任务/还是最好能够执行的任务)进行四象限的划分。通常来说对于非确保一定要执行的任务，无论时间是否紧迫，我们都可以使用ThreadPool来完成这个任务。对于那些比较重要的又时间紧迫的任务，我们一般会使用Foreground Service来完成这个操作。比较有有意思的是最后一个象限：那些希望确保可以被执行但是又可以接受延期执行的任务。这些任务可以使用JobScheduler/JobDispatcher/AlarmManager/BroadcastReceivers来完成。WorkManager也刚好是用来解决这一类的问题的。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_02.png" alt="google_io_2018_android_jetpack_workmanager_02" /></p>

<!-- More -->


<h2>1）WorkManager Features</h2>

<p>下面是WorkManager的一些突出特点：</p>

<ul>
<li>确保可以被执行，并且可以设置执行的限定条件(例如仅仅在有网络连接的时候才进行图片的上传)</li>
<li>同样受到系统后台任务的限制管理(如APP进入Doze Mode的时候，任务不会被执行)</li>
<li>向后兼容；无论是否集成了Google Play Service服务，都是向后兼容的</li>
<li>任务可查询；如论当下在执行什么任务，都是可以直接查询获取到任务状态信息的(例如正在运行的状态是什么，结果是成功还是失败了)</li>
<li>任务可串联；例如执行任务A之前需要任务B或者C先进行完成</li>
<li>任务伺机执行：在条件满足的时候会尽快尝试触发任务的执行，不需要等待JobScheduler的唤醒，也不会需要等待JobScheduler进行批量任务处理的才被执行</li>
</ul>


<p>WorkManager中的核心类有：</p>

<ul>
<li>Worker：这个类是真正干活的，工作逻辑都在这里面</li>
<li>WorkRequest：

<ul>
<li>OneTimeWorkRequest：只执行一次的任务请求</li>
<li>PeriodicWorkRequest：重复执行的任务请求</li>
</ul>
</li>
</ul>


<p>举个例子：图片上传的后台任务是如何执行的。下面是上传图片的Worker示例：</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_03.png" alt="google_io_2018_android_jetpack_workmanager_03" /></p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_04.png" alt="google_io_2018_android_jetpack_workmanager_04" /></p>

<p>其中uploadPhoto是执行在后台线程的，返回值可以是成功或者失败，还可以是重试，这意味着告诉系统这个任务需要后面找机会重新执行。有了上面那些基础，接下去就只需要利用Worker创建对应的WorkRequest，并并添加到WorkManager的执行队列中就好了。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_05.png" alt="google_io_2018_android_jetpack_workmanager_05" /></p>

<p>正常情况下，放到任务队列中的任务会被立马执行，可是如果遇到网络连接失败的情况，这样就会执行失败。此时我们就可以通过添加限定执行条件来达到优化的目的，例如设置限定只在网络连接成功的时候才进行任务的执行。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_06.png" alt="google_io_2018_android_jetpack_workmanager_06" /></p>

<h2>2）Observing Work</h2>

<p>有了上面的任务触发逻辑之后，那么如何做任务的监听呢？例如正在处理过程中显示一个进度圈，处理成功的时候消失进度等等。我们可以使用如下演示的范例来监听任务的执行状态。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_07.png" alt="google_io_2018_android_jetpack_workmanager_07" /></p>

<p><code>LiveData</code>是Google开发的一个感知生命周期的架构组件。使用这个组件来hook监听request任务的<code>WorkStatus</code>。在WorkStatus里面有任务的id和status，其中status有6种状态，分别是<code>ENQUEUED</code>,<code>RUNNING</code>,<code>SUCCEEDED</code>,<code>FAILED</code>,<code>BLOCKED</code>,<code>CANCELLED</code>。</p>

<h2>3）Chaining Work</h2>

<p>通常来说，上传任务真正被执行之前，我们会对数据做一次压缩，因为每一个任务都需要在后台进行，并且需要保证执行顺序。我们可以使用下面的示例方式，先进行压缩，成功之后，再进行上传。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_08.png" alt="google_io_2018_android_jetpack_workmanager_08" /></p>

<p>只所以可以类似上面那样写，是因为每一步任务返回的都是<code>WorkContinuation</code>，使用它可以对不同的任务进行串联。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_09.png" alt="google_io_2018_android_jetpack_workmanager_09" /></p>

<p>如果想要多项任务并发执行，可以同时建立多个WorkRequest，一起交给WorkManager进行执行(根据CPU核心数和架构的不同，并发数量有所差异)。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_10.png" alt="google_io_2018_android_jetpack_workmanager_10" /></p>

<p>我们再把任务链设置的更加复杂一点，例如图片要先分别经过不同的滤镜处理，之后再进行压缩，最后才可以上传，那么使用WorkManager该如何实行呢？</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_11.png" alt="google_io_2018_android_jetpack_workmanager_11" /></p>

<h2>4）Inputs and Outputs</h2>

<p>任务之间如何进行数据的传递呢？在介绍这个之前，我们需要了解下什么叫做MapReduce。例如，我们想要从三本书里面找出使用最多的词语，先把所有词语都进行计算一遍，然后对词语的使用次数进行排序，最后才可以找出使用最多的词语，我们把这个行为叫做MapReduce。</p>

<p>使用WorkManager的输入和输出数据具备如下的特点：</p>

<ul>
<li>简单的KEY-VALUE

<ul>
<li>KEY都是String类型的</li>
<li>VALUE可以是基础数据类型和String</li>
</ul>
</li>
<li>数据本身已经做了序列化处理</li>
<li>限定10KB大小以内</li>
</ul>


<p>我们使用如下的方式进行输入的数据传递，构造一个map类型的Data，通过WorkManager的<code>setInputData()</code>给Worker进行传输数据。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_12.png" alt="google_io_2018_android_jetpack_workmanager_12" /></p>

<p>接下去Worker可以通过<code>getInputData()</code>来获取到输入的数据。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_13.png" alt="google_io_2018_android_jetpack_workmanager_13" /></p>

<p>一般来说，我们会需要把处理的结果进行返回，那么使用<code>setOutputData()</code>来完成这个操作就可以了</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_14.png" alt="google_io_2018_android_jetpack_workmanager_14" /></p>

<p>有意思的事情是，在任务链中，输出的数据一般就是下一个任务的输入。那么当某个环节的一个任务是由多个任务的输出构成的时候，改如何处理呢？</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_15.png" alt="google_io_2018_android_jetpack_workmanager_15" /></p>

<p>为了解决这个问题，我们需要了解<code>InputMergers</code>，顾名思义，它是用来合并多个输入数据变成一个的。一般来说有两种合并实现的方式(也可以自己自定义)</p>

<ul>
<li><code>OverwritingInputMerger</code>(系统默认)：按照输入数据的先后顺序，相同KEY会被覆盖，不同的KEY内容会被保留</li>
</ul>


<p><img src="/images/google_io_2018_android_jetpack_workmanager_16.png" alt="google_io_2018_android_jetpack_workmanager_16" /></p>

<ul>
<li><code>ArrayCreatingInputMerger</code>：相同KEY的VALUE值进行合并，需要确保VALUE是相同数据类型的，否者会出现异常</li>
</ul>


<p><img src="/images/google_io_2018_android_jetpack_workmanager_17.png" alt="google_io_2018_android_jetpack_workmanager_17" /></p>

<h2>5）Cancelling Work</h2>

<p>想要取消一个任务，只需要调用<code>cancelWorkById()</code>就好了，但是需要注意的是，这个方法只是<strong>尽力而为</strong>，因为相关想要取消的任务有可能已经在运行，也有可能已经执行结束了。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_18.png" alt="google_io_2018_android_jetpack_workmanager_18" /></p>

<h2>6）Tags</h2>

<p>前面我们有提到过好几次任务id，这个id是系统自动生成的，类似UUID这样的数值。我们无法通过这个id来判断这是一个什么样的任务，tags就是为了解决这个任务可读性的问题的。我们可以给任务打上一个或者多个tag来标记这是一个什么样的任务，然后可以通过这个tag来查询，取消任务等等。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_19.png" alt="google_io_2018_android_jetpack_workmanager_19" /></p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_20.png" alt="google_io_2018_android_jetpack_workmanager_20" /></p>

<p>使用Tag可以给我们提供很大的帮助，我们可以根据不同的模块和依赖给任务设置不同的tag，也可以根据任务的类型进行设置tag，这样就可以方便的进行批量任务操作了。</p>

<h2>7）Unique Work</h2>

<p>为了解决多个任务的同步问题，引入了Unique Work的机制。它有三种类型，分别为</p>

<ul>
<li><code>KEEP</code>：新启动的Unique任务，如果之前已经存在，就继续保留旧的任务，如果不存在，则触发这次新的任务</li>
</ul>


<p><img src="/images/google_io_2018_android_jetpack_workmanager_21.png" alt="google_io_2018_android_jetpack_workmanager_21" /></p>

<ul>
<li><code>REPLACE</code>：取消或者删除之前的所有此类Unique任务，使用这次的任务作为最新任务，重复调用多次的时候，会以最后一次为准</li>
</ul>


<p><img src="/images/google_io_2018_android_jetpack_workmanager_22.png" alt="google_io_2018_android_jetpack_workmanager_22" /></p>

<ul>
<li><code>APPEND</code>：按照添加顺序，逐个执行任务</li>
</ul>


<p><img src="/images/google_io_2018_android_jetpack_workmanager_23.png" alt="google_io_2018_android_jetpack_workmanager_23" /></p>

<h2>8）Periodic Work</h2>

<p>重复任务和我们之前认知的其他重复任务一样，具备一些如下的特点：</p>

<ul>
<li>最短间隔时间15分钟(和JobScheduler一样)</li>
<li>同样受系统doze mode和其他的后台任务限制</li>
<li>不可以有任务链</li>
<li>不可以有触发延迟</li>
</ul>


<h2>9）Under The Hood</h2>

<p>当系统接受到一个Work任务的时候，会先记录到自己的任务数据库中，接下去系统是如何判断执行的呢？如果任务符合当下执行的条件，那么会由Executor(可自定义，系统默认有实现)立即执行；如果我们的进程已经被杀死，那么任务什么时候可以被执行呢？如果设备运行在>=API 23，会交给JobScheduler触发IPC请求，唤醒我们的进程进行任务的执行；如果设备运行在&lt; API 23的情况下，系统会判断设备是否有Firebase JobDispatcher，如果有会交给它进行处理；如果那些Google Play Service服务都没有，系统会使用AlarmManager和BroadcastReceivers的方式在合适的时候唤醒应用进行处理。</p>

<p><img src="/images/google_io_2018_android_jetpack_workmanager_24.png" alt="google_io_2018_android_jetpack_workmanager_24" /></p>

<h2>10）Best Practice</h2>

<ul>
<li>何时使用WorkManager呢？下面给一些最佳实践的例子：

<ul>
<li>OK：上传图片和视频</li>
<li>OK：解析数据并存储到数据库中</li>
<li>NO：从调色板中获取颜色并设置到图片上</li>
<li>NO：解析数据并呈现到视图上进行显示</li>
<li>NO：处理交易的请求</li>
</ul>
</li>
<li>不要使用WorkManager来存储数据，记得只有10kb的限制</li>
<li>记得给不同的任务设置各自的执行限定条件，避免无谓的资源浪费</li>
</ul>


<p><img src="/images/google_io_2018_android_jetpack_workmanager_25.png" alt="google_io_2018_android_jetpack_workmanager_25" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android相机开发 - 1)基础概览篇]]></title>
    <link href="http://hukai.me/android-dev-camera-basics/"/>
    <updated>2017-01-30T21:24:00+08:00</updated>
    <id>http://hukai.me/android-dev-camera-basics</id>
    <content type="html"><![CDATA[<p>在Android平台上面实现自定义相机，根据业务的复杂度，涉及到的知识范畴大致如下，开篇优先描述下基础概览的部分:</p>

<p><img src="/images/android_dev_custom_camera_basic.jpeg" alt="android_dev_custom_camera_basic.jpeg" /></p>

<h2>0)开始之前</h2>

<p>在应用中开启Android设备的相机功能之前，应该考虑如下几个问题：</p>

<ul>
<li><strong>必须的相机硬件</strong> - 当然不能把一个包含相机功能的应用安装到一个连相机硬件都没有的设备上。因此，应该在mainfest文件中声明需要使用到相机。</li>
<li><strong>快速获取图片还是自定义相机</strong> - 应用将如何使用相机？是想实现一个快速的抓拍功能还是录制一小段视频剪辑？还是说想提供一种全新的相机使用方式？如果是快速的获取一张抓拍图片或者是一小段视频剪辑，建议查看下面的<strong>3)使用已经存在的相机应用。</strong>如果是为了开发一个自定义的相机功能的应用，查看下面的<strong>4)创建自定义相机应用</strong>。</li>
<li><strong>存储位置</strong> - 生成的图片与视频是只对自己的应用可见还是其它相册Gallery类的应用也可以访问？即使自己的应用被卸载后也不能被其他应用访问吗？建议查看<strong>5)保存媒体文件</strong></li>
</ul>


<h2>1)简要概述</h2>

<p>Android framework通过提供Camera API来支持拍照与录制视频的功能。下面是相关的类：</p>

<ul>
<li><a href="https://developer.android.com/reference/android/hardware/camera2/package-summary.html"><strong>android.hardware.camera2</strong></a><br/>
这里列举了控制相机的核心API，使用它可以实现拍照和录制视频的功能。</li>
<li><a href="https://developer.android.com/reference/android/hardware/Camera.html"><strong>Camera</strong></a><br/>
该类是已经被废弃的控制相机的基础的API。</li>
<li><a href="http://developer.android.com/reference/android/view/SurfaceView.html"><strong>SurfaceView</strong></a><br/>
该类用来呈现一个动态的相机预览界面。</li>
<li><a href="http://developer.android.com/reference/android/media/MediaRecorder.html"><strong>MediaRecorder</strong></a><br/>
该类用来使用相机录制视频(后续的文章中都不会对视频录制的部分进行过多描述，不属于该系列文章的主要讨论范畴)</li>
<li><a href="http://developer.android.com/reference/android/content/Intent.html"><strong>Intent</strong></a><br/>
使用<a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> 或者 <a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a>作为Intent的action可以用来拍照与录制视频。</li>
</ul>


<!-- More -->


<h2>2)AndroidManifest.xml声明</h2>

<p>在使用Camera API开发应用之前，应该确保应用的mainfest中有做恰当的权限声明，表明此应用需要使用相机或者是相机的相关功能。</p>

<ul>
<li><p><strong>Camera Permission</strong> - 为了使用相机硬件，你的应用必须请求使用Camera的权限。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</code><br/>
<strong>Note:</strong>如果你是通过Intent来调用其他已经存在的Camera应用，自己的应用程序是不需要声明这个权限的。</p></li>
<li><p><strong>Camera Features</strong> - 你的应用还必须声明使用相机功能，例如：<br/>
<code>xml
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</code><br/>
关于相机功能列表，请参考<a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">功能引用</a>。增加相机功能到你的mainfest文件，这样Google Play可以阻止那些没有相机硬件或者没有相机特定功能的设备安装你的应用。关于Google Play如何做过滤的信息，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#market-feature-filtering">Google Play and Feature-Based Filtering</a>(关于这一点，国内的分发市场暂时都没有做一条的过滤)。你还可以为每个相机特性设置<code>android:required</code>的属性，表示这个功能是否为必须的。</p></li>
<li><p><strong>Storage Permission</strong> - 如果你的应用需要保存图片或者视频到设备的外置存储空间(SDCard)上，你也需要在manifest中指定存储的读写权限。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
</code></p></li>
<li><p><strong>Location Permission</strong> - 如果你的应用需要为图片添加位置信息，你还需要请求location permission，如果应用需要执行在Android 5.0及更高的的版本上，还需要声明GPS权限。
```xml
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
...</p></li>
</ul>


<!-- Needed only if your app targets Android 5.0 (API level 21) or higher. -->


<p><uses-feature android:name="android.hardware.location.gps" />
```</p>

<p>关于获取用户位置信息的更多细节信息，请参考<a href="https://developer.android.com/guide/topics/location/strategies.html">Location Strategies</a>。</p>

<h2>3)使用已经存在的相机应用</h2>

<p>在你的应用中快速的实现拍照与录制视频的方法是使用一个Intent来调用已经存在系统中的相机程序。通过已经存在的相机程序拍照或者录制视频，然后返回数据给请求方。这一部分会演示如何使用这种技术。</p>

<p>触发Camera Intent需要遵守如下几个步骤：</p>

<ul>
<li><p><strong>Compose a Camera Intent</strong> - 创建一个请求拍照或者录像的Intent，使用下面的intent类型：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> - 请求拍照的Intent。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a> - 请求录像的Intent。</li>
</ul>
</li>
<li><p><strong>Start the Camera Intent</strong> - 使用<a href="http://developer.android.com/reference/android/app/Activity.html#startActivityForResult(android.content.Intent,%20int">startActivityForResult()</a>)方法来执行这个Intent。在启动这个Intent之后，相机程序会被唤起并提供拍照或者录像的功能。</p></li>
<li><p><strong>Receive the Intent Result</strong> - 在你的程序里面实现<a href="http://developer.android.com/reference/android/app/Activity.html#onActivityResult(int,%20int,%20android.content.Intent">onActivityResult()</a>)的方法用来接收相机程序返回的数据。当用户结束拍照或者录像之后，系统会调用到这个方法。</p></li>
</ul>


<h3>3.1)Image capture intent</h3>

<p>使用Camera Intent是一种使用最少的代码为你的程序开启拍照功能的一种简便的方法。一个拍照程序可以包含下面的附加信息：</p>

<p><strong><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a></strong> - 这定义了一个Uri对象来指定存放图片的路径与文件名。这个设置信息是可选的，但是强烈建议添加。如果你不指定这个值，相机程序会使用默认的文件名保存图片到默认的位置，这个值可以从Intent.getData()的字段中获取到。</p>

<p>下面的示例代码演示了如何构建一个拍照Intent并执行它。<code>getOutputMediaFileUri()</code>方法可以从<strong>Saving Media Files</strong>的段落中涉及到。</p>

<p>```java
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private Uri fileUri;</p>

<p>@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

// create Intent to take a picture and return control to the calling application
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

fileUri = getOutputMediaFileUri(MEDIA_TYPE_IMAGE); // create a file to save the image
intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri); // set the image file name

// start the image capture Intent
startActivityForResult(intent, CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE);
</code></pre>

<p>}
```</p>

<p>当startActivityForResult()方法被执行，用户会看到一个相机拍照的界面。用户执行了拍照(或者取消操作)，用户界面会回退到你的程序，你必须在onActivityResult()方法里面接收返回的数据。关于如何接受完整的intent，可以参考下面的<strong>Receiving camera intent result</strong>段落。</p>

<h3>3.2)Video capture intent</h3>

<p>视频录制的原理和拍照一致。一个视频录制的Intent可以包含如下的参数信息：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a> - 和拍照类似，这里指定保存视频的位置。同样这个字段是可选的，但是也被强烈建议进行填写。如果没有传递这个参数，相机程序会使用默认的文件名保存文件到默认的存储位置。你可以通过在返回的Intent.getData()字段中获取到这个值。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_VIDEO_QUALITY">MediaStore.EXTRA_VIDEO_QUALITY</a> - 这里的值可以为0或者1，分别表示低质量与高质量。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_DURATION_LIMIT">MediaStore.EXTRA_DURATION_LIMIT</a> - 设置这个值用来限制视频的长度，用毫秒计算。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_SIZE_LIMIT">MediaStore.EXTRA_SIZE_LIMIT</a> - 设置这个值用来限制文件的大小，用btye做单位。</li>
</ul>


<p>下面演示了如何构建一个Video Intent并执行：
```java
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;
private Uri fileUri;</p>

<p>@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

//create new Intent
Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);

fileUri = getOutputMediaFileUri(MEDIA_TYPE_VIDEO);  // create a file to save the video
intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);  // set the image file name

intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1); // set the video image quality to high

// start the Video Capture Intent
startActivityForResult(intent, CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE);
</code></pre>

<p>}
```
和拍照类似，也需要在activity的onActivityResult里面去接收数据并做处理。</p>

<h3>3.3)Receiving camera intent result</h3>

<p>一旦你构建并执行了一个拍照或者录像的Intent，你的程序必须确保能够正确接收返回的数据。为了正确的接收到Intent，你必须重写onActivityResult()的方法，下面会演示如何获取到上面示例代码返回的数据。</p>

<p>```java
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;</p>

<p>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {</p>

<pre><code>if (requestCode == CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
        // Image captured and saved to fileUri specified in the Intent
        Toast.makeText(this, "Image saved to:\n" +
                 data.getData(), Toast.LENGTH_LONG).show();
    } else if (resultCode == RESULT_CANCELED) {
        // User cancelled the image capture
    } else {
        // Image capture failed, advise user
    }
}

if (requestCode == CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
        // Video captured and saved to fileUri specified in the Intent
        Toast.makeText(this, "Video saved to:\n" +
                 data.getData(), Toast.LENGTH_LONG).show();
    } else if (resultCode == RESULT_CANCELED) {
        // User cancelled the video capture
    } else {
        // Video capture failed, advise user
    }
}
</code></pre>

<p>}
```</p>

<p>一旦你的activity成功接收了数据，那么你的程序就可以在指定的位置获取到图片或者视频了。</p>

<h2>4)创建自定义相机应用</h2>

<p>很多时候，我们都会需要开发自定义的相机应用，它能够提供更多特殊的相机功能并带来不同的用户体验。创建一个自定义的相机应用比起使用Intent调用已经存在的相机应用会复杂许多，后续我们都会基于自定义的相机扩展描述其他的相关内容。</p>

<p>通常来说创建一个自定义的相机有如下几个步骤：</p>

<ul>
<li><strong>Detect and Access Camera</strong> - 检查相机是否存在并可访问。</li>
<li><strong>Create a Preview Class</strong> - 创建一个继承自SurfaceView的preview类，并实现SurfaceHolder的接口，用这个类用来预览相机的画面。</li>
<li><strong>Build a Preview Layout</strong> - 一旦你拥有了预览组件。创建一个Layout用来承载preview并提供交互控制界面。</li>
<li><strong>Setup Listeners for Capture</strong> - 为控制界面建立监听器，用来启动拍照或者录像。</li>
<li><strong>Capture and Save Files</strong> - 建立拍照录像的代码并进行保存。</li>
<li><strong>Release the Camera</strong> - 使用完相机之后，你的程序必须正确的释放它，以便其他程序使用。</li>
</ul>


<p>相机硬件是一个共享资源，必须谨慎正确的使用，我们的程序不应该和其他可能使用相机硬件的程序有冲突。下面的段落会介绍如何检测相机硬件，如何请求获取权限，如何拍照录像以及如何在使用完毕时释放相机。</p>

<p><strong>注意:</strong> 当你的程序执行完任务之后，切记需要通过执行Camera.release()来释放相机对象。如果你的相机没有合理的释放相机，后续包括你自己的应用在内的所有的相机应用，都将无法正常打开相机并且可能导致程序崩溃。</p>

<h3>4.1)Detecting camera hardware</h3>

<p>如果你的程序没有在manifest中声明需要使用相机，你应该在运行时去检查相机是否可用。为了执行这个检查，需要使用到<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String">PackageManager.hasSystemFeature()</a>) 方法，如下所示：</p>

<p>```java
/<em>* Check if this device has a camera </em>/
private boolean checkCameraHardware(Context context) {</p>

<pre><code>if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)){
    // this device has a camera
    return true;
} else {
    // no camera on this device
    return false;
}
</code></pre>

<p>}
```</p>

<p>Android设备可以拥有多个摄像头，例如前置与后置摄像头。从Android 2.3 (API level 9)开始，可以通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#getNumberOfCameras(">Camera.getNumberOfCameras()</a>)方法获取到摄像头的个数。</p>

<h3>4.2)Accessing cameras</h3>

<p>如果已经判断到程序运行的设备上存在摄像头，接下去想要获取到某个具体的摄像头实例，需要通过先打开这个摄像头的实例来进行访问操作。</p>

<p>为了访问到主摄像头，如下所示，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(">Camera.open()</a>)方法。
```java
/<em>* A safe way to get an instance of the Camera object. </em>/
public static Camera getCameraInstance(){</p>

<pre><code>Camera c = null;
try {
    c = Camera.open(); // attempt to get a Camera instance
}
catch (Exception e){
    // Camera is not available (in use or does not exist)
}
return c; // returns null if camera is unavailable
</code></pre>

<p>}
```</p>

<p><strong>注意:</strong>当使用<code>Camera.open()</code>方法时总是需要做异常捕获。如果没有进行检查捕获，很有可能会因为相机正在使用或者相机不存在而使得程序崩溃。</p>

<p>在Android 2.3 (API level 9)开始, 可以使用通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(int">Camera.open(int)</a>)方法来访问指定的摄像头。上面演示的代码会优先获取主摄像头。</p>

<h3>4.3)Checking camera features</h3>

<p>一旦获取到相机实例，可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getParameters(">Camera.getParameters()</a>)方法来获取到更多的相机信息。也可以通过获取到的相机参数对象得到相机能够支持的功能。从android 2.3开始，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getCameraInfo(int,%20android.hardware.Camera.CameraInfo">Camera.getCameraInfo()</a>)可以获取到相机是前置还是后置摄像头以及将要拍摄出来的图片角度。</p>

<h3>4.4)Creating a preview class</h3>

<p>为了给用户提供有效的拍照与录像体验，用户需要能够对摄像头捕获的数据进行预览。相机预览是使用SurfaceView，它用来显示来自摄像头硬件传递过来的画面数据。</p>

<p>下面的示例代码演示了如何创建一个基础的相机预览类，该类可以included到另外一个layout中。为了捕获拍照事件的回调，需要实现<a href="http://developer.android.com/reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a>，之后可以在这些回调里面进行创建与销毁View的操作。</p>

<p>```java
/<em>* A basic Camera preview class </em>/
public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {</p>

<pre><code>private SurfaceHolder mHolder;
private Camera mCamera;

public CameraPreview(Context context, Camera camera) {
    super(context);
    mCamera = camera;

    // Install a SurfaceHolder.Callback so we get notified when the
    // underlying surface is created and destroyed.
    mHolder = getHolder();
    mHolder.addCallback(this);
    // deprecated setting, but required on Android versions prior to 3.0
    mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
}

public void surfaceCreated(SurfaceHolder holder) {
    // The Surface has been created, now tell the camera where to draw the preview.
    try {
        mCamera.setPreviewDisplay(holder);
        mCamera.startPreview();
    } catch (IOException e) {
        Log.d(TAG, "Error setting camera preview: " + e.getMessage());
    }
}

public void surfaceDestroyed(SurfaceHolder holder) {
    // empty. Take care of releasing the Camera preview in your activity.
}

public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
    // If your preview can change or rotate, take care of those events here.
    // Make sure to stop the preview before resizing or reformatting it.

    if (mHolder.getSurface() == null){
      // preview surface does not exist
      return;
    }

    // stop preview before making changes
    try {
        mCamera.stopPreview();
    } catch (Exception e){
      // ignore: tried to stop a non-existent preview
    }

    // set preview size and make any resize, rotate or
    // reformatting changes here

    // start preview with new settings
    try {
        mCamera.setPreviewDisplay(mHolder);
        mCamera.startPreview();

    } catch (Exception e){
        Log.d(TAG, "Error starting camera preview: " + e.getMessage());
    }
}
</code></pre>

<p>}
```</p>

<p>如果你想为你的相机预览界面设置特定的预览大小，可以在<code>surfaceChanged()</code>的回调里面进行操作(注意上面演示代码的注释)。设置预览大小时，你<strong>必须</strong>使用从<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#getSupportedPreviewSizes(">getSupportedPreviewSizes()</a>)方法获取到的预览值，不能在<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#setPreviewSize(int,%20int">setPreviewSize()</a>)方法里设置随意的预览值。</p>

<p><strong>Notes:</strong>请注意这里只是为了演示操作相机的基础步骤，实际项目中很少用下面这么简单的结构来进行操作。</p>

<h3>4.5)Placing preview in a layout</h3>

<p>在上一段落演示的Camera Preview Class，必须放置在一个activity的layout中。这一段落会演示为了预览如何创建一个基础的layout与activity。</p>

<p>下面的代码提供了一个能够显示相机预览界面的基础layout。在这段代码中，FrameLayout是相机预览类的container。使用framelayout可以在相机预览界面上叠加额外的图片信息或者是操作控制组件。</p>

<p>```xml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:orientation="horizontal"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
&gt;
</code></pre>

<p>  &lt;FrameLayout</p>

<pre><code>android:id="@+id/camera_preview"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:layout_weight="1"
/&gt;
</code></pre>

<p>  &lt;Button</p>

<pre><code>android:id="@+id/button_capture"
android:text="Capture"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_gravity="center"
/&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>在大多数设备上，相机预览的角度默认是横屏的。演示的layout指定了horizontal，并且下面的代码使得activity固定成横屏的模式。</p>

<p>```xml
&lt;activity android:name=".CameraActivity"</p>

<pre><code>      android:label="@string/app_name"

      android:screenOrientation="landscape"&gt;
      &lt;!-- configure this activity to use landscape orientation --&gt;

      &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
</code></pre>

<p></activity>
```</p>

<p><strong>Note:</strong> 相机预览界面不一定是要横屏的。从android 2.2开始，你可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation(int">setDisplayOrientation()</a>)方法来设置预览图片的角度。为了在用户旋转手机时改变相机预览的角度，在<code>surfaceChanged()</code>方法里面，首先要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#stopPreview(">Camera.stopPreview()</a>)停止预览，然后再使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#startPreview(">Camera.startPreview()</a>)方法来重新开启相机预览，后面会新写文章展开来讲这一部分的细节。</p>

<p>为了在activity中添加相机界面，你的Camera Activity必须确保在activity pause或者是destory的时候释放相机资源。下面的代码演示了如何添加camera preview class到camera activity中。</p>

<p>```java
public class CameraActivity extends Activity {</p>

<pre><code>private Camera mCamera;
private CameraPreview mPreview;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // Create an instance of Camera
    mCamera = getCameraInstance();

    // Create our Preview view and set it as the content of our activity.
    mPreview = new CameraPreview(this, mCamera);
    FrameLayout preview = (FrameLayout) findViewById(R.id.camera_preview);
    preview.addView(mPreview);
}
</code></pre>

<p>}
```</p>

<p><strong>Note:</strong> 上面演示的<code>getCameraInstance()</code>方法出现在4.2)Accessing camera段落中。</p>

<h3>4.6)触发拍照行为</h3>

<p>一旦你建立了preview class并且创建好了显示的layout。那么就可以开始做拍照的动作了。</p>

<p>为了获取到一张图片，需要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#takePicture(android.hardware.Camera.ShutterCallback,%20android.hardware.Camera.PictureCallback,%20android.hardware.Camera.PictureCallback">Camera.takePicture()</a>)方法。为了获取到JPEG格式的图片数据，你必须implement一个<a href="http://developer.android.com/reference/android/hardware/Camera.PictureCallback.html">Camera.PictureCallback</a>接口来接收图片数据并把它写到文件中。</p>

<p>```java
private PictureCallback mPicture = new PictureCallback() {</p>

<pre><code>@Override
public void onPictureTaken(byte[] data, Camera camera) {

    File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
    if (pictureFile == null){
        Log.d(TAG, "Error creating media file, check storage permissions: " +
            e.getMessage());
        return;
    }

    try {
        FileOutputStream fos = new FileOutputStream(pictureFile);
        fos.write(data);
        fos.close();
    } catch (FileNotFoundException e) {
        Log.d(TAG, "File not found: " + e.getMessage());
    } catch (IOException e) {
        Log.d(TAG, "Error accessing file: " + e.getMessage());
    }
}
</code></pre>

<p>};
```</p>

<p>触发拍照的动作，需要使用下面演示到的方法。</p>

<p>```java
// Add a listener to the Capture button
Button captureButton = (Button) findViewById(id.button_capture);
captureButton.setOnClickListener(</p>

<pre><code>new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // get an image from the camera
        mCamera.takePicture(null, null, mPicture);
    }
}
</code></pre>

<p>);
```</p>

<h3>4.7)释放相机实例</h3>

<p>相机实例是被共享的系统资源。获取到相机实例之后，程序才可以使用相机，但是，在使用完相机的时候，程序必须谨慎的释放它。建议在程序进入到pause状态时，立即释放相机资源。如果你的程序没有合理的释放相机资源，包括自己程序本身在内，后续所有的相机请求都将失败，甚至可能会导致程序崩溃。下面的代码演示了如何释放相机资源。</p>

<p>```java
public class CameraActivity extends Activity {</p>

<pre><code>private Camera mCamera;
private SurfaceView mPreview;
private MediaRecorder mMediaRecorder;

...

@Override
protected void onPause() {
    super.onPause();
    releaseMediaRecorder();       // if you are using MediaRecorder, release it first
    releaseCamera();              // release the camera immediately on pause event
}

private void releaseMediaRecorder(){
    if (mMediaRecorder != null) {
        mMediaRecorder.reset();   // clear recorder configuration
        mMediaRecorder.release(); // release the recorder object
        mMediaRecorder = null;
        mCamera.lock();           // lock camera for later use
    }
}

private void releaseCamera(){
    if (mCamera != null){
        mCamera.release();        // release the camera for other applications
        mCamera = null;
    }
}
</code></pre>

<p>}
```</p>

<h2>5)保存媒体文件</h2>

<p>前面介绍了自定义相机，使用相机拍摄的照片或者视频都需要保存到设备的external storage目录下(SDCard)。可以有多种可能的位置用来保存文件，但是作为一个开发人员，建议使用下面两种标准的路径进行保存。</p>

<ul>
<li><a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String">Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回用来保存图片与视频所推荐使用的标准共享目录。这个目录是共享开放的，所有其他的程序都可以轻易的访问，读取并删除这个目录下的文件。如果你的程序被用户卸载，在这个目录下的文件不会被移除。为了避免干扰到用户已经存在的图片与视频目录，你应该为你的程序创建一个子目录。如下面的代码所示。这个方法从Android 2.2 (API level 8)开始就可以使用。</li>
<li><a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String">Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回一个和你的程序相关联的，用来保存图片与视频的，标准目录。如果你的程序被卸载，在这个目录下的文件也会被一起移除。这个目录并不能阻止其他程序的读写。</li>
</ul>


<p>```java
public static final int MEDIA_TYPE_IMAGE = 1;
public static final int MEDIA_TYPE_VIDEO = 2;</p>

<p>/<em>* Create a file Uri for saving an image or video </em>/
private static Uri getOutputMediaFileUri(int type){</p>

<pre><code>  return Uri.fromFile(getOutputMediaFile(type));
</code></pre>

<p>}</p>

<p>/<em>* Create a File for saving an image or video </em>/
private static File getOutputMediaFile(int type){</p>

<pre><code>// To be safe, you should check that the SDCard is mounted
// using Environment.getExternalStorageState() before doing this.

File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
          Environment.DIRECTORY_PICTURES), "MyCameraApp");
// This location works best if you want the created images to be shared
// between applications and persist after your app has been uninstalled.

// Create the storage directory if it does not exist
if (! mediaStorageDir.exists()){
    if (! mediaStorageDir.mkdirs()){
        Log.d("MyCameraApp", "failed to create directory");
        return null;
    }
}

// Create a media file name
String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
File mediaFile;
if (type == MEDIA_TYPE_IMAGE){
    mediaFile = new File(mediaStorageDir.getPath() + File.separator +
    "IMG_"+ timeStamp + ".jpg");
} else if(type == MEDIA_TYPE_VIDEO) {
    mediaFile = new File(mediaStorageDir.getPath() + File.separator +
    "VID_"+ timeStamp + ".mp4");
} else {
    return null;
}
return mediaFile;
</code></pre>

<p>}
```</p>

<h2>6)相机相关特性</h2>

<p>Android提供了控制相机特性的方法，例如图片格式，闪光灯模式，聚焦模式等等。这一段落列出了大部分相机共有的功能并简短的介绍如何使用这些功能。大多数相机特性可以通过<strong>Camera.Parameters</strong>对象来获取并进行相关的设置。然而，有几个重要的功能不仅仅是通过<strong>Camera.Parameters</strong>能够实现的。请看下面的内容介绍：</p>

<ul>
<li>Metering and focus areas：测光并进行聚焦</li>
<li>Face detection：人脸检测</li>
</ul>


<p>关于上面2个常用的功能会在以后的文章中进行更加详细的介绍，除此之外的其他相机特性功能，请参考下面这张表：</p>

<p><img src="/images/articles/camera_features_table.png" title="Camera Common Features" alt="camera_features_table.png" /></p>

<p><strong>Note:</strong> 因为软硬件的差异性，那些功能并不一定都是支持的。对于检查功能是否可用，请参考下面的Checking feature availability.</p>

<h3>6.1)Checking feature availability</h3>

<p>相机的有些功能在所有手机上并不一定是都支持的。在开发相机应用时就需要提前考虑应该适配到哪个level。然后开发的时候需要动态的去根据功能是否支持来做不同的处理。</p>

<p>你可以通过获取到相机参数的对象来做检测。下面的例子演示了如何检查autofocus功能是否可用：
```java
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();</p>

<p>List<String> focusModes = params.getSupportedFocusModes();
if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
  // Autofocus mode is supported
}
```</p>

<p>对于大多数的相机特性，都可以使用类型上面的代码来处理。Camera.Parameters对象提供了一系列的类似<code>getSupported...()</code>, <code>is...Supported()</code> 与 <code>getMax...()</code> 方法来判断某个功能是否可用的。</p>

<p>如果你的程序确定需要相机的某个特性，你可以在mainfest文件中就进声明。例如你声明了flash与auto-focus的功能，那么Google Play会阻止那些不支持这些功能的设备安装这个应用。关于相机功能的声明列表，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">Features Reference.</a></p>

<h3>6.2)Using camera features</h3>

<p>前面已经提到过，通过Camera.Parameters对象来操控相机。如下所示：
<code>java
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();
// set the focus mode
params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
// set Camera parameters
mCamera.setParameters(params);
</code>
上面这种方法对大多数相机功能都是可用的，在你获取到相机的实例之后，大多数参数都是在任意时间均可以修改的。参数修改的效果在相机预览的界面是可以立即看到效果的。在软件层面，实际上可能是需要花几帧的时间来产生效果的，因为需要发送指令给相机硬件产生效果。</p>

<p><strong>Important:</strong> 有部分相机特性不是想要修改的时候就可以直接修改的。尤其是，修改相机预览的角度与相机预览大小，很多时候是需要先停止预览，设置参数，再重启预览的。从Android Android 4.0(API level 14)开始，预览角度可以不用重启预览就可以进行修改。</p>

<hr />

<p><strong>后记:</strong>这篇概览大致介绍了Android平台上相机开发相关的基础概念，上面的演示代码仅仅是为了说明问题，在真实项目的实践中，相机实例的相关操作都会放在单独的线程中，很多基础的操作都可能遇到复杂的兼容性问题，为了解决兼容性的问题，提高性能等等的需要，会做很大的调整，更多细节请期待后续的文章，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第6季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-6/"/>
    <updated>2016-10-04T23:12:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-6</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_common.png" alt="android_perf_patterns_season_common" /></p>

<blockquote><p>这里是<a href="https://www.youtube.com/watch?v=Vw1G1s73DsY&amp;index=74&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第6季的课程学习笔记，从被@知会到有连载更新，这篇学习笔记就一直被惦记着，现在学习记录分享一下，请多多指教包涵！这次一共才6个小段落，涉及的内容主要有：程序启动时间性能优化的三个方面：优化activity的创建过程，优化application对象的启动过程，正确使用启动显屏达到优化程序启动性能的目的。另外还介绍了减少安装包大小的checklist以及如何使用VectorDrawable来减少安装包的大小。</p></blockquote>

<h2>1）App Launch time 101</h2>

<p>提高程序的启动速度意义重大，很显然，启动时间越短，用户才越有耐心等待打开这个APP进行使用，反之启动时间越长，用户则越有可能来不及等到APP打开就已经切换到其他APP了。程序启动过程中的那些复杂错误的操作很可能导致严重的性能问题。Android系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他APP界面切换回来）。那么关键的问题是，用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他APP了。更严重的是，如果启动时间过长，可能导致程序出现ANR。我们应该避免出现这两种糟糕的情况。</p>

<p>从技术角度来说，当用户点击桌面图标开始，系统会立即为这个APP创建独立的专属进程，然后显示启动窗口，直到APP在自己的进程里面完成了程序的创建以及主线程完成了Activity的初始化显示操作，再然后系统进程就会把启动窗口替换成APP的显示窗口。</p>

<p><img src="/images/android_perf_6_launch_time_start_process.png" alt="android_perf_6_launch_time_start_process" /></p>

<!-- More -->


<p>上述流程里面的绝大多数步骤都是由系统控制的，一般来说不会出现什么问题，可是对于启动速度，我们能够控制并且需要特别关注的地方主要有三处：</p>

<ul>
<li>1）Activity的onCreate流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题。</li>
<li>2）Application的onCreate流程，对于大型的APP来说，通常会在这里做大量的通用组件的初始化操作。</li>
<li>3）目前有部分APP会提供自定义的启动窗口，这里可以做成品牌宣传界面或者是给用户提供一种程序已经启动的视觉效果。</li>
</ul>


<p>在正式着手解决问题之前，我们需要掌握一套正确测量评估启动性能的方法。所幸的是，Android系统有提供一些工具来帮助我们定位问题。</p>

<ul>
<li>1）首先是<strong>display time</strong>：从Android KitKat版本开始，Logcat中会输出从程序启动到某个Activity显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_display_time.png" alt="android_perf_6_launch_time_display_time" /></p>

<ul>
<li>2）其次是<strong>reportFullyDrawn</strong>方法：我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用<code>activity.reportFullyDrawn()</code>方法来告诉系统此时的状态，以便获取整个加载的耗时。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_report_fully_drawn.png" alt="android_perf_6_launch_time_report_fully_drawn" /></p>

<ul>
<li>3）然后是<strong>Method Tracing</strong>：前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用Method Tracing工具来进行详细的测量。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_method_tracing.png" alt="android_perf_6_launch_time_method_tracing" /></p>

<ul>
<li>4）最后是<strong>Systrace</strong>：我们可以在onCreate方法里面添加trace.beginSection()与trace.endSection()方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_systrace.png" alt="android_perf_6_launch_time_systrace" /></p>

<h2>2）App Launch Time &amp; Activity Creation</h2>

<p>提升Activity的创建速度是优化APP启动速度的首要关注目标。从桌面点击APP图标启动应用开始，程序会显示一个启动窗口等待Activity的创建加载完毕再进行显示。在Activity的创建加载过程中，会执行很多的操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写Preference等等。</p>

<p><img src="/images/android_perf_6_activity_creation_0.png" alt="android_perf_6_activity_creation_0" /></p>

<p>上述操作的任何一个环节出现性能问题都可能导致画面不能及时显示，影响了程序的启动速度。上一个段落我们介绍了使用Method Tracing来发现那些耗时占比相对较多的方法。假设我们发现某个方法执行时间过长，接下去就可以使用Systrace来帮忙定位到底是什么原因导致那个方法执行时间过长。</p>

<p>除了使用工具进行具体定位分析性能问题之外，以下两点经验可以帮助我们对Activity启动做性能优化：</p>

<ul>
<li>1）优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！</li>
<li>2）异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。</li>
</ul>


<h2>3）App Launch Time &amp; Bloated Application Objects</h2>

<p>在Application初始化的地方做太多繁重的事情是可能导致严重启动性能问题的元凶之一。Application里面的初始化操作不结束，其他任意的程序操作都无法进行。</p>

<p><img src="/images/android_perf_6_application_objs.png" alt="android_perf_6_application_objs" /></p>

<p>有时候，我们会一股脑的把绝大多数全局组件的初始化操作都放在Application的onCreate里面，但其实很多组件是需要做区队对待的，有些可以做延迟加载，有些可以放到其他的地方做初始化操作，特别需要留意包含Disk IO操作，网络访问等严重耗时的任务，他们会严重阻塞程序的启动。</p>

<p><img src="/images/android_perf_6_application_create.png" alt="android_perf_6_application_create" /></p>

<p>优化这些问题的解决方案是做延迟加载，可以在application里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。</p>

<p><img src="/images/android_perf_6_application_lazyload.png" alt="android_perf_6_application_lazyload" /></p>

<h2>4）App Launch Time &amp; Theme Launch Screens</h2>

<p>启动闪屏不仅仅可以作为品牌宣传页，还能够减轻用户对启动耗时的感知，但是如果使用不恰当，将适得其反。前面介绍过当点击桌面图标启动APP的时候，程序会显示一个启动窗口，一直到页面的渲染加载完毕。如果程序的启动速度足够快，我们看的闪屏窗口停留显示的时间则会很短，但是当程序启动速度偏慢的时候，这个启动闪屏可以一定程度上减轻用户等待的焦虑感，避免用户过于轻易的关闭应用。</p>

<p>目前大多数开发者都会通过设置启动窗口主题的方式来替换系统默认的启动窗口，通过这种方式只是使用『障眼法』弱化了用户对启动时间的感知，但本质上并没有对启动速度做什么优化。也有些APP通过关闭启动窗口属性<code>android:windowDisablePreview</code>的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，这样的用户体验是十分糟糕的！</p>

<p><img src="/images/android_perf_6_launch_screen.png" alt="android_perf_6_launch_screen" />
<img src="/images/android_perf_6_launch_screen2.png" alt="android_perf_6_launch_screen2" /></p>

<p>对于启动闪屏，正确的使用方法是自定义一张图片，把这张图片通过设置主题的方式显示为启动闪屏，代码执行到主页面的onCreate的时候设置为程序正常的主题。</p>

<p><img src="/images/android_perf_6_launch_screen3.png" alt="android_perf_6_launch_screen3" />
<img src="/images/android_perf_6_launch_screen4.png" alt="android_perf_6_launch_screen4" /></p>

<h2>5）Smaller APKs: A Checklist</h2>

<p>减少应用程序安装包的大小，不仅仅减少了用户的网络数据流量还减少了下载等待的时间。毋庸置疑，尽量减少程序安装包的大小是十分有必要的。通常来说，减少程序安装包的大小有两条规律：要么减少程序资源的大小，要么就是减少程序的代码量。这里总结一个简易版的减少安装包大小的Checklist:</p>

<h3>减少程序图片资源的大小</h3>

<ul>
<li>1）确保在build.gradle文件中开启了<code>minifEnabled</code>与<code>shrinkResources</code>的属性，这两个属性可以帮助移除那些在程序中使用不到的代码与资源，帮助减少APP的安装包大小。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_gradle.png" alt="android_perf_6_smaller_apks_gradle" /></p>

<ul>
<li>2）有选择性的提供对应分辨率的图片资源，系统会自动匹配最合适分辨率的图片并执行拉伸或者压缩的处理。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_dpi.png" alt="android_perf_6_smaller_apks_dpi" /></p>

<ul>
<li>3）在符合条件的情况下，使用Vertor Drawable替代传统的PNG/JPEG图片，能够极大的减少图片资源的大小。传统模式下，针对不同dpi的手机都需要提供一套PNG/JPEG的图片，而如果使用Vector Drawable的话，只需要一个XML文件即可。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_vector.png" alt="android_perf_6_smaller_apks_vector" /></p>

<ul>
<li>4）尽量复用已经存在的资源图片，使用代码的方式对已有的资源进行复用，如下图所示：</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_reuse.png" alt="android_perf_6_smaller_apks_reuse" /></p>

<p>以上几点虽然看起来都微不足道，但是真正执行之后，能够显著减少安装包的资源图片大小。</p>

<h3>减少程序的代码量</h3>

<ul>
<li><p>1）开启MinifEnabled，Proguard。打开这些编译属性之后，程序在打包的时候就不会把没有引用到的代码编译进来，以此达到减少安装包大小的目的。</p></li>
<li><p>2）注意因为编译行为额外产生的方法数，例如类似Enum，Protocal Buffer可能导致方法数与类的个数增加。</p></li>
<li><p>3）部分引入到工程中的jar类库可能并不是专门针对移动端APP而设计的，他们最开始可能是运用在PC或者Server上的。使用这些类库不仅仅额外增加了包的大小，还增加了编译时间。单纯依靠Proguard可能无法完全移除那些使用不到的方法，最佳的方式是使用一些更加轻量化，专门为Android APP设计的jar类库。</p></li>
</ul>


<h3>安装包的拆分</h3>

<p>设想一下，一个low dpi，API&lt;14的用户手机下载安装的APK里面却包含了大量xxhdpi的资源文件，对于这个用户来说，这个APK是存在很大的资源浪费的。幸好Android平台为我们提供了拆分APK的方法，它能够根据API Level，屏幕大小以及GPU版本的不同进行拆分，使得对应平台的用户下载到最合适自己手机的安装包。</p>

<p><img src="/images/android_perf_6_smaller_apks_split.png" alt="android_perf_6_smaller_apks_split" /></p>

<p>更多关于安装包拆分的信息，请查看<a href="https://developer.android.com/studio/build/configure-apk-splits.html">Configure APK Splits</a>与<a href="https://developer.android.com/training/multiple-apks/index.html">Maintaining Multiple APKs</a>(由于国内应用分发市场的现状，这一条几乎没有办法执行)。</p>

<h2>6）VectorDrawable for smaller APKs</h2>

<p>针对不同的分辨率提供多张精度的图片会额外增加APK的大小，针对这个问题的解决方案是考虑使用VectorDrawable，它仅仅只需要一个文件，能够动态生成对应分辨率的图片。</p>

<p><a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html">VectorDrawable</a>通过XML文件描述图片的形状，大小，样式。</p>

<p><img src="/images/android_perf_6_vectordrawable_origin.png" alt="android_perf_6_vectordrawable_origin" /></p>

<p>通过这种方式，我们可以显著减少图片资源对安装包大小的影响。</p>

<p><img src="/images/android_perf_6_vectordrawable_dpi.png" alt="android_perf_6_vectordrawable_dpi" />
<img src="/images/android_perf_6_vectordrawable_dpi2.png" alt="android_perf_6_vectordrawable_dpi2" /></p>

<p>使用VectorDrawable还可以避免因为使用帧动画导致的图片资源过多的情况，如下图所示</p>

<p><img src="/images/android_perf_6_vectordrawable_animation.png" alt="android_perf_6_vectordrawable_animation" /></p>

<p>前面介绍了VectorDrawable(VD)的优势，但是在使用VectorDrawable的时候，还是有以下的问题需要特别注意的？</p>

<ul>
<li>首先VD的加载有异于JPEG/PNG文件，图片文件可以依靠硬件进行纹理的渲染，而VD文件需要先进行加载解析，然后才能够进行纹理的渲染。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_load.png" alt="android_perf_6_vectordrawable_load" /></p>

<ul>
<li>其次VD文件适用于简单有规则的图片渲染，不适用于那些纹理过于复杂的图片，这样不仅仅会过度增加描述文件的复杂度还可能无法获取到想要的渲染效果。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_simple.png" alt="android_perf_6_vectordrawable_simple" /></p>

<ul>
<li>最后VD文件中关于Path的描述需要尽量简化，复杂冗余的Path信息不仅对得到想要的图片没有益处，还增加了加载渲染的难度。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_path.png" alt="android_perf_6_vectordrawable_path" /></p>

<hr />

<p>首发于CSDN：<a href="http://geek.csdn.net/news/detail/106513">Android性能优化典范（六）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google I/O 2016随笔]]></title>
    <link href="http://hukai.me/google-io-2016/"/>
    <updated>2016-05-24T05:06:01+08:00</updated>
    <id>http://hukai.me/google-io-2016</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/oasisfeng">冯老师</a>，<a href="https://github.com/liaohuqiu">秋百万</a>，<a href="http://www.race604.com/">吴晶</a>还有我！四人约好从北京转机一起前往旧金山。</p>

<p><img src="/images/google_io_2016_00.JPG" alt="google_io_2016_00" /></p>

<p>在航班上研究KMP算法的同学</p>

<p><img src="/images/google_io_2016_01.JPG" alt="google_io_2016_01" /></p>

<p>到达旧金山机场，去提取事先租好的车，自驾</p>

<!-- More -->


<p><img src="/images/google_io_2016_02.JPG" alt="google_io_2016_02" /></p>

<p><img src="/images/google_io_2016_03.JPG" alt="google_io_2016_03" /></p>

<p><img src="/images/google_io_2016_04.JPG" alt="google_io_2016_04" /></p>

<p>入住通过Airbnb上找的房子</p>

<p><img src="/images/google_io_2016_05.JPG" alt="google_io_2016_05" /></p>

<p><img src="/images/google_io_2016_06.JPG" alt="google_io_2016_06" /></p>

<p>到美国吃的第一顿（中式餐馆）没预料到这会是之后几天我吃的最满意的一次了</p>

<p><img src="/images/google_io_2016_07.JPG" alt="google_io_2016_07" /></p>

<p>第二天一早清晨，在海边小镇上闲逛</p>

<p><img src="/images/google_io_2016_08.JPG" alt="google_io_2016_08" />
<img src="/images/google_io_2016_09.JPG" alt="google_io_2016_09" />
<img src="/images/google_io_2016_10.JPG" alt="google_io_2016_10" />
<img src="/images/google_io_2016_11.JPG" alt="google_io_2016_11" />
<img src="/images/google_io_2016_12.JPG" alt="google_io_2016_12" /></p>

<p>之后去了旁边的半月湾海边走走，以及不远处的森林公园爬山</p>

<p><img src="/images/google_io_2016_13.JPG" alt="google_io_2016_13" />
<img src="/images/google_io_2016_14.JPG" alt="google_io_2016_14" />
<img src="/images/google_io_2016_15.JPG" alt="google_io_2016_15" /></p>

<p>晚上跑到旧金山最高点，看全市夜景</p>

<p><img src="/images/google_io_2016_16.JPG" alt="google_io_2016_16" /></p>

<p>离开半月湾海边公寓之前的合影（从左至右，依次为吴晶，冯老师，秋百万和我）</p>

<p><img src="/images/google_io_2016_17.JPG" alt="google_io_2016_17" /></p>

<p>窗外的全景</p>

<p><img src="/images/google_io_2016_19.JPG" alt="google_io_2016_19" /></p>

<p>I/O的头一天签到</p>

<p><img src="/images/google_io_2016_21.JPG" alt="google_io_2016_21" />
<img src="/images/google_io_2016_20.JPG" alt="google_io_2016_20" />
<img src="/images/google_io_2016_22.JPG" alt="google_io_2016_22" />
<img src="/images/google_io_2016_23.JPG" alt="google_io_2016_23" />
<img src="/images/google_io_2016_24.JPG" alt="google_io_2016_24" /></p>

<p>顺便参观了下Google总部</p>

<p><img src="/images/google_io_2016_25.JPG" alt="google_io_2016_25" />
<img src="/images/google_io_2016_26.JPG" alt="google_io_2016_26" />
<img src="/images/google_io_2016_27.JPG" alt="google_io_2016_27" />
<img src="/images/google_io_2016_28.JPG" alt="google_io_2016_28" />
<img src="/images/google_io_2016_29.JPG" alt="google_io_2016_29" />
<img src="/images/google_io_2016_30.JPG" alt="google_io_2016_30" /></p>

<p>签到当天晚上，又是一群聚会聊天</p>

<p><img src="/images/google_io_2016_32.JPG" alt="google_io_2016_32" />
<img src="/images/google_io_2016_31.JPG" alt="google_io_2016_31" /></p>

<p>次日I/O正式开场，主会场，分会场持续三天</p>

<p><img src="/images/google_io_2016_33.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_34.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_35.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_36.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_37.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_38.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_39.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_40.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_41.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_42.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_43.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_44.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_45.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_46.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_47.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_48.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_49.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_50.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_51.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_52.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_53.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_54.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_55.JPG" alt="google_io_2016_31" /></p>

<p>用一张合影结尾</p>

<p><img src="/images/google_io_2016_18.JPG" alt="google_io_2016_18" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第5季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-5/"/>
    <updated>2016-04-28T00:08:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-5</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_5.png" alt="android_perf_patterns_season_5" /></p>

<blockquote><p>这是<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第5季的课程学习笔记，拖拖拉拉很久，记录分享给大家，请多多包涵担待指正！文章共10个段落，涉及的内容有：多线程并发的性能问题，介绍了AsyncTask，HandlerThread，IntentService与ThreadPool分别适合的使用场景以及各自的使用注意事项，这是一篇了解Android多线程编程不可多得的基础文章，清楚的了解这些Android系统提供的多线程基础组件之间的差异以及优缺点，才能够在项目实战中做出最恰当的选择。</p></blockquote>

<h2>1)Threading Performance</h2>

<p>在程序开发的实践当中，为了让程序表现得更加流畅，我们肯定会需要使用到多线程来提升程序的并发执行性能。但是编写多线程并发的代码一直以来都是一个相对棘手的问题，所以想要获得更佳的程序性能，我们非常有必要掌握多线程并发编程的基础技能。</p>

<p>众所周知，Android程序的大多数代码操作都必须执行在主线程，例如系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程。</p>

<p><img src="/images/android_perf_5_threading_main_thread.png" alt="android_perf_5_threading_main_thread" /></p>

<!-- More -->


<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的UI绘制等等。我们知道，为了让屏幕的刷新帧率达到60fps，我们需要确保16ms内完成单次刷新的操作。一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了(一旦刷新帧率降到20fps左右，用户就可以明显感知到卡顿不流畅了)。</p>

<p><img src="/images/android_perf_5_threading_dropframe.png" alt="android_perf_5_threading_dropframe" /></p>

<p>为了避免上面提到的掉帧问题，我们需要使用多线程的技术方案，把那些操作复杂的任务移动到其他线程当中执行，这样就不容易阻塞主线程的操作，也就减小了出现掉帧的可能性。</p>

<p><img src="/images/android_perf_5_threading_workthread.png" alt="android_perf_5_threading_workthread" /></p>

<p>那么问题来了，为主线程减轻负的多线程方案有哪些呢？这些方案分别适合在什么场景下使用？Android系统为我们提供了若干组工具类来帮助解决这个问题。</p>

<ul>
<li><strong>AsyncTask</strong>: 为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li><strong>HandlerThread</strong>: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li><strong>ThreadPool</strong>: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li><strong>IntentService</strong>: 适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。</li>
</ul>


<p>了解这些系统提供的多线程工具类分别适合在什么场景下，可以帮助我们选择合适的解决方案，避免出现不可预期的麻烦。虽然使用多线程可以提高程序的并发量，但是我们需要特别注意因为引入多线程而可能伴随而来的内存问题。举个例子，在Activity内部定义的一个AsyncTask，它属于一个内部类，该类本身和外面的Activity是有引用关系的，如果Activity要销毁的时候，AsyncTask还仍然在运行，这会导致Activity没有办法完全释放，从而引发内存泄漏。所以说，多线程是提升程序性能的有效手段之一，但是使用多线程却需要十分谨慎小心，如果不了解背后的执行机制以及使用的注意事项，很可能引起严重的问题。</p>

<h2>2)Understanding Android Threading</h2>

<p>通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。</p>

<p><img src="/images/android_perf_5_thread_lifecycle.png" alt="android_perf_5_thread_lifecycle" /></p>

<p>在很多时候，线程不仅仅是线性执行一系列的任务就结束那么简单的，我们会需要增加一个任务队列，让线程不断的从任务队列中获取任务去进行执行，另外我们还可能在线程执行的任务过程中与其他的线程进行协作。如果这些细节都交给我们自己来处理，这将会是件极其繁琐又容易出错的事情。</p>

<p><img src="/images/android_perf_5_thread_thread.png" alt="android_perf_5_thread_thread" /></p>

<p>所幸的是，Android系统为我们提供了Looper，Handler，MessageQueue来帮助实现上面的线程任务模型：</p>

<p><strong>Looper</strong>: 能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。</p>

<p><img src="/images/android_perf_5_thread_looper.png" alt="android_perf_5_thread_looper" /></p>

<p><strong>Handler</strong>: 能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。</p>

<p><img src="/images/android_perf_5_thread_handler.png" alt="android_perf_5_thread_handler" /></p>

<p><strong>MessageQueue</strong>: 使用Intent，Message，Runnable作为任务的载体在不同的线程之间进行传递。</p>

<p><img src="/images/android_perf_5_thread_messagequeue.png" alt="android_perf_5_thread_messagequeue" /></p>

<p>把上面三个组件打包到一起进行协作，这就是<strong>HandlerThread</strong></p>

<p><img src="/images/android_perf_5_thread_handlerthread.png" alt="android_perf_5_thread_handlerthread" /></p>

<p>我们知道，当程序被启动，系统会帮忙创建进程以及相应的主线程，而这个主线程其实就是一个HandlerThread。这个主线程会需要处理系统事件，输入事件，系统回调的任务，UI绘制等等任务，为了避免主线程任务过重，我们就会需要不断的开启新的工作线程来处理那些子任务。</p>

<h2>3)Memory &amp; Threading</h2>

<p>增加并发的线程数会导致内存消耗的增加，平衡好这两者的关系是非常重要的。我们知道，多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a>等等。为了解决这些问题，我们会需要引入<strong>锁</strong>的概念。</p>

<p>在Android系统中也无法避免因为多线程的引入而导致出现诸如上文提到的种种问题。Android UI对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>

<p> <img src="/images/android_perf_5_memory_thread_update.png" alt="android_perf_5_memory_thread_update" /></p>

<p>另外，在非UI线程中直接持有UI对象的引用也很可能出现问题。例如Work线程中持有某个UI对象的引用，在Work线程执行完毕之前，UI对象在主线程中被从ViewHierarchy中移除了，这个时候UI对象的任何属性都已经不再可用了，另外对这个UI对象的更新操作也都没有任何意义了，因为它已经从ViewHierarchy中被移除，不再绘制到画面上了。</p>

<p><img src="/images/android_perf_5_memory_view_remove.png" alt="android_perf_5_memory_view_remove" /></p>

<p>不仅如此，View对象本身对所属的Activity是有引用关系的，如果工作线程持续保有View的引用，这就可能导致Activity无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。例如通常我们会看到在Activity里面定义的一个AsyncTask，这种类型的AsyncTask与外部的Activity是存在隐式引用关系的，只要Task没有结束，引用关系就会一直存在，这很容易导致Activity的泄漏。更糟糕的情况是，它不仅仅发生了内存泄漏，还可能导致程序异常或者崩溃。</p>

<p><img src="/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>为了解决上面的问题，我们需要谨记的原则就是：不要在任何非UI线程里面去持有UI对象的引用。系统为了确保所有的UI对象都只会被UI线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当Activity被销毁的时候，由该Activity所触发的非UI线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止UI对象被错误的使用。</p>

<h2>4)Good AsyncTask Hunting</h2>

<p>AsyncTask是一个让人既爱又恨的组件，它提供了一种简便的异步处理机制，但是它又同时引入了一些令人厌恶的麻烦。一旦对AsyncTask使用不当，很可能对程序的性能带来负面影响，同时还可能导致内存泄露。</p>

<p>举个例子，常遇到的一个典型的使用场景：用户切换到某个界面，触发了界面上的图片的加载操作，因为图片的加载相对来说耗时比较长，我们需要在子线程中处理图片的加载，当图片在子线程中处理完成之后，再把处理好的图片返回给主线程，交给UI更新到画面上。</p>

<p><img src="/images/android_perf_5_asynctask_main.png" alt="android_perf_5_asynctask_main" /></p>

<p>AsyncTask的出现就是为了快速的实现上面的使用场景，AsyncTask把在主线程里面的准备工作放到<code>onPreExecute()</code>方法里面进行执行，<code>doInBackground()</code>方法执行在工作线程中，用来处理那些繁重的任务，一旦任务执行完毕，就会调用<code>onPostExecute()</code>方法返回到主线程。</p>

<p><img src="/images/android_perf_5_asynctask_mode.png" alt="android_perf_5_asynctask_mode" /></p>

<p>使用AsyncTask需要注意的问题有哪些呢？请关注以下几点：</p>

<ul>
<li>首先，默认情况下，所有的AsyncTask任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个AsyncTask，一旦其中的某个AsyncTask执行时间过长，队列中的其他剩余AsyncTask都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。情况如下图所示：</li>
</ul>


<p><img src="/images/android_perf_5_asynctask_single_queue.png" alt="android_perf_5_asynctask_single_queue" /></p>

<p>为了解决上面提到的线性队列等待的问题，我们可以使用<code>AsyncTask.executeOnExecutor()</code>强制指定AsyncTask使用线程池并发调度任务。</p>

<p><img src="/images/android_perf_5_asynctask_thread_pool.png" alt="android_perf_5_asynctask_thread_pool" /></p>

<ul>
<li>其次，如何才能够真正的取消一个AsyncTask的执行呢？我们知道AsyncTaks有提供<code>cancel()</code>的方法，但是这个方法实际上做了什么事情呢？线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在<code>doInBackground()</code>的代码中不断的添加程序是否被中止的判断逻辑，如下图所示：</li>
</ul>


<p><img src="/images/android_perf_5_asynctask_cancel.png" alt="android_perf_5_asynctask_cancel" /></p>

<p>一旦任务被成功中止，AsyncTask就不会继续调用<code>onPostExecute()</code>，而是通过调用<code>onCancelled()</code>的回调方法反馈任务执行取消的结果。我们可以根据任务回调到哪个方法（是onPostExecute还是onCancelled）来决定是对UI进行正常的更新还是把对应的任务所占用的内存进行销毁等。</p>

<ul>
<li>最后，使用AsyncTask很容易导致内存泄漏，一旦把AsyncTask写成Activity的内部类的形式就很容易因为AsyncTask生命周期的不确定而导致Activity发生泄漏。</li>
</ul>


<p><img src="/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>综上所述，AsyncTask虽然提供了一种简单便捷的异步机制，但是我们还是很有必要特别关注到他的缺点，避免出现因为使用错误而导致的严重系统性能问题。</p>

<h2>5）Getting a HandlerThread</h2>

<p>大多数情况下，AsyncTask都能够满足多线程并发的场景需要（在工作线程执行任务并返回结果到主线程），但是它并不是万能的。例如打开相机之后的预览帧数据是通过<code>onPreviewFrame()</code>的方法进行回调的，<code>onPreviewFrame()</code>和<code>open()</code>相机的方法是执行在同一个线程的。</p>

<p><img src="/images/android_perf_5_handlerthread_camera_open.png" alt="android_perf_5_handlerthread_camera_open" /></p>

<p>如果这个回调方法执行在UI线程，那么在onPreviewFrame()里面将要执行的数据转换操作将和主线程的界面绘制，事件传递等操作争抢系统资源，这就有可能影响到主界面的表现性能。</p>

<p><img src="/images/android_perf_5_handlerthread_main_thread2.png" alt="android_perf_5_handlerthread_main_thread2" /></p>

<p>我们需要确保onPreviewFrame()执行在工作线程。如果使用AsyncTask，会因为AsyncTask默认的线性执行的特性(即使换成并发执行)会导致因为无法把任务及时传递给工作线程而导致任务在主线程中被延迟，直到工作线程空闲，才可以把任务切换到工作线程中进行执行。</p>

<p><img src="/images/android_perf_5_handlerthread_asynctask.png" alt="android_perf_5_handlerthread_asynctask" /></p>

<p>所以我们需要的是一个执行在工作线程，同时又能够处理队列中的复杂任务的功能，而HandlerThread的出现就是为了实现这个功能的，它组合了Handler，MessageQueue，Looper实现了一个长时间运行的线程，不断的从队列中获取任务进行执行的功能。</p>

<p><img src="/images/android_perf_5_handlerthread_outline.png" alt="android_perf_5_handlerthread_outline" /></p>

<p>回到刚才的处理相机回调数据的例子，使用HandlerThread我们可以把open()操作与onPreviewFrame()的操作执行在同一个线程，同时还避免了AsyncTask的弊端。如果需要在onPreviewFrame()里面更新UI，只需要调用runOnUiThread()方法把任务回调给主线程就够了。</p>

<p><img src="/images/android_perf_5_handlerthread_camera.png" alt="android_perf_5_handlerthread_camera" /></p>

<p>HandlerThread比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。</p>

<p>另外很重要的一点是，一旦我们使用了HandlerThread，需要特别注意给HandlerThread设置不同的线程优先级，CPU会根据设置的不同线程优先级对所有的线程进行调度优化。</p>

<p><img src="/images/android_perf_5_handlerthread_priority.png" alt="android_perf_5_handlerthread_priority" /></p>

<p>掌握HandlerThread与AsyncTask之间的优缺点，可以帮助我们选择合适的方案。</p>

<h2>6）Swimming in Threadpools</h2>

<p>线程池适合用在把任务进行分解，并发进行执行的场景。通常来说，系统里面会针对不同的任务设置一个单独的守护线程用来专门处理这项任务。例如使用Networking Thread用来专门处理网络请求的操作，使用IO Thread用来专门处理系统的I\O操作。针对那些场景，这样设计是没有问题的，因为对应的任务单次执行的时间并不长而且可以是顺序执行的。但是这种专属的单线程并不能满足所有的情况，例如我们需要一次性decode 40张图片，每个线程需要执行4ms的时间，如果我们使用专属单线程的方案，所有图片执行完毕会需要花费160ms(40*4)，但是如果我们创建10个线程，每个线程执行4个任务，那么我们就只需要16ms就能够把所有的图片处理完毕。</p>

<p><img src="/images/android_perf_5_threadpool_1.png" alt="android_perf_5_threadpool_1" /></p>

<p>为了能够实现上面的线程池模型，系统为我们提供了<code>ThreadPoolExecutor</code>帮助类来简化实现，剩下需要做的就只是对任务进行分解就好了。</p>

<p><img src="/images/android_perf_5_threadpool_2.png" alt="android_perf_5_threadpool_2" /></p>

<p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为CPU只能同时执行固定数量的线程数，一旦同时并发的线程数量超过CPU能够同时执行的阈值，CPU就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>

<p><img src="/images/android_perf_5_threadpool_3.png" alt="android_perf_5_threadpool_3" /></p>

<p>一旦同时并发的线程数量达到一定的量级，这个时候CPU在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少64K+的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>

<p><img src="/images/android_perf_5_threadpool_4.png" alt="android_perf_5_threadpool_4" /></p>

<p>另外需要关注的一个问题是：<code>Runtime.getRuntime().availableProcesser()</code>方法并不可靠，他返回的值并不是真实的CPU核心数，因为CPU会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的CPU核心数。</p>

<h2>7）The Zen of IntentService</h2>

<p>默认的Service是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的AsyncTask与HandlerThread，我们还可以选择使用IntentService来实现异步操作。IntentService继承自普通Service同时又在内部创建了一个HandlerThread，在<code>onHandlerIntent()</code>的回调里面处理扔到IntentService的任务。所以IntentService就不仅仅具备了异步线程的特性，还同时保留了Service不受主页面生命周期影响的特点。</p>

<p><img src="/images/android_perf_5_intentservice_outline.png" alt="android_perf_5_intentservice_outline" /></p>

<p>如此一来，我们可以在IntentService里面通过设置闹钟间隔性的触发异步任务，例如刷新数据，更新缓存的图片或者是分析用户操作行为等等，当然处理这些任务需要小心谨慎。</p>

<p>使用IntentService需要特别留意以下几点：</p>

<ul>
<li>首先，因为IntentService内置的是HandlerThread作为异步线程，所以每一个交给IntentService的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</li>
<li>其次，通常使用到IntentService的时候，我们会结合使用BroadcastReceiver把工作线程的任务执行结果返回给主UI线程。使用广播容易引起性能问题，我们可以使用LocalBroadcastManager来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用<code>runOnUiThread()</code>快速回调到主UI线程。</li>
<li>最后，包含正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>


<h2>8）Threading and Loaders</h2>

<p>当启动工作线程的Activity被销毁的时候，我们应该做点什么呢？为了方便的控制工作线程的启动与结束，Android为我们引入了Loader来解决这个问题。我们知道Activity有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在Activity不停的创建与销毁的过程当中，很有可能因为工作线程持有Activity的View而导致内存泄漏(因为工作线程很可能持有View的强引用，另外工作线程的生命周期还无法保证和Activity的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在Activity被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。</p>

<p><img src="/images/android_perf_5_loader_bad.png" alt="android_perf_5_loader_bad" /></p>

<p>Loader的出现就是为了确保工作线程能够和Activity的生命周期保持一致，同时避免出现前面提到的问题。</p>

<p><img src="/images/android_perf_5_loader_good.png" alt="android_perf_5_loader_good" /></p>

<p>LoaderManager会对查询的操作进行缓存，只要对应Cursor上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader可以直接把缓存的数据回调到<code>onLoadFinished()</code>，从而避免重新查询数据。另外系统会在Loader不再需要使用到的时候(例如使用Back按钮退出当前页面)回调<code>onLoaderReset()</code>方法，我们可以在这里做数据的清除等等操作。</p>

<p>在Activity或者Fragment中使用Loader可以方便的实现异步加载的框架，Loader有诸多优点。但是实现Loader的这套代码还是稍微有点点复杂，Android官方为我们提供了使用Loader的<a href="http://developer.android.com/intl/zh-cn/reference/android/content/AsyncTaskLoader.html">示例代码</a>进行参考学习。</p>

<h2>9）The Importance of Thread Priority</h2>

<p>理论上来说，我们的程序可以创建出非常多的子线程一起并发执行的，可是基于CPU时间片轮转调度的机制，不可能所有的线程都可以同时被调度执行，CPU需要根据线程的优先级赋予不同的时间片。</p>

<p><img src="/images/android_perf_5_threadpriority_CPU.png" alt="android_perf_5_threadpriority_CPU" /></p>

<p>Android系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为forground的那部分线程会大致占用掉CPU的90%左右的时间片，background的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为forground的程序本身的优先级就更高，理应得到更多的执行时间。</p>

<p><img src="/images/android_perf_5_threadpriority_90.png" alt="android_perf_5_threadpriority_90" /></p>

<p>默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主UI线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占CPU资源，需要把这些线程的优先级进行降低处理，这样才能给帮组CPU识别主次，提高主线程所能得到的系统资源。</p>

<p><img src="/images/android_perf_5_threadpriority_less.png" alt="android_perf_5_threadpriority_less" /></p>

<p>在Android系统里面，我们可以通过<code>android.os.Process.setThreadPriority(int)</code>设置线程的优先级，参数范围从-20到24，数值越小优先级越高。Android系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。</p>

<p><img src="/images/android_perf_5_threadpriority_const.png" alt="android_perf_5_threadpriority_const" /></p>

<p>大多数情况下，新创建的线程优先级会被设置为默认的0，主线程设置为0的时候，新创建的线程还可以利用<code>THREAD_PRIORITY_LESS_FAVORABLE</code>或者<code>THREAD_PRIORITY_MORE_FAVORABLE</code>来控制线程的优先级。</p>

<p><img src="/images/android_perf_5_threadpriority_value.png" alt="android_perf_5_threadpriority_value" /></p>

<p>Android系统里面的AsyncTask与IntentService已经默认帮助我们设置线程的优先级，但是对于那些非官方提供的多线程工具类，我们需要特别留意根据需要自己手动来设置线程的优先级。</p>

<p><img src="/images/android_perf_5_threadpriority_asynctask.png" alt="android_perf_5_threadpriority_asynctask" />
<img src="/images/android_perf_5_threadpriority_intentservice.png" alt="android_perf_5_threadpriority_intentservice" /></p>

<h2>10）Profile GPU Rendering : M Update</h2>

<p>从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process，Execute，Update三大步骤的时间耗费情况。</p>

<p><img src="/images/android_perf_5_gpu_profiling_old.png" alt="android_perf_5_gpu_profiling_old" /></p>

<p>但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在Android M版本开始，GPU Profiling工具把渲染操作拆解成如下8个详细的步骤进行显示。</p>

<p><img src="/images/android_perf_5_gpu_profiling_8steps.png" alt="android_perf_5_gpu_profiling_8steps" /></p>

<p>旧版本中提到的Proces，Execute，Update还是继续得到了保留，他们的对应关系如下：</p>

<p><img src="/images/android_perf_5_gpu_profiling_3steps.png" alt="android_perf_5_gpu_profiling_3steps" /></p>

<p>接下去我们看下其他五个步骤分别代表了什么含义：</p>

<ul>
<li><strong>Sync &amp; Upload</strong>：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</li>
<li><strong>Measure &amp; Layout</strong>：这里表示的是布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</li>
<li><strong>Animation</strong>：表示的是计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</li>
<li><strong>Input Handling</strong>：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</li>
<li><strong>Misc/Vsync Delay</strong>：如果稍加注意，我们可以在开发应用的Log日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况。</li>
</ul>


<!-- ![android_perf_5_gpu_profiling_sync_upload](/images/android_perf_5_gpu_profiling_sync_upload.png) -->


<!-- ![android_perf_5_gpu_profiling_vsync](/images/android_perf_5_gpu_profiling_vsync.png)
 -->


<!-- ![android_perf_5_gpu_profiling_measure](/images/android_perf_5_gpu_profiling_measure.png) -->


<p>上面八种不同的颜色区分了不同的操作所耗费的时间，为了便于我们迅速找出那些有问题的步骤，GPU Profiling工具会显示16ms的阈值线，这样就很容易找出那些不合理的性能问题，再仔细看对应具体哪个步骤相对来说耗费时间比例更大，结合上面介绍的细化步骤，从而快速定位问题，修复问题。</p>

<hr />

<p>首发于CSDN：<a href="http://ms.csdn.net/geek/71031">Android性能优化典范（五）</a></p>
]]></content>
  </entry>
  
</feed>
