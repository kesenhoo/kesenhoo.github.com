<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android:Performance | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android-performance/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2018-07-19T00:22:17+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[HuKai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第6季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-6/"/>
    <updated>2016-10-04T23:12:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-6</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_common.png" alt="android_perf_patterns_season_common" /></p>

<blockquote><p>这里是<a href="https://www.youtube.com/watch?v=Vw1G1s73DsY&amp;index=74&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第6季的课程学习笔记，从被@知会到有连载更新，这篇学习笔记就一直被惦记着，现在学习记录分享一下，请多多指教包涵！这次一共才6个小段落，涉及的内容主要有：程序启动时间性能优化的三个方面：优化activity的创建过程，优化application对象的启动过程，正确使用启动显屏达到优化程序启动性能的目的。另外还介绍了减少安装包大小的checklist以及如何使用VectorDrawable来减少安装包的大小。</p></blockquote>

<h2>1）App Launch time 101</h2>

<p>提高程序的启动速度意义重大，很显然，启动时间越短，用户才越有耐心等待打开这个APP进行使用，反之启动时间越长，用户则越有可能来不及等到APP打开就已经切换到其他APP了。程序启动过程中的那些复杂错误的操作很可能导致严重的性能问题。Android系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他APP界面切换回来）。那么关键的问题是，用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他APP了。更严重的是，如果启动时间过长，可能导致程序出现ANR。我们应该避免出现这两种糟糕的情况。</p>

<p>从技术角度来说，当用户点击桌面图标开始，系统会立即为这个APP创建独立的专属进程，然后显示启动窗口，直到APP在自己的进程里面完成了程序的创建以及主线程完成了Activity的初始化显示操作，再然后系统进程就会把启动窗口替换成APP的显示窗口。</p>

<p><img src="/images/android_perf_6_launch_time_start_process.png" alt="android_perf_6_launch_time_start_process" /></p>

<!-- More -->


<p>上述流程里面的绝大多数步骤都是由系统控制的，一般来说不会出现什么问题，可是对于启动速度，我们能够控制并且需要特别关注的地方主要有三处：</p>

<ul>
<li>1）Activity的onCreate流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题。</li>
<li>2）Application的onCreate流程，对于大型的APP来说，通常会在这里做大量的通用组件的初始化操作。</li>
<li>3）目前有部分APP会提供自定义的启动窗口，这里可以做成品牌宣传界面或者是给用户提供一种程序已经启动的视觉效果。</li>
</ul>


<p>在正式着手解决问题之前，我们需要掌握一套正确测量评估启动性能的方法。所幸的是，Android系统有提供一些工具来帮助我们定位问题。</p>

<ul>
<li>1）首先是<strong>display time</strong>：从Android KitKat版本开始，Logcat中会输出从程序启动到某个Activity显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_display_time.png" alt="android_perf_6_launch_time_display_time" /></p>

<ul>
<li>2）其次是<strong>reportFullyDrawn</strong>方法：我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用<code>activity.reportFullyDrawn()</code>方法来告诉系统此时的状态，以便获取整个加载的耗时。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_report_fully_drawn.png" alt="android_perf_6_launch_time_report_fully_drawn" /></p>

<ul>
<li>3）然后是<strong>Method Tracing</strong>：前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用Method Tracing工具来进行详细的测量。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_method_tracing.png" alt="android_perf_6_launch_time_method_tracing" /></p>

<ul>
<li>4）最后是<strong>Systrace</strong>：我们可以在onCreate方法里面添加trace.beginSection()与trace.endSection()方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_systrace.png" alt="android_perf_6_launch_time_systrace" /></p>

<h2>2）App Launch Time &amp; Activity Creation</h2>

<p>提升Activity的创建速度是优化APP启动速度的首要关注目标。从桌面点击APP图标启动应用开始，程序会显示一个启动窗口等待Activity的创建加载完毕再进行显示。在Activity的创建加载过程中，会执行很多的操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写Preference等等。</p>

<p><img src="/images/android_perf_6_activity_creation_0.png" alt="android_perf_6_activity_creation_0" /></p>

<p>上述操作的任何一个环节出现性能问题都可能导致画面不能及时显示，影响了程序的启动速度。上一个段落我们介绍了使用Method Tracing来发现那些耗时占比相对较多的方法。假设我们发现某个方法执行时间过长，接下去就可以使用Systrace来帮忙定位到底是什么原因导致那个方法执行时间过长。</p>

<p>除了使用工具进行具体定位分析性能问题之外，以下两点经验可以帮助我们对Activity启动做性能优化：</p>

<ul>
<li>1）优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！</li>
<li>2）异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。</li>
</ul>


<h2>3）App Launch Time &amp; Bloated Application Objects</h2>

<p>在Application初始化的地方做太多繁重的事情是可能导致严重启动性能问题的元凶之一。Application里面的初始化操作不结束，其他任意的程序操作都无法进行。</p>

<p><img src="/images/android_perf_6_application_objs.png" alt="android_perf_6_application_objs" /></p>

<p>有时候，我们会一股脑的把绝大多数全局组件的初始化操作都放在Application的onCreate里面，但其实很多组件是需要做区队对待的，有些可以做延迟加载，有些可以放到其他的地方做初始化操作，特别需要留意包含Disk IO操作，网络访问等严重耗时的任务，他们会严重阻塞程序的启动。</p>

<p><img src="/images/android_perf_6_application_create.png" alt="android_perf_6_application_create" /></p>

<p>优化这些问题的解决方案是做延迟加载，可以在application里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。</p>

<p><img src="/images/android_perf_6_application_lazyload.png" alt="android_perf_6_application_lazyload" /></p>

<h2>4）App Launch Time &amp; Theme Launch Screens</h2>

<p>启动闪屏不仅仅可以作为品牌宣传页，还能够减轻用户对启动耗时的感知，但是如果使用不恰当，将适得其反。前面介绍过当点击桌面图标启动APP的时候，程序会显示一个启动窗口，一直到页面的渲染加载完毕。如果程序的启动速度足够快，我们看的闪屏窗口停留显示的时间则会很短，但是当程序启动速度偏慢的时候，这个启动闪屏可以一定程度上减轻用户等待的焦虑感，避免用户过于轻易的关闭应用。</p>

<p>目前大多数开发者都会通过设置启动窗口主题的方式来替换系统默认的启动窗口，通过这种方式只是使用『障眼法』弱化了用户对启动时间的感知，但本质上并没有对启动速度做什么优化。也有些APP通过关闭启动窗口属性<code>android:windowDisablePreview</code>的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，这样的用户体验是十分糟糕的！</p>

<p><img src="/images/android_perf_6_launch_screen.png" alt="android_perf_6_launch_screen" />
<img src="/images/android_perf_6_launch_screen2.png" alt="android_perf_6_launch_screen2" /></p>

<p>对于启动闪屏，正确的使用方法是自定义一张图片，把这张图片通过设置主题的方式显示为启动闪屏，代码执行到主页面的onCreate的时候设置为程序正常的主题。</p>

<p><img src="/images/android_perf_6_launch_screen3.png" alt="android_perf_6_launch_screen3" />
<img src="/images/android_perf_6_launch_screen4.png" alt="android_perf_6_launch_screen4" /></p>

<h2>5）Smaller APKs: A Checklist</h2>

<p>减少应用程序安装包的大小，不仅仅减少了用户的网络数据流量还减少了下载等待的时间。毋庸置疑，尽量减少程序安装包的大小是十分有必要的。通常来说，减少程序安装包的大小有两条规律：要么减少程序资源的大小，要么就是减少程序的代码量。这里总结一个简易版的减少安装包大小的Checklist:</p>

<h3>减少程序图片资源的大小</h3>

<ul>
<li>1）确保在build.gradle文件中开启了<code>minifEnabled</code>与<code>shrinkResources</code>的属性，这两个属性可以帮助移除那些在程序中使用不到的代码与资源，帮助减少APP的安装包大小。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_gradle.png" alt="android_perf_6_smaller_apks_gradle" /></p>

<ul>
<li>2）有选择性的提供对应分辨率的图片资源，系统会自动匹配最合适分辨率的图片并执行拉伸或者压缩的处理。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_dpi.png" alt="android_perf_6_smaller_apks_dpi" /></p>

<ul>
<li>3）在符合条件的情况下，使用Vertor Drawable替代传统的PNG/JPEG图片，能够极大的减少图片资源的大小。传统模式下，针对不同dpi的手机都需要提供一套PNG/JPEG的图片，而如果使用Vector Drawable的话，只需要一个XML文件即可。</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_vector.png" alt="android_perf_6_smaller_apks_vector" /></p>

<ul>
<li>4）尽量复用已经存在的资源图片，使用代码的方式对已有的资源进行复用，如下图所示：</li>
</ul>


<p><img src="/images/android_perf_6_smaller_apks_reuse.png" alt="android_perf_6_smaller_apks_reuse" /></p>

<p>以上几点虽然看起来都微不足道，但是真正执行之后，能够显著减少安装包的资源图片大小。</p>

<h3>减少程序的代码量</h3>

<ul>
<li><p>1）开启MinifEnabled，Proguard。打开这些编译属性之后，程序在打包的时候就不会把没有引用到的代码编译进来，以此达到减少安装包大小的目的。</p></li>
<li><p>2）注意因为编译行为额外产生的方法数，例如类似Enum，Protocal Buffer可能导致方法数与类的个数增加。</p></li>
<li><p>3）部分引入到工程中的jar类库可能并不是专门针对移动端APP而设计的，他们最开始可能是运用在PC或者Server上的。使用这些类库不仅仅额外增加了包的大小，还增加了编译时间。单纯依靠Proguard可能无法完全移除那些使用不到的方法，最佳的方式是使用一些更加轻量化，专门为Android APP设计的jar类库。</p></li>
</ul>


<h3>安装包的拆分</h3>

<p>设想一下，一个low dpi，API&lt;14的用户手机下载安装的APK里面却包含了大量xxhdpi的资源文件，对于这个用户来说，这个APK是存在很大的资源浪费的。幸好Android平台为我们提供了拆分APK的方法，它能够根据API Level，屏幕大小以及GPU版本的不同进行拆分，使得对应平台的用户下载到最合适自己手机的安装包。</p>

<p><img src="/images/android_perf_6_smaller_apks_split.png" alt="android_perf_6_smaller_apks_split" /></p>

<p>更多关于安装包拆分的信息，请查看<a href="https://developer.android.com/studio/build/configure-apk-splits.html">Configure APK Splits</a>与<a href="https://developer.android.com/training/multiple-apks/index.html">Maintaining Multiple APKs</a>(由于国内应用分发市场的现状，这一条几乎没有办法执行)。</p>

<h2>6）VectorDrawable for smaller APKs</h2>

<p>针对不同的分辨率提供多张精度的图片会额外增加APK的大小，针对这个问题的解决方案是考虑使用VectorDrawable，它仅仅只需要一个文件，能够动态生成对应分辨率的图片。</p>

<p><a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html">VectorDrawable</a>通过XML文件描述图片的形状，大小，样式。</p>

<p><img src="/images/android_perf_6_vectordrawable_origin.png" alt="android_perf_6_vectordrawable_origin" /></p>

<p>通过这种方式，我们可以显著减少图片资源对安装包大小的影响。</p>

<p><img src="/images/android_perf_6_vectordrawable_dpi.png" alt="android_perf_6_vectordrawable_dpi" />
<img src="/images/android_perf_6_vectordrawable_dpi2.png" alt="android_perf_6_vectordrawable_dpi2" /></p>

<p>使用VectorDrawable还可以避免因为使用帧动画导致的图片资源过多的情况，如下图所示</p>

<p><img src="/images/android_perf_6_vectordrawable_animation.png" alt="android_perf_6_vectordrawable_animation" /></p>

<p>前面介绍了VectorDrawable(VD)的优势，但是在使用VectorDrawable的时候，还是有以下的问题需要特别注意的？</p>

<ul>
<li>首先VD的加载有异于JPEG/PNG文件，图片文件可以依靠硬件进行纹理的渲染，而VD文件需要先进行加载解析，然后才能够进行纹理的渲染。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_load.png" alt="android_perf_6_vectordrawable_load" /></p>

<ul>
<li>其次VD文件适用于简单有规则的图片渲染，不适用于那些纹理过于复杂的图片，这样不仅仅会过度增加描述文件的复杂度还可能无法获取到想要的渲染效果。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_simple.png" alt="android_perf_6_vectordrawable_simple" /></p>

<ul>
<li>最后VD文件中关于Path的描述需要尽量简化，复杂冗余的Path信息不仅对得到想要的图片没有益处，还增加了加载渲染的难度。</li>
</ul>


<p><img src="/images/android_perf_6_vectordrawable_path.png" alt="android_perf_6_vectordrawable_path" /></p>

<hr />

<p>首发于CSDN：<a href="http://geek.csdn.net/news/detail/106513">Android性能优化典范（六）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第5季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-5/"/>
    <updated>2016-04-28T00:08:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-5</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_5.png" alt="android_perf_patterns_season_5" /></p>

<blockquote><p>这是<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第5季的课程学习笔记，拖拖拉拉很久，记录分享给大家，请多多包涵担待指正！文章共10个段落，涉及的内容有：多线程并发的性能问题，介绍了AsyncTask，HandlerThread，IntentService与ThreadPool分别适合的使用场景以及各自的使用注意事项，这是一篇了解Android多线程编程不可多得的基础文章，清楚的了解这些Android系统提供的多线程基础组件之间的差异以及优缺点，才能够在项目实战中做出最恰当的选择。</p></blockquote>

<h2>1)Threading Performance</h2>

<p>在程序开发的实践当中，为了让程序表现得更加流畅，我们肯定会需要使用到多线程来提升程序的并发执行性能。但是编写多线程并发的代码一直以来都是一个相对棘手的问题，所以想要获得更佳的程序性能，我们非常有必要掌握多线程并发编程的基础技能。</p>

<p>众所周知，Android程序的大多数代码操作都必须执行在主线程，例如系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程。</p>

<p><img src="/images/android_perf_5_threading_main_thread.png" alt="android_perf_5_threading_main_thread" /></p>

<!-- More -->


<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的UI绘制等等。我们知道，为了让屏幕的刷新帧率达到60fps，我们需要确保16ms内完成单次刷新的操作。一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了(一旦刷新帧率降到20fps左右，用户就可以明显感知到卡顿不流畅了)。</p>

<p><img src="/images/android_perf_5_threading_dropframe.png" alt="android_perf_5_threading_dropframe" /></p>

<p>为了避免上面提到的掉帧问题，我们需要使用多线程的技术方案，把那些操作复杂的任务移动到其他线程当中执行，这样就不容易阻塞主线程的操作，也就减小了出现掉帧的可能性。</p>

<p><img src="/images/android_perf_5_threading_workthread.png" alt="android_perf_5_threading_workthread" /></p>

<p>那么问题来了，为主线程减轻负的多线程方案有哪些呢？这些方案分别适合在什么场景下使用？Android系统为我们提供了若干组工具类来帮助解决这个问题。</p>

<ul>
<li><strong>AsyncTask</strong>: 为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li><strong>HandlerThread</strong>: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li><strong>ThreadPool</strong>: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li><strong>IntentService</strong>: 适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。</li>
</ul>


<p>了解这些系统提供的多线程工具类分别适合在什么场景下，可以帮助我们选择合适的解决方案，避免出现不可预期的麻烦。虽然使用多线程可以提高程序的并发量，但是我们需要特别注意因为引入多线程而可能伴随而来的内存问题。举个例子，在Activity内部定义的一个AsyncTask，它属于一个内部类，该类本身和外面的Activity是有引用关系的，如果Activity要销毁的时候，AsyncTask还仍然在运行，这会导致Activity没有办法完全释放，从而引发内存泄漏。所以说，多线程是提升程序性能的有效手段之一，但是使用多线程却需要十分谨慎小心，如果不了解背后的执行机制以及使用的注意事项，很可能引起严重的问题。</p>

<h2>2)Understanding Android Threading</h2>

<p>通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。</p>

<p><img src="/images/android_perf_5_thread_lifecycle.png" alt="android_perf_5_thread_lifecycle" /></p>

<p>在很多时候，线程不仅仅是线性执行一系列的任务就结束那么简单的，我们会需要增加一个任务队列，让线程不断的从任务队列中获取任务去进行执行，另外我们还可能在线程执行的任务过程中与其他的线程进行协作。如果这些细节都交给我们自己来处理，这将会是件极其繁琐又容易出错的事情。</p>

<p><img src="/images/android_perf_5_thread_thread.png" alt="android_perf_5_thread_thread" /></p>

<p>所幸的是，Android系统为我们提供了Looper，Handler，MessageQueue来帮助实现上面的线程任务模型：</p>

<p><strong>Looper</strong>: 能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。</p>

<p><img src="/images/android_perf_5_thread_looper.png" alt="android_perf_5_thread_looper" /></p>

<p><strong>Handler</strong>: 能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。</p>

<p><img src="/images/android_perf_5_thread_handler.png" alt="android_perf_5_thread_handler" /></p>

<p><strong>MessageQueue</strong>: 使用Intent，Message，Runnable作为任务的载体在不同的线程之间进行传递。</p>

<p><img src="/images/android_perf_5_thread_messagequeue.png" alt="android_perf_5_thread_messagequeue" /></p>

<p>把上面三个组件打包到一起进行协作，这就是<strong>HandlerThread</strong></p>

<p><img src="/images/android_perf_5_thread_handlerthread.png" alt="android_perf_5_thread_handlerthread" /></p>

<p>我们知道，当程序被启动，系统会帮忙创建进程以及相应的主线程，而这个主线程其实就是一个HandlerThread。这个主线程会需要处理系统事件，输入事件，系统回调的任务，UI绘制等等任务，为了避免主线程任务过重，我们就会需要不断的开启新的工作线程来处理那些子任务。</p>

<h2>3)Memory &amp; Threading</h2>

<p>增加并发的线程数会导致内存消耗的增加，平衡好这两者的关系是非常重要的。我们知道，多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a>等等。为了解决这些问题，我们会需要引入<strong>锁</strong>的概念。</p>

<p>在Android系统中也无法避免因为多线程的引入而导致出现诸如上文提到的种种问题。Android UI对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>

<p> <img src="/images/android_perf_5_memory_thread_update.png" alt="android_perf_5_memory_thread_update" /></p>

<p>另外，在非UI线程中直接持有UI对象的引用也很可能出现问题。例如Work线程中持有某个UI对象的引用，在Work线程执行完毕之前，UI对象在主线程中被从ViewHierarchy中移除了，这个时候UI对象的任何属性都已经不再可用了，另外对这个UI对象的更新操作也都没有任何意义了，因为它已经从ViewHierarchy中被移除，不再绘制到画面上了。</p>

<p><img src="/images/android_perf_5_memory_view_remove.png" alt="android_perf_5_memory_view_remove" /></p>

<p>不仅如此，View对象本身对所属的Activity是有引用关系的，如果工作线程持续保有View的引用，这就可能导致Activity无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。例如通常我们会看到在Activity里面定义的一个AsyncTask，这种类型的AsyncTask与外部的Activity是存在隐式引用关系的，只要Task没有结束，引用关系就会一直存在，这很容易导致Activity的泄漏。更糟糕的情况是，它不仅仅发生了内存泄漏，还可能导致程序异常或者崩溃。</p>

<p><img src="/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>为了解决上面的问题，我们需要谨记的原则就是：不要在任何非UI线程里面去持有UI对象的引用。系统为了确保所有的UI对象都只会被UI线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当Activity被销毁的时候，由该Activity所触发的非UI线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止UI对象被错误的使用。</p>

<h2>4)Good AsyncTask Hunting</h2>

<p>AsyncTask是一个让人既爱又恨的组件，它提供了一种简便的异步处理机制，但是它又同时引入了一些令人厌恶的麻烦。一旦对AsyncTask使用不当，很可能对程序的性能带来负面影响，同时还可能导致内存泄露。</p>

<p>举个例子，常遇到的一个典型的使用场景：用户切换到某个界面，触发了界面上的图片的加载操作，因为图片的加载相对来说耗时比较长，我们需要在子线程中处理图片的加载，当图片在子线程中处理完成之后，再把处理好的图片返回给主线程，交给UI更新到画面上。</p>

<p><img src="/images/android_perf_5_asynctask_main.png" alt="android_perf_5_asynctask_main" /></p>

<p>AsyncTask的出现就是为了快速的实现上面的使用场景，AsyncTask把在主线程里面的准备工作放到<code>onPreExecute()</code>方法里面进行执行，<code>doInBackground()</code>方法执行在工作线程中，用来处理那些繁重的任务，一旦任务执行完毕，就会调用<code>onPostExecute()</code>方法返回到主线程。</p>

<p><img src="/images/android_perf_5_asynctask_mode.png" alt="android_perf_5_asynctask_mode" /></p>

<p>使用AsyncTask需要注意的问题有哪些呢？请关注以下几点：</p>

<ul>
<li>首先，默认情况下，所有的AsyncTask任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个AsyncTask，一旦其中的某个AsyncTask执行时间过长，队列中的其他剩余AsyncTask都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。情况如下图所示：</li>
</ul>


<p><img src="/images/android_perf_5_asynctask_single_queue.png" alt="android_perf_5_asynctask_single_queue" /></p>

<p>为了解决上面提到的线性队列等待的问题，我们可以使用<code>AsyncTask.executeOnExecutor()</code>强制指定AsyncTask使用线程池并发调度任务。</p>

<p><img src="/images/android_perf_5_asynctask_thread_pool.png" alt="android_perf_5_asynctask_thread_pool" /></p>

<ul>
<li>其次，如何才能够真正的取消一个AsyncTask的执行呢？我们知道AsyncTaks有提供<code>cancel()</code>的方法，但是这个方法实际上做了什么事情呢？线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在<code>doInBackground()</code>的代码中不断的添加程序是否被中止的判断逻辑，如下图所示：</li>
</ul>


<p><img src="/images/android_perf_5_asynctask_cancel.png" alt="android_perf_5_asynctask_cancel" /></p>

<p>一旦任务被成功中止，AsyncTask就不会继续调用<code>onPostExecute()</code>，而是通过调用<code>onCancelled()</code>的回调方法反馈任务执行取消的结果。我们可以根据任务回调到哪个方法（是onPostExecute还是onCancelled）来决定是对UI进行正常的更新还是把对应的任务所占用的内存进行销毁等。</p>

<ul>
<li>最后，使用AsyncTask很容易导致内存泄漏，一旦把AsyncTask写成Activity的内部类的形式就很容易因为AsyncTask生命周期的不确定而导致Activity发生泄漏。</li>
</ul>


<p><img src="/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>综上所述，AsyncTask虽然提供了一种简单便捷的异步机制，但是我们还是很有必要特别关注到他的缺点，避免出现因为使用错误而导致的严重系统性能问题。</p>

<h2>5）Getting a HandlerThread</h2>

<p>大多数情况下，AsyncTask都能够满足多线程并发的场景需要（在工作线程执行任务并返回结果到主线程），但是它并不是万能的。例如打开相机之后的预览帧数据是通过<code>onPreviewFrame()</code>的方法进行回调的，<code>onPreviewFrame()</code>和<code>open()</code>相机的方法是执行在同一个线程的。</p>

<p><img src="/images/android_perf_5_handlerthread_camera_open.png" alt="android_perf_5_handlerthread_camera_open" /></p>

<p>如果这个回调方法执行在UI线程，那么在onPreviewFrame()里面将要执行的数据转换操作将和主线程的界面绘制，事件传递等操作争抢系统资源，这就有可能影响到主界面的表现性能。</p>

<p><img src="/images/android_perf_5_handlerthread_main_thread2.png" alt="android_perf_5_handlerthread_main_thread2" /></p>

<p>我们需要确保onPreviewFrame()执行在工作线程。如果使用AsyncTask，会因为AsyncTask默认的线性执行的特性(即使换成并发执行)会导致因为无法把任务及时传递给工作线程而导致任务在主线程中被延迟，直到工作线程空闲，才可以把任务切换到工作线程中进行执行。</p>

<p><img src="/images/android_perf_5_handlerthread_asynctask.png" alt="android_perf_5_handlerthread_asynctask" /></p>

<p>所以我们需要的是一个执行在工作线程，同时又能够处理队列中的复杂任务的功能，而HandlerThread的出现就是为了实现这个功能的，它组合了Handler，MessageQueue，Looper实现了一个长时间运行的线程，不断的从队列中获取任务进行执行的功能。</p>

<p><img src="/images/android_perf_5_handlerthread_outline.png" alt="android_perf_5_handlerthread_outline" /></p>

<p>回到刚才的处理相机回调数据的例子，使用HandlerThread我们可以把open()操作与onPreviewFrame()的操作执行在同一个线程，同时还避免了AsyncTask的弊端。如果需要在onPreviewFrame()里面更新UI，只需要调用runOnUiThread()方法把任务回调给主线程就够了。</p>

<p><img src="/images/android_perf_5_handlerthread_camera.png" alt="android_perf_5_handlerthread_camera" /></p>

<p>HandlerThread比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。</p>

<p>另外很重要的一点是，一旦我们使用了HandlerThread，需要特别注意给HandlerThread设置不同的线程优先级，CPU会根据设置的不同线程优先级对所有的线程进行调度优化。</p>

<p><img src="/images/android_perf_5_handlerthread_priority.png" alt="android_perf_5_handlerthread_priority" /></p>

<p>掌握HandlerThread与AsyncTask之间的优缺点，可以帮助我们选择合适的方案。</p>

<h2>6）Swimming in Threadpools</h2>

<p>线程池适合用在把任务进行分解，并发进行执行的场景。通常来说，系统里面会针对不同的任务设置一个单独的守护线程用来专门处理这项任务。例如使用Networking Thread用来专门处理网络请求的操作，使用IO Thread用来专门处理系统的I\O操作。针对那些场景，这样设计是没有问题的，因为对应的任务单次执行的时间并不长而且可以是顺序执行的。但是这种专属的单线程并不能满足所有的情况，例如我们需要一次性decode 40张图片，每个线程需要执行4ms的时间，如果我们使用专属单线程的方案，所有图片执行完毕会需要花费160ms(40*4)，但是如果我们创建10个线程，每个线程执行4个任务，那么我们就只需要16ms就能够把所有的图片处理完毕。</p>

<p><img src="/images/android_perf_5_threadpool_1.png" alt="android_perf_5_threadpool_1" /></p>

<p>为了能够实现上面的线程池模型，系统为我们提供了<code>ThreadPoolExecutor</code>帮助类来简化实现，剩下需要做的就只是对任务进行分解就好了。</p>

<p><img src="/images/android_perf_5_threadpool_2.png" alt="android_perf_5_threadpool_2" /></p>

<p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为CPU只能同时执行固定数量的线程数，一旦同时并发的线程数量超过CPU能够同时执行的阈值，CPU就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>

<p><img src="/images/android_perf_5_threadpool_3.png" alt="android_perf_5_threadpool_3" /></p>

<p>一旦同时并发的线程数量达到一定的量级，这个时候CPU在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少64K+的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>

<p><img src="/images/android_perf_5_threadpool_4.png" alt="android_perf_5_threadpool_4" /></p>

<p>另外需要关注的一个问题是：<code>Runtime.getRuntime().availableProcesser()</code>方法并不可靠，他返回的值并不是真实的CPU核心数，因为CPU会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的CPU核心数。</p>

<h2>7）The Zen of IntentService</h2>

<p>默认的Service是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的AsyncTask与HandlerThread，我们还可以选择使用IntentService来实现异步操作。IntentService继承自普通Service同时又在内部创建了一个HandlerThread，在<code>onHandlerIntent()</code>的回调里面处理扔到IntentService的任务。所以IntentService就不仅仅具备了异步线程的特性，还同时保留了Service不受主页面生命周期影响的特点。</p>

<p><img src="/images/android_perf_5_intentservice_outline.png" alt="android_perf_5_intentservice_outline" /></p>

<p>如此一来，我们可以在IntentService里面通过设置闹钟间隔性的触发异步任务，例如刷新数据，更新缓存的图片或者是分析用户操作行为等等，当然处理这些任务需要小心谨慎。</p>

<p>使用IntentService需要特别留意以下几点：</p>

<ul>
<li>首先，因为IntentService内置的是HandlerThread作为异步线程，所以每一个交给IntentService的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</li>
<li>其次，通常使用到IntentService的时候，我们会结合使用BroadcastReceiver把工作线程的任务执行结果返回给主UI线程。使用广播容易引起性能问题，我们可以使用LocalBroadcastManager来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用<code>runOnUiThread()</code>快速回调到主UI线程。</li>
<li>最后，包含正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>


<h2>8）Threading and Loaders</h2>

<p>当启动工作线程的Activity被销毁的时候，我们应该做点什么呢？为了方便的控制工作线程的启动与结束，Android为我们引入了Loader来解决这个问题。我们知道Activity有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在Activity不停的创建与销毁的过程当中，很有可能因为工作线程持有Activity的View而导致内存泄漏(因为工作线程很可能持有View的强引用，另外工作线程的生命周期还无法保证和Activity的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在Activity被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。</p>

<p><img src="/images/android_perf_5_loader_bad.png" alt="android_perf_5_loader_bad" /></p>

<p>Loader的出现就是为了确保工作线程能够和Activity的生命周期保持一致，同时避免出现前面提到的问题。</p>

<p><img src="/images/android_perf_5_loader_good.png" alt="android_perf_5_loader_good" /></p>

<p>LoaderManager会对查询的操作进行缓存，只要对应Cursor上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader可以直接把缓存的数据回调到<code>onLoadFinished()</code>，从而避免重新查询数据。另外系统会在Loader不再需要使用到的时候(例如使用Back按钮退出当前页面)回调<code>onLoaderReset()</code>方法，我们可以在这里做数据的清除等等操作。</p>

<p>在Activity或者Fragment中使用Loader可以方便的实现异步加载的框架，Loader有诸多优点。但是实现Loader的这套代码还是稍微有点点复杂，Android官方为我们提供了使用Loader的<a href="http://developer.android.com/intl/zh-cn/reference/android/content/AsyncTaskLoader.html">示例代码</a>进行参考学习。</p>

<h2>9）The Importance of Thread Priority</h2>

<p>理论上来说，我们的程序可以创建出非常多的子线程一起并发执行的，可是基于CPU时间片轮转调度的机制，不可能所有的线程都可以同时被调度执行，CPU需要根据线程的优先级赋予不同的时间片。</p>

<p><img src="/images/android_perf_5_threadpriority_CPU.png" alt="android_perf_5_threadpriority_CPU" /></p>

<p>Android系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为forground的那部分线程会大致占用掉CPU的90%左右的时间片，background的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为forground的程序本身的优先级就更高，理应得到更多的执行时间。</p>

<p><img src="/images/android_perf_5_threadpriority_90.png" alt="android_perf_5_threadpriority_90" /></p>

<p>默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主UI线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占CPU资源，需要把这些线程的优先级进行降低处理，这样才能给帮组CPU识别主次，提高主线程所能得到的系统资源。</p>

<p><img src="/images/android_perf_5_threadpriority_less.png" alt="android_perf_5_threadpriority_less" /></p>

<p>在Android系统里面，我们可以通过<code>android.os.Process.setThreadPriority(int)</code>设置线程的优先级，参数范围从-20到24，数值越小优先级越高。Android系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。</p>

<p><img src="/images/android_perf_5_threadpriority_const.png" alt="android_perf_5_threadpriority_const" /></p>

<p>大多数情况下，新创建的线程优先级会被设置为默认的0，主线程设置为0的时候，新创建的线程还可以利用<code>THREAD_PRIORITY_LESS_FAVORABLE</code>或者<code>THREAD_PRIORITY_MORE_FAVORABLE</code>来控制线程的优先级。</p>

<p><img src="/images/android_perf_5_threadpriority_value.png" alt="android_perf_5_threadpriority_value" /></p>

<p>Android系统里面的AsyncTask与IntentService已经默认帮助我们设置线程的优先级，但是对于那些非官方提供的多线程工具类，我们需要特别留意根据需要自己手动来设置线程的优先级。</p>

<p><img src="/images/android_perf_5_threadpriority_asynctask.png" alt="android_perf_5_threadpriority_asynctask" />
<img src="/images/android_perf_5_threadpriority_intentservice.png" alt="android_perf_5_threadpriority_intentservice" /></p>

<h2>10）Profile GPU Rendering : M Update</h2>

<p>从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process，Execute，Update三大步骤的时间耗费情况。</p>

<p><img src="/images/android_perf_5_gpu_profiling_old.png" alt="android_perf_5_gpu_profiling_old" /></p>

<p>但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在Android M版本开始，GPU Profiling工具把渲染操作拆解成如下8个详细的步骤进行显示。</p>

<p><img src="/images/android_perf_5_gpu_profiling_8steps.png" alt="android_perf_5_gpu_profiling_8steps" /></p>

<p>旧版本中提到的Proces，Execute，Update还是继续得到了保留，他们的对应关系如下：</p>

<p><img src="/images/android_perf_5_gpu_profiling_3steps.png" alt="android_perf_5_gpu_profiling_3steps" /></p>

<p>接下去我们看下其他五个步骤分别代表了什么含义：</p>

<ul>
<li><strong>Sync &amp; Upload</strong>：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</li>
<li><strong>Measure &amp; Layout</strong>：这里表示的是布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</li>
<li><strong>Animation</strong>：表示的是计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</li>
<li><strong>Input Handling</strong>：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</li>
<li><strong>Misc/Vsync Delay</strong>：如果稍加注意，我们可以在开发应用的Log日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况。</li>
</ul>


<!-- ![android_perf_5_gpu_profiling_sync_upload](/images/android_perf_5_gpu_profiling_sync_upload.png) -->


<!-- ![android_perf_5_gpu_profiling_vsync](/images/android_perf_5_gpu_profiling_vsync.png)
 -->


<!-- ![android_perf_5_gpu_profiling_measure](/images/android_perf_5_gpu_profiling_measure.png) -->


<p>上面八种不同的颜色区分了不同的操作所耗费的时间，为了便于我们迅速找出那些有问题的步骤，GPU Profiling工具会显示16ms的阈值线，这样就很容易找出那些不合理的性能问题，再仔细看对应具体哪个步骤相对来说耗费时间比例更大，结合上面介绍的细化步骤，从而快速定位问题，修复问题。</p>

<hr />

<p>首发于CSDN：<a href="http://ms.csdn.net/geek/71031">Android性能优化典范（五）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第4季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-4/"/>
    <updated>2015-12-31T23:39:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-4</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_4.png" alt="android_perf_patterns_season_4" /></p>

<blockquote><p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第4季的课程学习笔记终于在2015年的最后一天完成了，文章共17个段落，包含的内容大致有：优化网络请求的行为，优化安装包的资源文件，优化数据传输的效率，性能优化的几大基础原理等等。因为学习认知水平有限，肯定存在不少理解偏差甚至错误的地方，请多多交流指正！</p></blockquote>

<h2>1)Cachematters for networking</h2>

<p>想要使得Android系统上的网络访问操作更加的高效就必须做好网络数据的缓存。这是提高网络访问性能最基础的步骤之一。从手机的缓存中直接读取数据肯定比从网络上获取数据要更加的便捷高效，特别是对于那些会被频繁访问到的数据，需要把这些数据缓存到设备上，以便更加快速的进行访问。</p>

<p>Android系统上关于网络请求的Http Response Cache是默认关闭的，这样会导致每次即使请求的数据内容是一样的也会需要重复被调用执行，效率低下。我们可以通过下面的代码示例开启<a href="http://developer.android.com/reference/android/net/http/HttpResponseCache.html">HttpResponseCache</a>。</p>

<!-- More -->


<p><img src="/images/android_perf_4_network_cache_enable.png" alt="android_perf_4_network_cache_enable" /></p>

<p>开启Http Response Cache之后，Http操作相关的返回数据就会缓存到文件系统上，不仅仅是主程序自己编写的网络请求相关的数据会被缓存，另外引入的library库中的网络相关的请求数据也会被缓存到这个Cache中。</p>

<p>网络请求的场景有可以是普通的http请求，也可以打开某个URL去获取数据，如下图所示：</p>

<p><img src="/images/android_perf_4_network_cache_code.png" alt="android_perf_4_network_cache_code" /></p>

<p>我们有两种方式来清除<code>HttpResponseCache</code>的缓存数据：第一种方式是缓存溢出的时候删除最旧最老的文件，第二种方式是通过Http返回Header中的<code>Cache-Control</code>字段来进行控制的。如下图所示：</p>

<p><img src="/images/android_perf_4_network_cache_control.png" alt="android_perf_4_network_cache_control" /></p>

<p>通常来说，<code>HttpResponseCache</code>会缓存所有的返回信息，包括实际的数据与Header的部分.一般情况下，这个Cache会自动根据协议返回<code>Cache-Control</code>的内容与当前缓存的数据量来决定哪些数据应该继续保留，哪些数据应该删除。但是在一些极端的情况下，例如服务器返回的数据没有设置Cache废弃的时间，或者是本地的Cache文件系统与返回的缓存数据有冲突，或者是某些特殊的网络环境导致HttpResponseCache工作异常，在这些情况下就需要我们自己来实现Http的缓存Cache。</p>

<p>实现自定义的http缓存，需要解决两个问题：第一个是实现一个DiskCacheManager，另外一个是制定Cache的缓存策略。关于DiskCacheManager，我们可以扩展Android系统提供的<a href="https://developer.android.com/intl/zh-cn/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">DiskLruCache</a>来实现。而Cache的缓存策略，相对来说复杂一些，我们可能需要把部分JSON数据设计成不能缓存的，另外一些JSON数据设计成可以缓存几天的，把缩略图设计成缓存一两天的等等，为不同的数据类型根据他们的使用特点制定不同的缓存策略。</p>

<p><img src="/images/android_perf_4_network_cache_diff.png" alt="android_perf_4_network_cache_diff" /></p>

<p>想要比较好的实现这两件事情，如果全部自己从头开始写会比较繁琐复杂，所幸的是，有不少著名的开源框架帮助我们快速的解决了那些问题。我们可以使用<a href="https://developer.android.com/training/volley/index.html">Volly</a>，<a href="http://square.github.io/okhttp/">okHTTP</a>，<a href="http://square.github.io/picasso/">Picasso</a>来实现网络缓存。</p>

<p>实现好网络缓存之后，我们可以使用Android Studio里面的<code>Network Traffic Tools</code>来查看网络数据的请求与返回情况，另外我们还可以使用<a href="https://developer.att.com/application-resource-optimizer">AT&amp;T ARO</a>工具来抓取网络数据包进行分析查看。</p>

<h2>2)Optimizing Network Request Frequencies</h2>

<p>应用程序的一个基础功能是能够保持确保界面上呈现的信息是即时最新的，例如呈现最新的新闻，天气，信息流等等信息。但是，过于频繁的促使手机客户端应用去同步最新的服务器数据会对性能产生很大的负面影响，不仅仅使得CPU不停的在工作，内存，网络流量，电量等等都会持续的被消耗，所以在进行网络请求操作的时候一定要避免多度同步操作。</p>

<p>退到后台的应用为了能够在切换回前台的时候呈现最新的数据，会偷偷在后台不停的做同步的操作。这种行为会带来很严重的问题，首先因为网络请求的行为异常的耗电，其次不停的进行网络同步会耗费很多带宽流量。</p>

<p>为了能够尽量的减少不必要的同步操作，我们需要遵守下面的一些规则：</p>

<ul>
<li>首先我们要对网络行为进行分类，区分需要立即更新数据的行为和其他可以进行延迟的更新行为，为不同的场景进行差异化处理。</li>
<li>其次要避免客户端对服务器的轮询操作，这样会浪费很多的电量与带宽流量。解决这个问题，我们可以使用Google Cloud Message来对更新的数据进行推送。</li>
<li>然后在某些必须做同步的场景下，需要避免使用固定的间隔频率来进行更新操作，我们应该在返回的数据无更新的时候，使用双倍的间隔时间来进行下一次同步。</li>
<li>最后更进一步，我们还可以通过判断当前设备的状态来决定同步的频率，例如判断设备处于休眠，运动等不同的状态设计各自不同时间间隔的同步频率。</li>
</ul>


<p><img src="/images/android_perf_4_network_frequencies_backoff.png" alt="android_perf_4_network_frequencies_backoff" /></p>

<p>另外，我们还可以通过判断设备是否连接上WiFi，是否正在充电来决定更新的频率。为了能够方便的实现这个功能，Android为我们提供了<a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmNetworkManager">GCMNetworkManager</a>来判断设备当下的状态，从而设计更加高效的网络同步操作，如下图所示：</p>

<p><img src="/images/android_perf_4_network_frequencies_gcm.png" alt="android_perf_4_network_frequencies_gcm" /></p>

<h2>3)Effective Prefetching</h2>

<p>关于提升网络操作的性能，除了避免频繁的网络同步操作之外，还可以使用捆绑批量访问的方式来减少访问的频率，为了达到这个目的，我们就需要了解Prefetching。</p>

<p>举个例子，在某个场景下，一开始发出了网络请求得到了某张图片，隔了10s之后，发出第二次请求想要拿到另外一张图片，再隔了6s发出第三张图片的网络请求。这会导致设备的无线蜂窝一直处于高消耗的状态。Prefetching就是预先判定那些可能马上就会使用到的网络资源，捆绑一起集中进行网络请求。这样能够极大的减少电量的消耗，提升设备的续航时间。</p>

<p><img src="/images/android_perf_4_prefetching_bundle.png" alt="android_perf_4_prefetching_bundle" /></p>

<p>使用Prefetching的难点在于如何判断事先获取的数据量到底是多少，如果预取的数据量偏少，那么就起不到什么效果，但是如果预取过多，又可能导致访问的时间过长。</p>

<p><img src="/images/android_perf_4_prefetching_tricky.png" alt="android_perf_4_prefetching_tricky" /></p>

<p>那么问题来了，到底预取多少才比较合适呢？一个比较普适的规则是，在3G网络下可以预取1-5Mb的数据量，或者是按照提前预期后续1-2分钟的数据作为基线标准。在实际的操作当中，我们还需要考虑当前的网络速度来决定预取的数据量，例如在同样的时间下，4G网络可以获取到12张图片的数据，而2G网络则只能拿到3张图片的数据。所以，我们还需要把当前的网络环境情况添加到设计预取数据量的策略当中去。判断当前设备的状态与网络情况，可以使用前面提到过的<a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmNetworkManager">GCMNetworkManager</a>。</p>

<h2>4)Adapting to Latency</h2>

<p>网络延迟通常来说很容易被用户察觉到，严重的网络延迟会对用户体验造成很大的影响，用户很容易抱怨应用程序写的不好。</p>

<p>一个典型的网络操作行为，通常包含以下几个步骤：首先手机端发起网络请求，到达网络服务运营商的基站，再转移到服务提供者的服务器上，经过解码之后，接着访问本地的存储数据库，获取到数据之后，进行编码，最后按照原来传递的路径逐层返回。如下图所示：</p>

<p><img src="/images/android_perf_4_network_latency.png" alt="android_perf_4_network_latency" /></p>

<p>在上面的网络请求链路当中的任何一个环节都有可能导致严重的延迟，成为性能瓶颈，但是这些环节可能出现的问题，客户端应用是无法进行调节控制的，应用能够做的就只是根据当前的网络环境选择当下最佳的策略来降低出现网络延迟的概率。主要的实施步骤有两步：第1步检测收集当前的网络环境信息，第2步根据当前收集到的信息进行网络请求行为的调整。</p>

<p>关于第1步检测当前的网络环境，我们可以使用系统提供的API来获取到相关的信息，如下图所示：</p>

<p><img src="/images/android_perf_4_network_latency_detect.png" alt="android_perf_4_network_latency_detect" /></p>

<p>通过上面的示例，我们可以获取到移动网络的详细子类型，例如4G(LTE),3G等等，详细分类见下图，获取到详细的移动网络类型之后，我们可以根据当前网络的速率来调整网络请求的行为：</p>

<p><img src="/images/android_perf_4_network_latency_subtype.png" alt="android_perf_4_network_latency_subtype" /></p>

<p>关于第2步根据收集到的信息进行策略的调整，通常来说，我们可以把网络请求延迟划分为三档：例如把网络延迟小于60ms的划分为GOOD，大于220ms的划分为BAD，介于两者之间的划分为OK（这里的60ms，220ms会需要根据不同的场景提前进行预算推测）。如果网络延迟属于GOOD的范畴，我们就可以做更多比较激进的预取数据的操作，如果网络延迟属于BAD的范畴，我们就应该考虑把当下的网络请求操作Hold住等待网络状况恢复到GOOD的状态再进行处理。</p>

<p><img src="/images/android_perf_4_network_latency_three_category.png" alt="android_perf_4_network_latency_three_category" /></p>

<p>前面提到说60ms，220ms是需要提前自己预测的，可是预测的工作相当复杂。首先针对不同的机器与网络环境，网络延迟的三档阈值都不太一样，出现的概率也不尽相同，我们会需要针对这些不同的用户与设备选择不同的阈值进行差异化处理：</p>

<p><img src="/images/android_perf_4_network_latency_three_level.png" alt="android_perf_4_network_latency_three_level" /></p>

<p>Android官方为了帮助我们设计自己的网络请求策略，为我们提供了模拟器的网络流量控制功能来对实际环境进行模拟测量，或者还可以使用AT&amp;T提供的<a href="http://developer.att.com/developer/legalAgreementPage.jsp?passedItemId=14500040">AT&amp;T Network Attenuator</a>来帮助预估网络延迟。</p>

<h2>5)Minimizing Asset Payload</h2>

<p>为了能够减小网络传输的数据量，我们需要对传输的数据做压缩的处理，这样能够提高网络操作的性能。首先不同的网络环境，下载速度以及网络延迟是存在差异的，如下图所示：</p>

<p><img src="/images/android_perf_4_min_asset_load.png" alt="android_perf_4_min_asset_load" /></p>

<p>如果我们选择在网速更低的网络环境下进行数据传输，这就意味着需要执行更长的时间，而更长的网络操作行为，会导致电量消耗更加严重。另外传输的数据如果不做压缩处理，也同样会增加网络传输的时间，消耗更多的电量。不仅如此，未经过压缩的数据，也会消耗更多的流量，使得用户需要付出更多的流量费。</p>

<p>通常来说，网络传输数据量的大小主要由两部分组成：图片与序列化的数据，那么我们需要做的就是减少这两部分的数据传输大小，分下面两个方面来讨论。</p>

<ul>
<li>A)首先需要做的是减少图片的大小，选择合适的图片保存格式是第一步。下图展示了PNG,JPEG,WEBP三种主流格式在占用空间与图片质量之间的对比：</li>
</ul>


<p><img src="/images/android_perf_4_min_asset_png_jpeg_webp.png" alt="android_perf_4_min_asset_png_jpeg_webp" /></p>

<p>对于JPEG与WEBP格式的图片，不同的清晰度对占用空间的大小也会产生很大的影响，适当的减少JPG Quality，可以大大的缩小图片占用的空间大小。</p>

<p>另外，我们需要为不同的使用场景提供当前场景下最合适的图片大小，例如针对全屏显示的情况我们会需要一张清晰度比较高的图片，而如果只是显示为缩略图的形式，就只需要服务器提供一个相对清晰度低很多的图片即可。服务器应该支持到为不同的使用场景分别准备多套清晰度不一样的图片，以便在对应的场景下能够获取到最适合自己的图片。这虽然会增加服务端的工作量，可是这个付出却十分值得！</p>

<ul>
<li>B)其次需要做的是减少序列化数据的大小。JSON与XML为了提高可读性，在文件中加入了大量的符号，空格等等字符，而这些字符对于程序来说是没有任何意义的。我们应该使用Protocal Buffers，Nano-Proto-Buffers，FlatBuffer来减小序列化的数据的大小。</li>
</ul>


<p>Android系统为我们提供了工具来查看网络传输的数据情况，打开Android Studio的Monitor，里面有网络访问的模块。或者是打开AT&amp;T提供的<a href="https://developer.att.com/application-resource-optimizer">ARO</a>工具来查看网络请求状态。</p>

<h2>6)Service Performance Patterns</h2>

<p>Service是Android程序里面最常用的基础组件之一，但是使用Service很容易引起电量的过度消耗以及系统资源的未及时释放。学会在何时启用Service以及使用何种方式杀掉Service就显得十分有必要了。</p>

<p>简要过一下Service的特性：Service和UI没有关联，Service的创建，执行，销毁Service都是需要占用系统时间和内存的。另外Service是默认运行在UI线程的，这意味着Service可能会影响到系统的流畅度。</p>

<p>使用Service应该遵循下面的一些规则：</p>

<ul>
<li>避免错误的使用Service，例如我们不应该使用Service来监听某些事件的变化，不应该搞一个Service在后台对服务器不断的进行轮询(应该使用Google Cloud Messaging)</li>
<li>如果已经事先知道Service里面的任务应该执行在后台线程(非默认的主线程)的时候，我们应该使用IntentService或者结合HanderThread，AsycnTask Loader实现的Service。</li>
</ul>


<p>Android系统为我们提供了以下的一些异步相关的工具类</p>

<ul>
<li>GCM</li>
<li>BroadcastReciever</li>
<li>LocalBroadcastReciever</li>
<li>WakefulBroadcastReciver</li>
<li>HandlerThreads</li>
<li>AsyncTaskLoaders</li>
<li>IntentService</li>
</ul>


<p>如果使用上面的诸多方案还是无法替代普通的Service，那么需要注意的就是如何正确的关闭Service。</p>

<ul>
<li>普通的Started Service，需要通过stopSelf()来停止Service</li>
</ul>


<p><img src="/images/android_perf_4_service_started.png" alt="android_perf_4_service_started" /></p>

<ul>
<li>另外一种Bound Service，会在其他组件都unBind之后自动关闭自己</li>
</ul>


<p><img src="/images/android_perf_4_service_bound.png" alt="android_perf_4_service_bound" /></p>

<p>把上面两种Service进行合并之后，我们可以得到如下图所示的Service(相关知识，还可以参考<a href="http://hukai.me/android-notes-services/">http://hukai.me/android-notes-services/</a>, <a href="http://hukai.me/android-notes-bound-services/">http://hukai.me/android-notes-bound-services/</a>)</p>

<p><img src="/images/android_perf_4_service_mix.png" alt="android_perf_4_service_mix" /></p>

<h2>7)Removing unused code</h2>

<p>使用第三方库(library)可以在不用自己编写大量代码的前提下帮助我们解决一些难题，节约大量的时间，但是这些引入的第三方库很可能会导致主程序代码臃肿冗余。</p>

<p>如果我们处在人力，财力都相对匮乏的情况下，通常会倾向大量使用第三方库来帮助编写应用程序。这其实是无可厚非的，那些著名的第三方库的可行性早就被很多应用所采用并实践证明过。但是这里面存在的问题是，如果我们因为只需要某个library的一小部分功能而把整个library都导入自己的项目，这就会引起代码臃肿。一旦发生代码臃肿，用户就会下载到安装包偏大的应用程序，另外因为代码臃肿，还很有可能会超过单个编译文件只能有65536个方法的上限。解决这个问题的办法是使用<strong>MultiDex</strong>的方案，可是这实在是无奈之举，原则上，我们还是应该尽量避免出现这种情况。</p>

<p>Android为我们提供了Proguard的工具来帮助应用程序对代码进行瘦身，优化，混淆的处理。它会帮助移除那些没有使用到的代码，还可以对类名，方法名进行混淆处理以避免程序被反编译。举个例子，Google I/O 2015这个应用使用了大量的library，没有经过Proguard处理之前编译出来的包是8.4Mb大小，经过处理之后的包仅仅是4.1Mb大小。</p>

<p>使用Proguard相当的简单，只需要在build.gradle文件中配置minifEnable为true即可，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_code_proguard.png" alt="android_perf_4_remove_unused_code_proguard" /></p>

<p>但是Proguard还是不足够聪明到能够判断哪些类，哪些方法是不能够被混淆的，针对这些情况，我们需要手动的把这些需要保留的类名与方法名添加到Proguard的配置文件中，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_code_proguard_setting.png" alt="android_perf_4_remove_unused_code_proguard_setting" /></p>

<p>在使用library的时候，需要特别注意这些library在proguard配置上的说明文档，我们需要把这些配置信息添加到自己的主项目中。关于Proguard的详细说明，请看官方文档<a href="http://developer.android.com/tools/help/proguard.html">http://developer.android.com/tools/help/proguard.html</a></p>

<h2>8)Removing unused resources</h2>

<p>减少APK安装包的大小也是Android程序优化中很重要的一个方面，我们不应该给用户下载到一个臃肿的安装包。假设这样一个场景，我们引入了Google Play Service的library，是想要使用里面的Maps的功能，但是里面的登入等等其他功能是不需要的，可是这些功能相关的代码与图片资源，布局资源如果也被引入我们的项目，这样就会导致我们的程序安装包臃肿。</p>

<p>所幸的是，我们可以使用Gradle来帮助我们分析代码，分析引用的资源，对于那些没有被引用到的资源，会在编译阶段被排除在APK安装包之外，要实现这个功能，对我们来说仅仅只需要在build.gradle文件中配置shrinkResource为true就好了，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_resource.png" alt="android_perf_4_remove_unused_resource" /></p>

<p>为了辅助gradle对资源进行瘦身，或者是某些时候的特殊需要，我们可以通过tools:keep或者是tools:discard标签来实现对特定资源的保留与废弃，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_resource_tools.png" alt="android_perf_4_remove_unused_resource_tools" /></p>

<p>Gradle目前无法对values，drawable等根据运行时来决定使用的资源进行优化，对于这些资源，需要我们自己来确保资源不会有冗余。</p>

<h2>9)Perf Theory: Caching</h2>

<p>当我们讨论性能优化的时候，缓存是最常见最有效的策略之一。无论是为了提高CPU的计算速度还是提高数据的访问速度，在绝大多数的场景下，我们都会使用到缓存。关于缓存是如何提高效率的，这里就不赘述了。</p>

<p>那么在什么地方，在何时应该利用好缓存来提高效率呢？请看下面的例子，很明显的演示了在某些细节上是如何利用缓存的原理来提高代码的执行效率的：</p>

<p><img src="/images/android_perf_4_cache_1.png" alt="android_perf_4_cache_1" />
<img src="/images/android_perf_4_cache_2.png" alt="android_perf_4_cache_2" /></p>

<p>类似上面的例子采用缓存原理的地方还有很多，例如缓存到内存里面的图片资源，网络请求返回数据的缓存等等。总之，使用缓存就是为了减少不必要的操作，尽量复用已有的对象来提高效率。</p>

<h2>10)Perf Theory: Approximation(近似法)</h2>

<p>很多时候，我们都需要学会在性能更优与体验更好之间做一定的权衡取舍。为了获取更好的表现性能，我们可能会需要牺牲一些用户体验，例如把某些细节做删除或者是降级处理以便有更好的性能。例如，导航类的应用，如果在导航期间是不停的执行定位的操作，这样能够很及时的获取到最新的位置信息以及当下位置相关的其他提示信息，但是这样会导致网络流量以及手机电量的过度消耗。所以我们可以做一定的降级处理，每隔固定的一段时间才去获取一次位置信息，损失一点及时性来换取更长的续航时间。</p>

<p>还有很多地方都会用到近似法则来优化程序的性能，例如使用一张比较接近实际大小的图片来替代原图，换取更快的加载速度。所以对于那些对计算结果要求不需要十分精确的场景，我们可以使用近似法则来提高程序的性能。</p>

<h2>11)Perf Theory: Culling(遴选，挑选)</h2>

<p>在以前的性能优化课程里面，我们知道可以通过减少Overdraw来提高程序的渲染性能（主要手段有移除非必须的background，减少重叠的布局，使用clipRect来提高自定义View的绘制性能），今天在这里要介绍的另外一个提高性能的方法是逐步对数据进行过滤筛选，减小搜索的数据集，以此提高程序的执行性能。例如我们需要搜索到居住在某个地方，年龄是多少，符合某些特定条件的候选人，就可以通过逐层过滤筛选的方式来提高后续搜索的执行效率。</p>

<h2>12)Perf Theory: Threading</h2>

<p>使用多线程并发处理任务，从某种程度上可以快速提高程序的执行性能。对于Android程序来说，主线程通常也成为UI线程，需要处理UI的渲染，响应用户的操作等等。对于那些可能影响到UI线程的任务都需要特别留意是否有必要放到其他的线程来进行处理。如果处理不当，很有可能引起程序ANR。关于多线程的使用建议，可以参考官方的培训课程<a href="http://developer.android.com/training/best-background.html">http://developer.android.com/training/best-background.html</a></p>

<h2>13)Perf Theory: Batching</h2>

<p>关于Batching，在前几季的性能优化课程里面也不止一次提到，下面使用一张图演示下Batching的原理：</p>

<p><img src="/images/android_perf_4_batching.png" alt="android_perf_4_batching" /></p>

<p>网络请求的批量执行是另外一个比较适合说明batching使用场景的例子，因为每次发起网络请求都相对来说比较耗时耗电，如果能够做到批量一起执行，可以大大的减少电量的消耗。</p>

<p><img src="/images/android_perf_4_batching_network.png" alt="android_perf_4_batching_network" /></p>

<h2>14)Serialization performance</h2>

<p>数据的序列化是程序代码里面必不可少的组成部分，当我们讨论到数据序列化的性能的时候，需要了解有哪些候选的方案，他们各自的优缺点是什么。首先什么是序列化？用下面的图来解释一下：</p>

<p><img src="/images/android_perf_4_serialIzation.png" alt="android_perf_4_serialIzation" /></p>

<p>数据序列化的行为可能发生在数据传递过程中的任何阶段，例如网络传输，不同进程间数据传递，不同类之间的参数传递，把数据存储到磁盘上等等。通常情况下，我们会把那些需要序列化的类实现Serializable接口(如下图所示)，但是这种传统的做法效率不高，实施的过程会消耗更多的内存。</p>

<p><img src="/images/android_perf_4_serialIzation_implement.png" alt="android_perf_4_serialIzation_implement" /></p>

<p>但是我们如果使用GSON库来处理这个序列化的问题，不仅仅执行速度更快，内存的使用效率也更高。Android的XML布局文件会在编译的阶段被转换成更加复杂的格式，具备更加高效的执行性能与更高的内存使用效率。</p>

<p><img src="/images/android_perf_4_serialIzation_gson.png" alt="android_perf_4_serialIzation_gson" /></p>

<p>下面介绍三个数据序列化的候选方案：</p>

<ul>
<li><strong><a href="https://developers.google.com/protocol-buffers/?utm_campaign=android_series_serialization_performance_101315&amp;utm_source=anddev&amp;utm_medium=yt-annt">Protocal Buffers</a></strong>：强大，灵活，但是对内存的消耗会比较大，并不是移动终端上的最佳选择。</li>
<li><strong><a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt?utm_campaign=android_series_serialization_performance_101315&amp;utm_source=anddev&amp;utm_medium=yt-annt">Nano-Proto-Buffers</a></strong>：基于Protocal，为移动终端做了特殊的优化，代码执行效率更高，内存使用效率更佳。</li>
<li><strong><a href="https://google.github.io/flatbuffers/">FlatBuffers</a></strong>：这个开源库最开始是由Google研发的，专注于提供更优秀的性能。</li>
</ul>


<p>上面这些方案在性能方面的数据对比如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_filesize.png" alt="android_perf_4_serialIzation_filesize" />
<img src="/images/android_perf_4_serialIzation_encode.png" alt="android_perf_4_serialIzation_encode" /></p>

<p>为了避免序列化带来的性能问题，我们其实可以考虑使用SharedPreference或者SQLite来存储那些数据，避免需要先把那些复杂的数据进行序列化的操作。</p>

<h2>15)Smaller Serialized Data</h2>

<p>数据呈现的顺序以及结构会对序列化之后的空间产生不小的影响。通常来说，一般的数据序列化的过程如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json.png" alt="android_perf_4_serialIzation_java_2_json" /></p>

<p>上面的过程，存在两个弊端，第一个是重复的属性名称：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json_dup.png" alt="android_perf_4_serialIzation_java_2_json_dup" /></p>

<p>另外一个是GZIP没有办法对上面的数据进行更加有效的压缩，假如相似数据间隔了32k的数据量，这样GZIP就无法进行更加有效的压缩：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json_gzip.png" alt="android_perf_4_serialIzation_java_2_json_gzip" /></p>

<p>但是我们稍微改变下数据的记录方式，就可以得到占用空间更小的数据，如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json2.png" alt="android_perf_4_serialIzation_java_2_json2" /></p>

<p>通过优化，至少有三方面的性能提升，如下图所示：</p>

<p>1）减少了重复的属性名：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_1.png" alt="android_perf_4_serialIzation_opt_1" /></p>

<p>2）使得GZIP的压缩效率更高：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_2.png" alt="android_perf_4_serialIzation_opt_2" /></p>

<p>3）同样的数据类型可以批量优化：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_3.png" alt="android_perf_4_serialIzation_opt_3" /></p>

<h2>16)Caching UI data</h2>

<p>如今绝大多数的应用界面上呈现的数据都依赖于网络请求返回的结果，如何做到在网络数据返回之前避免呈现一个空白的等待页面呢（当然这里说的是非首次冷启动的情况）？这就会涉及到如何缓存UI界面上的数据。</p>

<p>缓存UI界面上的数据，可以采用方案有存储到文件系统，Preference，SQLite等等，做了缓存之后，这样就可以在请求数据返回结果之前，呈现给用户旧的数据，而不是使用正在加载的方式让用户什么数据都看不到，当然在请求网络最新数据的过程中，需要有正在刷新的提示。至于到底选择哪个方案来对数据进行缓存，就需要根据具体情况来做选择了。</p>

<h2>17)CPU Frequency Scaling</h2>

<p>调节CPU的频率会执行的性能产生较大的影响，为了最大化的延长设备的续航时间，系统会动态调整CPU的频率，频率越高执行代码的速度自然就越快。</p>

<p><img src="/images/android_perf_4_CPU.png" alt="android_perf_4_CPU" /></p>

<p>Android系统会在电量消耗与表现性能之间不断的做权衡，当有需要的时候会迅速调整CPU的频率到一个比较高负荷的状态，当程序不需要高性能的时候就会降低频率来确保更长的续航时间。</p>

<p><img src="/images/android_perf_4_CPU_adjust.png" alt="android_perf_4_CPU_adjust" /></p>

<p>Android系统检测到需要调整CPU的频率到CPU频率真的达到对应频率会需要花费大概20ms的时间，在此期间很有可能会因为CPU频率不够而导致代码执行偏慢。</p>

<p><img src="/images/android_perf_4_CPU_gap.png" alt="android_perf_4_CPU_gap" /></p>

<p>我们可以使用Systrace工具来导出CPU的执行情况，以便帮助定位性能问题。</p>

<hr />

<p>首发于CSDN：<a href="http://geek.csdn.net/news/detail/50692">Android性能优化典范（四）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android内存优化之OOM]]></title>
    <link href="http://hukai.me/android-performance-oom/"/>
    <updated>2015-09-12T14:53:00+08:00</updated>
    <id>http://hukai.me/android-performance-oom</id>
    <content type="html"><![CDATA[<blockquote><p>Android的内存优化是性能优化中很重要的一部分，而避免OOM又是内存优化中比较核心的一点，这是一篇关于内存优化中如何避免OOM的总结性概要文章，内容大多都是和OOM有关的实践总结概要。理解错误或是偏差的地方，还请多包涵指正，谢谢！</p></blockquote>

<h2>(一)Android的内存管理机制</h2>

<p>Google在Android的官网上有这样一篇文章，初步介绍了Android是如何管理应用的进程与内存分配：<a href="http://developer.android.com/training/articles/memory.html">http://developer.android.com/training/articles/memory.html</a>。
Android系统的Dalvik虚拟机扮演了常规的内存垃圾自动回收的角色，Android系统没有为内存提供交换区，它使用<a href="http://en.wikipedia.org/wiki/Paging">paging</a>与<a href="http://en.wikipedia.org/wiki/Memory-mapped_files">memory-mapping(mmapping)</a>的机制来管理内存，下面简要概述一些Android系统中重要的内存管理基础概念。</p>

<h3>1）共享内存</h3>

<p>Android系统通过下面几种方式来实现共享内存：</p>

<ul>
<li>Android应用的进程都是从一个叫做Zygote的进程fork出来的。Zygote进程在系统启动并且载入通用的framework的代码与资源之后开始启动。为了启动一个新的程序进程，系统会fork Zygote进程生成一个新的进程，然后在新的进程中加载并运行应用程序的代码。这使得大多数的RAM pages被用来分配给framework的代码，同时使得RAM资源能够在应用的所有进程之间进行共享。</li>
<li>大多数static的数据被mmapped到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。常见的static数据包括Dalvik Code，app resources，so文件等。</li>
<li>大多数情况下，Android通过显式的分配共享内存区域(例如ashmem或者gralloc)来实现动态RAM区域能够在不同进程之间进行共享的机制。例如，Window Surface在App与Screen Compositor之间使用共享的内存，Cursor Buffers在Content Provider与Clients之间共享内存。</li>
</ul>


<!-- More -->


<h3>2）分配与回收内存</h3>

<ul>
<li>每一个进程的Dalvik heap都反映了使用内存的占用范围。这就是通常逻辑意义上提到的Dalvik Heap Size，它可以随着需要进行增长，但是增长行为会有一个系统为它设定的上限。</li>
<li>逻辑上讲的Heap Size和实际物理意义上使用的内存大小是不对等的，Proportional Set Size(PSS)记录了应用程序自身占用以及和其他进程进行共享的内存。</li>
<li>Android系统并不会对Heap中空闲内存区域做碎片整理。系统仅仅会在新的内存分配之前判断Heap的尾端剩余空间是否足够，如果空间不够会触发gc操作，从而腾出更多空闲的内存空间。在Android的高级系统版本里面针对Heap空间有一个Generational Heap Memory的模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。系统会根据内存中不同的内存数据类型分别执行不同的gc操作。例如，刚分配到Young Generation区域的对象通常更容易被销毁回收，同时在Young Generation区域的gc操作速度会比Old Generation区域的gc操作速度更快。如下图所示：</li>
</ul>


<p><img src="/images/memory_mode_generation.png" alt="memory_mode_generation" />
<img src="/images/android_memory_gc_mode.png" alt="android_memory_gc_mode" /></p>

<p>每一个Generation的内存区域都有固定的大小，随着新的对象陆续被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发GC的操作，以便腾出空间来存放其他新的对象。如下图所示：</p>

<p><img src="/images/gc_threshold.png" alt="gc_threshold" /></p>

<p>通常情况下，GC发生的时候，所有的线程都是会被暂停的。执行GC所占用的时间和它发生在哪一个Generation也有关系，Young Generation中的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。执行时间的长短也和当前Generation中的对象数量有关，遍历树结构查找20000个对象比起遍历50个对象自然是要慢很多的。</p>

<h3>3）限制应用的内存</h3>

<ul>
<li>为了整个Android系统的内存控制需要，Android系统为每一个应用程序都设置了一个硬性的Dalvik Heap Size最大限制阈值，这个阈值在不同的设备上会因为RAM大小不同而各有差异。如果你的应用占用内存空间已经接近这个阈值，此时再尝试分配内存的话，很容易引起<code>OutOfMemoryError</code>的错误。</li>
<li><code>ActivityManager.getMemoryClass()</code>可以用来查询当前应用的Heap Size阈值，这个方法会返回一个整数，表明你的应用的Heap Size阈值是多少Mb(megabates)。</li>
</ul>


<h3>4）应用切换操作</h3>

<ul>
<li>Android系统并不会在用户切换应用的时候做交换内存的操作。Android会把那些不包含Foreground组件的应用进程放到LRU Cache中。例如，当用户开始启动了一个应用，系统会为它创建了一个进程，但是当用户离开这个应用，此进程并不会立即被销毁，而是会被放到系统的Cache当中，如果用户后来再切换回到这个应用，此进程就能够被马上完整的恢复，从而实现应用的快速切换。</li>
<li>如果你的应用中有一个被缓存的进程，这个进程会占用一定的内存空间，它会对系统的整体性能有影响。因此当系统开始进入Low Memory的状态时，它会由系统根据LRU的规则与应用的优先级，内存占用情况以及其他因素的影响综合评估之后决定是否被杀掉。</li>
<li>对于那些非foreground的进程，Android系统是如何判断Kill掉哪些进程的问题，请参考<a href="http://developer.android.com/guide/components/processes-and-threads.html">Processes and Threads</a>。</li>
</ul>


<h2>(二)OOM（OutOfMemory）</h2>

<p>前面我们提到过使用getMemoryClass()的方法可以得到Dalvik Heap的阈值。简要的获取某个应用的内存占用情况可以参考下面的示例（
关于更多内存查看的知识，可以参考这篇官方教程：<a href="http://developer.android.com/tools/debugging/debugging-memory.html">Investigating Your RAM Usage</a>
）</p>

<h3>1）查看内存使用情况</h3>

<ul>
<li>通过命令行查看内存详细占用情况：</li>
</ul>


<p><img src="/images/android_perf_oom_dumpsys_meminfo.png" alt="android_perf_oom_dumpsys_meminfo.png" /></p>

<ul>
<li>通过Android Studio的Memory Monitor查看内存中Dalvik Heap的实时变化</li>
</ul>


<p><img src="/images/android_perf_oom_studio_mem_monitor.png" alt="android_perf_oom_studio_mem_monitor" />
<img src="/images/memory_monitor_free_allocation.png" alt="memory_monitor_free_allocation" />
<img src="/images/memory_monitor_gc_event.png" alt="memory_monitor_gc_event" /></p>

<h3>2）发生OOM的条件</h3>

<p>关于Native Heap，Dalvik Heap，Pss等内存管理机制比较复杂，这里不展开描述。简单的说，通过不同的内存分配方式（malloc/mmap/JNIEnv/etc）对不同的对象（bitmap，etc）进行操作会因为Android系统版本的差异而产生不同的行为，对Native Heap与Dalvik Heap以及OOM的判断条件都会有所影响。在2.x的系统上，我们常常可以看到Heap Size的total值明显超过了通过getMemoryClass()获取到的阈值而不会发生OOM的情况，那么针对2.x与4.x的Android系统，到底是如何判断会发生OOM呢？</p>

<ul>
<li><p>Android 2.x系统
GC LOG中的dalvik allocated + external allocated + 新分配的大小 >= getMemoryClass()值的时候就会发生OOM。
例如，假设有这么一段Dalvik输出的GC LOG：GC_FOR_MALLOC free 2K, 13% free 32586K/37455K, external 8989K/10356K, paused 20ms，那么32586+8989+(新分配23975)=65550>64M时，就会发生OOM。</p></li>
<li><p>Android 4.x系统
Android 4.x的系统废除了external的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 >= getMemoryClass()的时候就会发生OOM，如下图所示（虽然图示演示的是art运行环境，但是统计规则还是和dalvik保持一致）</p></li>
</ul>


<p><img src="/images/android_perf_oom_gc_log.png" alt="android_perf_oom_gc_log.png" /></p>

<h2>(三)如何避免OOM总结</h2>

<p>前面介绍了一些基础的内存管理机制以及OOM的基础知识，那么在实践操作当中，有哪些指导性的规则可以参考呢？归纳下来，可以从四个方面着手，首先是减小对象的内存占用，其次是内存对象的重复利用，然后是避免对象的内存泄露，最后是内存使用策略优化。</p>

<h3>减小对象的内存占用</h3>

<p>避免OOM的第一步就是要尽量减少新分配出来的对象占用内存的大小，尽量使用更加轻量的对象。</p>

<h4>1）使用更加轻量的数据结构</h4>

<p>例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构，下图演示了HashMap的简要工作原理，相比起Android系统专门为移动操作系统编写的ArrayMap容器，在大多数情况下，都显示效率低下，更占内存。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。</p>

<p><img src="/images/android_perf_3_arraymap_key_value.png" alt="android_perf_3_arraymap_key_value" /></p>

<p>关于更多ArrayMap/SparseArray的讨论，请参考<a href="http://hukai.me/android-performance-patterns-season-3/">http://hukai.me/android-performance-patterns-season-3/</a>的前三个段落</p>

<h4>2）避免在Android里面使用Enum</h4>

<p>Android官方培训课程提到过<strong>"Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android."</strong>，具体原理请参考<a href="http://hukai.me/android-performance-patterns-season-3/">http://hukai.me/android-performance-patterns-season-3/</a>，所以请避免在Android里面使用到枚举。</p>

<h4>3）减小Bitmap对象的内存占用</h4>

<p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p>

<ul>
<li>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</li>
<li>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。</li>
</ul>


<h4>4）使用更小的图片</h4>

<p>在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p>

<h3>内存对象的重复利用</h3>

<p>大多数对象的复用，最终实施的方案都是利用对象池技术，要么是在编写代码的时候显式的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。</p>

<p><img src="/images/android_perf_2_object_pool.png" alt="android_perf_2_object_pool" /></p>

<p>在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，简要操作原理如下图所示：</p>

<p><img src="/images/android_perf_2_lru_mode.png" alt="android_perf_2_lru_mode" /></p>

<h4>1）复用系统自带的资源</h4>

<p>Android系统本身内置了很多的资源，例如字符串/颜色/图片/动画/样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小APK的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意Android系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p>

<h4>2）注意在ListView/GridView等出现大量重复子组件的视图里面对ConvertView的复用</h4>

<p><img src="/images/android_perf_oom_listview_recycle.png" alt="android_perf_oom_listview_recycle" /></p>

<h4>3）Bitmap对象的复用</h4>

<ul>
<li>在ListView与GridView等显示大量图片的控件里面需要使用LRU的机制来缓存处理好的Bitmap。</li>
</ul>


<p><img src="/images/android_perf_2_inbitmap_old.png" alt="android_perf_2_inbitmap_old" /></p>

<ul>
<li>利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率上的提升(3.0以及4.4以后存在一些使用限制上的差异)。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。</li>
</ul>


<p><img src="/images/android_perf_2_inbitmap_new.png" alt="android_perf_2_inbitmap_new" /></p>

<p>使用inBitmap需要注意几个限制条件：</p>

<ul>
<li>在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li>
<li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。
我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：</li>
</ul>


<p><img src="/images/android_perf_2_inbitmap_pool.png" alt="android_perf_2_inbitmap_pool" /></p>

<p>另外提一点：在2.x的系统上，尽管bitmap是分配在native层，但是还是无法避免被计算到OOM的引用计数器里面。这里提示一下，不少应用会通过反射BitmapFactory.Options里面的inNativeAlloc来达到扩大使用内存的目的，但是如果大家都这么做，对系统整体会造成一定的负面影响，建议谨慎采纳。</p>

<h4>4）避免在onDraw方法里面执行对象的创建</h4>

<p>类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p>

<h4>5）StringBuilder</h4>

<p>在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p>

<h3>避免对象的内存泄露</h3>

<p>内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现OOM。显然，这还使得每级Generation的内存区域可用空间变小，gc就会更容易被触发，容易出现内存抖动，从而引起性能问题。</p>

<p><img src="/images/android_perf_3_leak.png" alt="android_perf_3_leak" /></p>

<p>最新的LeakCanary开源控件，可以很好的帮助我们发现内存泄露的情况，更多关于LeakCanary的介绍，请看这里<a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a>(中文使用说明<a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/">http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/</a>)。另外也可以使用传统的MAT工具查找内存泄露，请参考这里<a href="http://android-developers.blogspot.pt/2011/03/memory-analysis-for-android.html">http://android-developers.blogspot.pt/2011/03/memory-analysis-for-android.html</a>（便捷的中文资料<a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/</a>）</p>

<h4>1）注意Activity的泄漏</h4>

<p>通常来说，Activity的泄漏是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的Activity泄漏：</p>

<ul>
<li>内部类引用导致Activity的泄漏</li>
</ul>


<p>最典型的场景是Handler导致的Activity泄漏，如果Handler中有延迟的任务或者是等待执行的任务队列过长，都有可能因为Handler继续执行而导致Activity发生泄漏。此时的引用关系链是Looper -> MessageQueue ->  Message -> Handler -> Activity。为了解决这个问题，可以在UI退出之前，执行remove Handler消息队列中的消息与runnable对象。或者是使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。</p>

<ul>
<li>Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。</li>
</ul>


<p>内部类引起的泄漏不仅仅会发生在Activity上，其他任何内部类出现的地方，都需要特别留意！我们可以考虑尽量使用static类型的内部类，同时使用WeakReference的机制来避免因为互相引用而出现的泄露。</p>

<h4>2）考虑使用Application Context而不是Activity Context</h4>

<p>对于大部分非必须使用Activity Context的情况（Dialog的Context就必须是Activity Context），我们都可以考虑使用Application Context而不是Activity的Context，这样可以避免不经意的Activity泄露。</p>

<h4>3）注意临时Bitmap对象的及时回收</h4>

<p>虽然在大多数情况下，我们会对Bitmap增加缓存机制，但是在某些时候，部分Bitmap是需要及时回收的。例如临时创建的某个相对比较大的bitmap对象，在经过变换得到新的bitmap对象之后，应该尽快回收原始的bitmap，这样能够更快释放原始bitmap所占用的空间。</p>

<p>需要特别留意的是Bitmap类里面提供的createBitmap()方法：</p>

<p><img src="/images/android_perf_oom_create_bitmap.png" alt="android_perf_oom_create_bitmap.png" /></p>

<p>这个函数返回的bitmap有可能和source bitmap是同一个，在回收的时候，需要特别检查source bitmap与return bitmap的引用是否相同，只有在不等的情况下，才能够执行source bitmap的recycle方法。</p>

<h4>4）注意监听器的注销</h4>

<p>在Android程序里面存在很多需要register与unregister的监听器，我们需要确保在合适的时候及时unregister那些监听器。自己手动add的listener，需要记得及时remove这个listener。</p>

<h4>5）注意缓存容器中的对象泄漏</h4>

<p>有时候，我们为了提高对象的复用性把某些对象放到缓存容器中，可是如果这些对象没有及时从容器中清除，也是有可能导致内存泄漏的。例如，针对2.3的系统，如果把drawable添加到缓存容器，因为drawable与View的强应用，很容易导致activity发生泄漏。而从4.0开始，就不存在这个问题。解决这个问题，需要对2.3系统上的缓存drawable做特殊封装，处理引用解绑的问题，避免泄漏的情况。</p>

<h4>6）注意WebView的泄漏</h4>

<p>Android中的WebView存在很大的兼容性问题，不仅仅是Android系统版本的不同对WebView产生很大的差异，另外不同的厂商出货的ROM里面WebView也存在着很大的差异。更严重的是标准的WebView存在内存泄露的问题，看这里<a href="https://code.google.com/p/android/issues/detail?id=5067">WebView causes memory leak - leaks the parent Activity</a>。所以通常根治这个问题的办法是为WebView开启另外一个进程，通过AIDL与主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>

<h4>7）注意Cursor对象是否及时关闭</h4>

<p>在程序中我们经常会进行查询数据库的操作，但时常会存在不小心使用Cursor之后没有及时关闭的情况。这些Cursor的泄露，反复多次出现的话会对内存管理产生很大的负面影响，我们需要谨记对Cursor对象的及时关闭。</p>

<h3>内存使用策略优化</h3>

<h4>1）谨慎使用large heap</h4>

<p>正如前面提到的，Android设备根据硬件与软件的设置差异而存在不同大小的内存空间，他们为应用程序设置了不同大小的Heap限制阈值。你可以通过调用<code>getMemoryClass()</code>来获取应用的可用Heap大小。在一些特殊的情景下，你可以通过在<code>manifest</code>的<code>application</code>标签下添加<code>largeHeap=true</code>的属性来为应用声明一个更大的heap空间。然后，你可以通过<code>getLargeMemoryClass()</code>来获取到这个更大的heap size阈值。然而，声明得到更大Heap阈值的本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用更多的内存而去请求一个大的Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用large heap。因此请谨慎使用large heap属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次gc的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行<code>getMemoryClass()</code>来检查实际获取到的heap大小。</p>

<h4>2）综合考虑设备内存阈值与其他因素设计合适的缓存大小</h4>

<p>例如，在设计ListView或者GridView的Bitmap LRU缓存的时候，需要考虑的点有：</p>

<ul>
<li>应用程序剩下了多少可用的内存空间?</li>
<li>有多少图片会被一次呈现到屏幕上？有多少图片需要事先缓存好以便快速滑动时能够立即显示到屏幕？</li>
<li>设备的屏幕大小与密度是多少? 一个xhdpi的设备会比hdpi需要一个更大的Cache来hold住同样数量的图片。</li>
<li>不同的页面针对Bitmap的设计的尺寸与配置是什么，大概会花费多少内存？</li>
<li>页面图片被访问的频率？是否存在其中的一部分比其他的图片具有更高的访问频繁？如果是，也许你想要保存那些最常访问的到内存中，或者为不同组别的位图(按访问频率分组)设置多个LruCache容器。</li>
</ul>


<h4>3）onLowMemory()与onTrimMemory()</h4>

<p>Android用户可以随意在不同的应用之间进行快速切换。为了让background的应用能够迅速的切换到forground，每一个background的应用都会占用一定的内存。Android系统会根据当前的系统的内存使用情况，决定回收部分background的应用内存。如果background的应用从暂停状态直接被恢复到forground，能够获得较快的恢复体验，如果background应用是从Kill的状态进行恢复，相比之下就显得稍微有点慢。</p>

<p><img src="/images/android_perf_3_memory_bg_2_for.png" alt="android_perf_3_memory_bg_2_for" /></p>

<ul>
<li><strong>onLowMemory()</strong>：Android系统提供了一些回调来通知当前应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到onLowMemory()的回调。在这种情况下，需要尽快释放当前应用的非必须的内存资源，从而确保系统能够继续稳定运行。</li>
<li><p><strong>onTrimMemory(int)</strong>：Android系统从4.0开始还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，收到onTrimMemory()回调的时候，需要根据传递的参数类型进行判断，合理的选择释放自身的一些内存占用，一方面可以提高系统的整体运行流畅度，另外也可以避免自己被系统判断为优先需要杀掉的应用。下图介绍了各种不同的回调参数：</p></li>
<li><p><strong>TRIM_MEMORY_UI_HIDDEN</strong>：你的应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键退出应用，导致应用的UI界面完全不可见。这个时候应该释放一些不可见的时候非必须的资源</p></li>
</ul>


<p>当程序正在前台运行的时候，可能会接收到从onTrimMemory()中返回的下面的值之一：</p>

<ul>
<li><strong>TRIM_MEMORY_RUNNING_MODERATE</strong>：你的应用正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。</li>
<li><strong>TRIM_MEMORY_RUNNING_LOW</strong>：你的应用正在运行且没有被列为可杀死的。但是设备正运行于更低内存的状态下，你应该释放不用的资源用来提升系统性能。</li>
<li><strong>TRIM_MEMORY_RUNNING_CRITICAL</strong>：你的应用仍在运行，但是系统已经把LRU Cache中的大多数进程都已经杀死，因此你应该立即释放所有非必须的资源。如果系统不能回收到足够的RAM数量，系统将会清除所有的LRU缓存中的进程，并且开始杀死那些之前被认为不应该杀死的进程，例如那个包含了一个运行态Service的进程。</li>
</ul>


<p>当应用进程退到后台正在被Cached的时候，可能会接收到从onTrimMemory()中返回的下面的值之一：</p>

<ul>
<li><strong>TRIM_MEMORY_BACKGROUND</strong>: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的应用进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的应用的时候才能够迅速恢复。</li>
<li><strong>TRIM_MEMORY_MODERATE</strong>: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。</li>
<li><strong>TRIM_MEMORY_COMPLETE</strong>: 系统正运行于低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的应用恢复状态的资源。</li>
</ul>


<p><img src="/images/android_perf_3_memory_ontrimmemory.png" alt="android_perf_3_memory_ontrimmemory" /></p>

<ul>
<li>因为onTrimMemory()的回调是在API 14才被加进来的，对于老的版本，你可以使用onLowMemory)回调来进行兼容。onLowMemory相当与TRIM_MEMORY_COMPLETE。</li>
<li>请注意：当系统开始清除LRU缓存中的进程时，虽然它首先按照LRU的顺序来执行操作，但是它同样会考虑进程的内存使用量以及其他因素。占用越少的进程越容易被留下来。</li>
</ul>


<h4>4）资源文件需要选择合适的文件夹进行存放</h4>

<p>我们知道<code>hdpi/xhdpi/xxhdpi</code>等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100<em>100的图片，那么根据换算关系，<code>xxhdpi</code>的手机去引用那张图片就会被拉伸到200</em>200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</p>

<h4>5）Try catch某些大内存分配的操作</h4>

<p>在某些情况下，我们需要事先评估那些可能发生OOM的代码，对于这些可能发生OOM的代码，加入catch机制，可以考虑在catch里面尝试一次降级的内存分配操作。例如decode bitmap的时候，catch到OOM，可以尝试把采样比例再增加一倍之后，再次尝试decode。</p>

<h4>6）谨慎使用static对象</h4>

<p>因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象。</p>

<p><img src="/images/android_perf_3_leak_static.png" alt="android_perf_3_leak_static" /></p>

<h4>7）特别留意单例对象中不合理的持有</h4>

<p>虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。</p>

<h4>8）珍惜Services资源</h4>

<p>如果你的应用需要在后台使用service，除非它被触发并执行一个任务，否则其他时候Service都应该是停止状态。另外需要注意当这个service完成任务之后因为停止service失败而引起的内存泄漏。
当你启动一个Service，系统会倾向为了保留这个Service而一直保留Service所在的进程。这使得进程的运行代价很高，因为系统没有办法把Service所占用的RAM空间腾出来让给其他组件，另外Service还不能被Paged out。这减少了系统能够存放到LRU缓存当中的进程数量，它会影响应用之间的切换效率，甚至会导致系统内存使用不稳定，从而无法继续保持住所有目前正在运行的service。
建议使用<a href="http://developer.android.com/reference/android/app/IntentService.html">IntentService</a>，它会在处理完交代给它的任务之后尽快结束自己。更多信息，请阅读<a href="http://developer.android.com/training/run-background-service/index.html">Running in a Background Service</a>。</p>

<h4>9）优化布局层次，减少内存消耗</h4>

<p>越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的View无法实现足够扁平的时候考虑使用自定义View来达到目的。</p>

<h4>10）谨慎使用“抽象”编程</h4>

<p>很多时候，开发者会使用抽象类作为”好的编程实践”，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的额外内存开销：他们需要同等量的代码用于可执行，那些代码会被mapping到内存中，因此如果你的抽象没有显著的提升效率，应该尽量避免他们。</p>

<h4>11）使用nano protobufs序列化数据</h4>

<p>Protocol buffers是由Google为序列化结构数据而设计的，一种语言无关，平台无关，具有良好的扩展性。类似XML，却比XML更加轻量，快速，简单。如果你需要为你的数据实现序列化与协议化，建议使用nano protobufs。关于更多细节，请参考<a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt">protobuf readme</a>的”Nano version”章节。</p>

<h4>12）谨慎使用依赖注入框架</h4>

<p>使用类似Guice或者RoboGuice等框架注入代码，在某种程度上可以简化你的代码。下面是使用RoboGuice前后的对比图：</p>

<p><img src="/images/android_perf_oom_roboguice_1.png" alt="android_perf_oom_roboguice_1" />
<img src="/images/android_perf_oom_roboguice_2.png" alt="android_perf_oom_roboguice_2" /></p>

<p>使用RoboGuice之后，代码是简化了不少。然而，那些注入框架会通过扫描你的代码执行许多初始化的操作，这会导致你的代码需要大量的内存空间来mapping代码，而且mapped pages会长时间的被保留在内存中。除非真的很有必要，建议谨慎使用这种技术。</p>

<h4>13）谨慎使用多进程</h4>

<p>使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p>

<p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的应用可以切分成2个进程：一个用来操作UI，另外一个给后台的Service。</p>

<h4>14）使用ProGuard来剔除不需要的代码</h4>

<p><a href="http://developer.android.com/tools/help/proguard.html">ProGuard</a>能够通过移除不需要的代码，重命名类，域与方法等等对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够减少mapping代码所需要的内存空间。</p>

<h4>15）谨慎使用第三方libraries</h4>

<p>很多开源的library代码都不是为移动网络环境而编写的，如果运用在移动设备上，并不一定适合。即使是针对Android而设计的library，也需要特别谨慎，特别是在你不知道引入的library具体做了什么事情的时候。例如，其中一个library使用的是nano protobufs, 而另外一个使用的是micro protobufs。这样一来，在你的应用里面就有2种protobuf的实现方式。这样类似的冲突还可能发生在输出日志，加载图片，缓存等等模块里面。另外不要为了1个或者2个功能而导入整个library，如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案。</p>

<h4>16）考虑不同的实现方式来优化内存占用</h4>

<p>在某些情况下，设计的某个方案能够快速实现需求，但是这个方案却可能在内存占用上表现的效率不够好。例如：</p>

<p><img src="/images/android_perf_2_waer_animation.png" alt="android_perf_2_waer_animation" /></p>

<p>对于上面这样一个时钟表盘的实现，最简单的就是使用很多张包含指针的表盘图片，使用帧动画实现指针的旋转。但是如果把指针扣出来，单独进行旋转绘制，显然比载入N多张图片占用的内存要少很多。当然这样做，代码复杂度上会有所增加，这里就需要在优化内存占用与实现简易度之间进行权衡了。</p>

<hr />

<p>写在最后：</p>

<ul>
<li>设计风格很大程度上会影响到程序的内存与性能，相对来说，如果大量使用类似Material Design的风格，不仅安装包可以变小，还可以减少内存的占用，渲染性能与加载性能都会有一定的提升。</li>
<li>内存优化并不就是说程序占用的内存越少就越好，如果因为想要保持更低的内存占用，而频繁触发执行gc操作，在某种程度上反而会导致应用性能整体有所下降，这里需要综合考虑做一定的权衡。</li>
<li>Android的内存优化涉及的知识面还有很多：内存管理的细节，垃圾回收的工作原理，如何查找内存泄漏等等都可以展开讲很多。OOM是内存优化当中比较突出的一点，尽量减少OOM的概率对内存优化有着很大的意义。</li>
</ul>


<hr />

<p>参考资料：</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=_CruQY55HOk">Google I/O 2011: Memory management for Android Apps</a></li>
<li><a href="http://developer.android.com/training/articles/memory.html">Managing Your App's Memory</a></li>
<li><a href="http://android-developers.blogspot.com/2009/01/avoiding-memory-leaks.html">Avoiding memory leaks</a></li>
<li><a href="http://hukai.me/android-performance-patterns-season-3/">Android性能优化典范 - 第3季</a></li>
<li><a href="http://hukai.me/android-performance-patterns-season-2/">Android性能优化典范 - 第2季</a></li>
<li><a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a></li>
<li><a href="http://hukai.me/android-performance-memory/">Android性能优化之内存篇</a></li>
<li>其他</li>
</ul>


<p><strong>本文刊登于CSDN《程序员》10月A刊上，如需转载请与CSDN联系</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第3季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-3/"/>
    <updated>2015-08-11T23:53:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-3</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_3.png" alt="android_perf_patterns_season_3" /></p>

<blockquote><p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>的课程最近更新到第三季了，这次一共12个短视频课程，包括的内容大致有：更高效的ArrayMap容器，使用Android系统提供的特殊容器来避免自动装箱，避免使用枚举类型，注意onLowMemory与onTrimMemory的回调，避免内存泄漏，高效的位置更新操作，重复layout操作的性能影响，以及使用Batching，Prefetching优化网络请求，压缩传输数据等等使用技巧。下面是对这些课程的总结摘要，认知有限，理解偏差的地方请多多交流指正！</p></blockquote>

<h2>1)Fun with ArrayMaps</h2>

<p>程序内存的管理是否合理高效对应用的性能有着很大的影响，有的时候对容器的使用不当也会导致内存管理效率低下。Android为移动操作系统特意编写了一些更加高效的容器，例如SparseArray，今天要介绍的是一个新的容器，叫做<strong><a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/core/java/android/util/ArrayMap.java">ArrayMap</a></strong>。</p>

<p>我们经常会使用到HashMap这个容器，它非常好用，但是却很占用内存。下图演示了HashMap的简要工作原理：</p>

<p><img src="/images/android_perf_3_arraymap_key_value.png" alt="android_perf_3_arraymap_key_value" /></p>

<p>为了解决HashMap更占内存的弊端，Android提供了内存效率更高的<strong>ArrayMap</strong>。它内部使用两个数组进行工作，其中一个数组记录key hash过后的顺序列表，另外一个数组按key的顺序记录Key-Value值，如下图所示：</p>

<!-- More -->


<p><img src="/images/android_perf_3_arraymap_two_array.png" alt="android_perf_3_arraymap_two_array" /></p>

<p>当你想获取某个value的时候，ArrayMap会计算输入key转换过后的hash值，然后对hash数组使用二分查找法寻找到对应的index，然后我们可以通过这个index在另外一个数组中直接访问到需要的键值对。如果在第二个数组键值对中的key和前面输入的查询key不一致，那么就认为是发生了碰撞冲突。为了解决这个问题，我们会以该key为中心点，分别上下展开，逐个去对比查找，直到找到匹配的值。如下图所示：</p>

<p><img src="/images/android_perf_3_arraymap_binary_search.png" alt="android_perf_3_arraymap_binary_search" /></p>

<p>随着数组中的对象越来越多，查找访问单个对象的花费也会跟着增长，这是在内存占用与访问时间之间做权衡交换。</p>

<p>既然ArrayMap中的内存占用是连续不间断的，那么它是如何处理插入与删除操作的呢？请看下图所示，演示了Array的特性：</p>

<p><img src="/images/android_perf_3_arraymap_del.png" alt="android_perf_3_arraymap_del" /></p>

<p><img src="/images/android_perf_3_arraymap_add.png" alt="android_perf_3_arraymap_add" /></p>

<p>很明显，ArrayMap的插入与删除的效率是不够高的，但是如果数组的列表只是在一百这个数量级上，则完全不用担心这些插入与删除的效率问题。HashMap与ArrayMap之间的内存占用效率对比图如下：</p>

<p><img src="/images/android_perf_3_arraymap_memory_compare.png" alt="android_perf_3_arraymap_memory_compare" /></p>

<p>与HashMap相比，ArrayMap在循环遍历的时候也更加简单高效，如下图所示：</p>

<p><img src="/images/android_perf_3_arraymap_list.png" alt="android_perf_3_arraymap_list" /></p>

<p>前面演示了很多ArrayMap的优点，但并不是所有情况下都适合使用ArrayMap，我们应该在满足下面2个条件的时候才考虑使用ArrayMap：</p>

<ul>
<li>对象个数的数量级最好是千以内</li>
<li>数据组织形式包含Map结构</li>
</ul>


<p>我们需要学会在特定情形下选择相对更加高效的实现方式。</p>

<h2>2)Beware Autoboxing</h2>

<p>有时候性能问题也可能是因为那些不起眼的小细节引起的，例如在代码中不经意的“自动装箱”。我们知道基础数据类型的大小：boolean(8 bits), int(32 bits), float(32 bits)，long(64 bits)，为了能够让这些基础数据类型在大多数Java容器中运作，会需要做一个autoboxing的操作，转换成Boolean，Integer，Float等对象，如下演示了循环操作的时候是否发生autoboxing行为的差异：</p>

<p><img src="/images/android_perf_3_autoboxing_for.png" alt="android_perf_3_autoboxing_for" /></p>

<p><img src="/images/android_perf_3_autoboxing_perf.png" alt="android_perf_3_autoboxing_perf" /></p>

<p>Autoboxing的行为还经常发生在类似HashMap这样的容器里面，对HashMap的增删改查操作都会发生了大量的autoboxing的行为。</p>

<p><img src="/images/android_perf_3_autoboxing_hashmap.png" alt="android_perf_3_autoboxing_hashmap" /></p>

<p>为了避免这些autoboxing带来的效率问题，Android特地提供了一些如下的Map容器用来替代HashMap，不仅避免了autoboxing，还减少了内存占用：</p>

<p><img src="/images/android_perf_3_autoboxing_sparse.png" alt="android_perf_3_autoboxing_sparse" /></p>

<h2>3)SparseArray Family Ties</h2>

<p>为了避免HashMap的autoboxing行为，Android系统提供了SparseBoolMap，SparseIntMap，SparseLongMap，LongSparseMap等容器。关于这些容器的基本原理请参考前面的ArrayMap的介绍，另外这些容器的使用场景也和ArrayMap一致，需要满足数量级在千以内，数据组织形式需要包含Map结构。</p>

<h2>4)The price of ENUMs</h2>

<p>在StackOverFlow等问答社区常常出现关于在Android系统里面使用枚举类型的性能讨论，关于这一点，Android官方的Training课程里面有下面这样一句话：</p>

<blockquote><p>Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p></blockquote>

<p><img src="/images/android_perf_3_enum.png" alt="android_perf_3_enum" /></p>

<p>关于enum的效率，请看下面的讨论。假设我们有这样一份代码，编译之后的dex大小是2556 bytes，在此基础之上，添加一些如下代码，这些代码使用普通static常量相关作为判断值：</p>

<p><img src="/images/android_perf_3_enum_static.png" alt="android_perf_3_enum_static" /></p>

<p>增加上面那段代码之后，编译成dex的大小是2680 bytes，相比起之前的2556 bytes只增加124 bytes。假如换做使用enum，情况如下：</p>

<p><img src="/images/android_perf_3_enum_enum.png" alt="android_perf_3_enum_enum" /></p>

<p>使用enum之后的dex大小是4188 bytes，相比起2556增加了1632 bytes，增长量是使用static int的13倍。不仅仅如此，使用enum，运行时还会产生额外的内存占用，如下图所示：</p>

<p><img src="/images/android_perf_3_enum_memory.png" alt="android_perf_3_enum_memory" /></p>

<p>Android官方强烈建议不要在Android程序里面使用到enum。</p>

<h2>5)Trimming and Sharing Memory</h2>

<p>Android系统的一大特色是多任务，用户可以随意在不同的app之间进行快速切换。为了确保你的应用在这种复杂的多任务环境中正常运行，我们需要了解下面的知识。</p>

<p>为了让background的应用能够迅速的切换到forground，每一个background的应用都会占用一定的内存。Android系统会根据当前的系统内存使用情况，决定回收部分background的应用内存。如果background的应用从暂停状态直接被恢复到forground，能够获得较快的恢复体验，如果background应用是从Kill的状态进行恢复，就会显得稍微有点慢。</p>

<p><img src="/images/android_perf_3_memory_bg_2_for.png" alt="android_perf_3_memory_bg_2_for" /></p>

<p>Android系统提供了一些回调来通知应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到<strong>onLowMemory()</strong>的回调。在这种情况下，需要尽快释放当前应用的非必须内存资源，从而确保系统能够稳定继续运行。Android系统还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，下图介绍了各种不同的回调参数：</p>

<p><img src="/images/android_perf_3_memory_ontrimmemory.png" alt="android_perf_3_memory_ontrimmemory" /></p>

<p>关于每个参数的更多介绍，请参考这里 <a href="http://hukai.me/android-training-managing_your_app_memory/">http://hukai.me/android-training-managing_your_app_memory/</a>，另外onTrimMemory()的回调可以发生在Application，Activity，Fragment，Service，Content Provider。</p>

<p>从Android 4.4开始，ActivityManager提供了<strong>isLowRamDevice()</strong>的API，通常指的是Heap Size低于512M或者屏幕大小&lt;=800*480的设备。</p>

<h2>6)DO NOT LEAK VIEWS</h2>

<p>内存泄漏的概念，下面一张图演示下：</p>

<p><img src="/images/android_perf_3_leak.png" alt="android_perf_3_leak" /></p>

<p>通常来说，View会保持Activity的引用，Activity同时还和其他内部对象也有可能保持引用关系。当屏幕发生旋转的时候，activity很容易发生泄漏，这样的话，里面的view也会发生泄漏。Activity以及view的泄漏是非常严重的，为了避免出现泄漏，请特别留意以下的规则：</p>

<h3>6.1)避免使用异步回调</h3>

<p>异步回调被执行的时间不确定，很有可能发生在activity已经被销毁之后，这不仅仅很容易引起crash，还很容易发生内存泄露。</p>

<p><img src="/images/android_perf_3_leak_asyncback.png" alt="android_perf_3_leak_asyncback" /></p>

<h3>6.2)避免使用Static对象</h3>

<p>因为static的生命周期过长，使用不当很可能导致leak，在Android中应该尽量避免使用static对象。</p>

<p><img src="/images/android_perf_3_leak_static.png" alt="android_perf_3_leak_static" /></p>

<h3>6.3)避免把View添加到没有清除机制的容器里面</h3>

<p>假如把view添加到<a href="http://stackoverflow.com/questions/5511279/what-is-a-weakhashmap-and-when-to-use-it">WeakHashMap</a>，如果没有执行清除操作，很可能会导致泄漏。</p>

<p><img src="/images/android_perf_3_leak_map.png" alt="android_perf_3_leak_map" /></p>

<h2>7)Location &amp; Battery Drain</h2>

<p>开启定位功能是一个相对来说比较耗电的操作，通常来说，我们会使用类似下面这样的代码来发出定位请求：</p>

<p><img src="/images/android_perf_3_location_request.png" alt="android_perf_3_location_request" /></p>

<p>上面演示中有一个方法是<strong>setInterval()</strong>指的意思是每隔多长的时间获取一次位置更新，时间相隔越短，自然花费的电量就越多，但是时间相隔太长，又无法及时获取到更新的位置信息。其中存在的一个优化点是，我们可以通过判断返回的位置信息是否相同，从而决定设置下次的更新间隔是否增加一倍，通过这种方式可以减少电量的消耗，如下图所示：</p>

<p><img src="/images/android_perf_3_location_reduce.png" alt="android_perf_3_location_reduce" /></p>

<p>在位置请求的演示代码中还有一个方法是<strong>setFastestInterval()</strong>，因为整个系统中很可能存在其他的应用也在请求位置更新，那些应用很有可能设置的更新间隔时间很短，这种情况下，我们就可以通过setFestestInterval的方法来过滤那些过于频繁的更新。</p>

<p>通过GPS定位服务相比起使用网络进行定位更加的耗电，但是也相对更加精准一些，他们的图示关系如下：</p>

<p><img src="/images/android_perf_3_location_provider.png" alt="android_perf_3_location_provider" /></p>

<p>为了提供不同精度的定位需求，同时屏蔽实现位置请求的细节，Android提供了下面4种不同精度与耗电量的参数给应用进行设置调用，应用只需要决定在适当的场景下使用对应的参数就好了，通过LocationRequest.setPriority()方法传递下面的参数就好了。</p>

<p><img src="/images/android_perf_3_location_accuracy.png" alt="android_perf_3_location_accuracy" /></p>

<h2>8)Double Layout Taxation</h2>

<p>布局中的任何一个View一旦发生一些属性变化，都可能引起很大的连锁反应。例如某个button的大小突然增加一倍，有可能会导致兄弟视图的位置变化，也有可能导致父视图的大小发生改变。当大量的layout()操作被频繁调用执行的时候，就很可能引起丢帧的现象。</p>

<p><img src="/images/android_perf_3_layout_double.png" alt="android_perf_3_layout_double" /></p>

<p>例如，在RelativeLayout中，我们通常会定义一些类似alignTop，alignBelow等等属性，如图所示：</p>

<p><img src="/images/android_perf_3_layout_relative.png" alt="android_perf_3_layout_relative" /></p>

<p>为了获得视图的准确位置，需要经过下面几个阶段。首先子视图会触发计算自身位置的操作，然后RelativeLayout使用前面计算出来的位置信息做边界的调整的操作，如下面两张图所示：</p>

<p><img src="/images/android_perf_3_layout_first_cal.png" alt="android_perf_3_layout_first_cal" /></p>

<p><img src="/images/android_perf_3_layout_first_adjust.png" alt="android_perf_3_layout_first_adjust" /></p>

<p>经历过上面2个步骤，relativeLayout会立即触发第二次layout()的操作来确定所有子视图的最终位置与大小信息。</p>

<p>除了RelativeLayout会发生两次layout操作之外，LinearLayout也有可能触发两次layout操作，通常情况下LinearLayout只会发生一次layout操作，可是一旦调用了measureWithLargetChild()方法就会导致触发两次layout的操作。另外，通常来说，GridLayout会自动预处理子视图的关系来避免两次layout，可是如果GridLayout里面的某些子视图使用了weight等复杂的属性，还是会导致重复的layout操作。</p>

<p>如果只是少量的重复layout本身并不会引起严重的性能问题，但是如果它们发生在布局的根节点，或者是ListView里面的某个ListItem，这样就会引起比较严重的性能问题。如下图所示：</p>

<p><img src="/images/android_perf_3_layout_hierachy.png" alt="android_perf_3_layout_hierachy" /></p>

<p>我们可以使用Systrace来跟踪特定的某段操作，如果发现了疑似丢帧的现象，可能就是因为重复layout引起的。通常我们无法避免重复layout，在这种情况下，我们应该尽量保持View Hierarchy的层级比较浅，这样即使发生重复layout，也不会因为布局的层级比较深而增大了重复layout的倍数。另外还有一点需要特别注意，在任何时候都请避免调用<strong>requestLayout()</strong>的方法，因为一旦调用了requestLayout，会导致该layout的所有父节点都发生重新layout的操作。</p>

<p><img src="/images/android_perf_3_layout_request.png" alt="android_perf_3_layout_request" /></p>

<h2>9)Network Performance 101</h2>

<p>在性能优化第一季与第二季的课程里面都介绍过，网络请求的操作是非常耗电的，其中在移动蜂窝网络情况下执行网络数据的请求则尤其比较耗电。关于如何减少移动网络下的网络请求的耗电量，有两个重要的原则需要遵守：第一个是减少移动网络被激活的时间与次数，第二个是压缩传输数据。</p>

<h3>9.1)减少移动网络被激活的时间与次数</h3>

<p>通常来说，发生网络行为可以划分为如下图所示的三种类型，一个是用户主动触发的请求，另外被动接收服务器的返回数据，最后一个是数据上报，行为上报，位置更新等等自定义的后台操作。</p>

<p><img src="/images/android_perf_3_network_three_type.png" alt="android_perf_3_network_three_type" /></p>

<p>我们绝对坚决肯定不应该使用Polling(轮询)的方式去执行网络请求，这样不仅仅会造成严重的电量消耗，还会浪费许多网络流量，例如：</p>

<p><img src="/images/android_perf_3_network_polling.png" alt="android_perf_3_network_polling" /></p>

<p>Android官方推荐使用<a href="https://developers.google.com/cloud-messaging/">Google Cloud Messaging</a>(在大陆，然并卵)，这个框架会帮助把更新的数据推送给手机客户端，效率极高！我们应该遵循下面的规则来处理数据同步的问题：</p>

<p>首先，我们应该使用回退机制来避免固定频繁的同步请求，例如，在发现返回数据相同的情况下，推迟下次的请求时间，如下图所示：</p>

<p><img src="/images/android_perf_3_network_backoff.png" alt="android_perf_3_network_backoff" /></p>

<p>其次，我们还可以使用<strong>Batching</strong>(批处理)的方式来集中发出请求，避免频繁的间隔请求，如下图所示：</p>

<p><img src="/images/android_perf_3_network_batching.png" alt="android_perf_3_network_batching" /></p>

<p>最后，我们还可以使用<strong>Prefetching</strong>(预取)的技术提前把一些数据拿到，避免后面频繁再次发起网络请求，如下图所示：</p>

<p><img src="/images/android_perf_3_network_prefetching.png" alt="android_perf_3_network_prefetching" /></p>

<p>Google Play Service中提供了一个叫做<a href="https://developers.google.com/cloud-messaging/network-manager">GCMNetworkManager</a>的类来帮助我们实现上面的那些功能，我们只需要调用对应的API，设置一些简单的参数，其余的工作就都交给Google来帮我们实现了。</p>

<p><img src="/images/android_perf_3_network_gcm_network_manager.png" alt="android_perf_3_network_gcm_network_manager" /></p>

<h3>9.2)压缩传输数据</h3>

<p>关于压缩传输数据，我们可以学习以下的一些课程(真的够喝好几壶了)：</p>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H">CompressorHead</a>：这系列的课程会介绍压缩的基本概念以及一些常见的压缩算法知识。</li>
<li><a href="http://www.html5rocks.com/en/tutorials/speed/img-compression/">Image Compression</a>：介绍关于图片的压缩知识。</li>
<li><a href="http://www.gdcvault.com/play/1020682/Texture-Wranglin-Getting-your-Android">Texture Wranglin</a>：介绍了游戏开发相关的知识。</li>
<li><a href="https://www.youtube.com/watch?v=P7riQin9Bfo&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_3146342489">Grabby</a>：介绍了游戏开发相关的知识。</li>
<li><a href="https://www.youtube.com/watch?v=whGwm0Lky2s&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_1270272007">Gzip is not enough</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/speed/txt-compression/">Text Compression</a></li>
<li><a href="https://www.youtube.com/watch?v=iQTxMkSJ1dQ&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_632816183">FlatBuffers</a></li>
</ul>


<h2>10)Effective Network Batching</h2>

<p>在性能优化课程的第一季与第二季里面，我们都有提到过下面这样一个网络请求与电量消耗的示意图：</p>

<p><img src="/images/android_perf_3_batching_networking.png" alt="android_perf_3_batching_networking" /></p>

<p>发起网络请求与接收返回数据都是比较耗电的，在网络硬件模块被激活之后，会继续保持几十秒的电量消耗，直到没有新的网络操作行为之后，才会进入休眠状态。前面一个段落介绍了使用Batching的技术来捆绑网络请求，从而达到减少网络请求的频率。那么如何实现Batching技术呢？通常来说，我们可以会把那些发出的网络请求，先暂存到一个PendingQueue里面，等到条件合适的时候再触发Queue里面的网络请求。</p>

<p><img src="/images/android_perf_3_batching_queue.png" alt="android_perf_3_batching_queue" /></p>

<p>可是什么时候才算是条件合适了呢？最简单粗暴的，例如我们可以在Queue大小到10的时候触发任务，也可以是当手机开始充电，或者是手机连接到WiFi等情况下才触发队列中的任务。手动编写代码去实现这些功能会比较复杂繁琐，Google为了解决这个问题，为我们提供了GCMNetworkManager来帮助实现那些功能，仅仅只需要调用API，设置触发条件，然后就OK了。</p>

<h2>11)Optimizing Network Request Frequencies</h2>

<p>前面的段落已经提到了应该减少网络请求的频率，这是为了减少电量的消耗。我们可以使用Batching，Prefetching的技术来避免频繁的网络请求。Google提供了GCMNetworkManager来帮助开发者实现那些功能，通过提供的API，我们可以选择在接入WiFi，开始充电，等待移动网络被激活等条件下再次激活网络请求。</p>

<h2>12)Effective Prefetching</h2>

<p>假设我们有这样的一个场景，最开始网络请求了一张图片，隔了10秒需要请求另外一张图片，再隔6秒会请求第三张图片，如下图所示：</p>

<p><img src="/images/android_perf_3_prefetching.png" alt="android_perf_3_prefetching" /></p>

<p>类似上面的情况会频繁触发网络请求，但是如果我们能够预先请求后续可能会使用到网络资源，避免频繁的触发网络请求，这样就能够显著的减少电量的消耗。可是预先获取多少数据量是很值得考量的，因为如果预取数据量偏少，就起不到减少频繁请求的作用，可是如果预取数据过多，就会造成资源的浪费。</p>

<p><img src="/images/android_perf_3_prefetching_over.png" alt="android_perf_3_prefetching_over" /></p>

<p>我们可以参考在WiFi，4G，3G等不同的网络下设计不同大小的预取数据量，也可以是按照图片数量或者操作时间来作为阀值。这需要我们需要根据特定的场景，不同的网络情况设计合适的方案。</p>

<hr />

<p>首发于CSDN：<a href="http://www.csdn.net/article/2015-08-12/2825447-android-performance-patterns-season-3">Android性能优化典范（三）</a></p>
]]></content>
  </entry>
  
</feed>
