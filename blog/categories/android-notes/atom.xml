<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android:Notes | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android-notes/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2018-05-28T21:33:51+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[HuKai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android APK安装包瘦身]]></title>
    <link href="http://hukai.me/android-tips-for-reduce-apk-size/"/>
    <updated>2014-09-13T20:24:00+08:00</updated>
    <id>http://hukai.me/android-tips-for-reduce-apk-size</id>
    <content type="html"><![CDATA[<p>很显然，APK安装包越小越好。下面从代码，资源文件，使用策略几个方面简要介绍下：</p>

<h3>代码</h3>

<ul>
<li>保持良好的编程习惯，不要重复或者不用的代码，谨慎添加libs，移除使用不到的libs。</li>
<li>使用proguard混淆代码，它会对不用的代码做优化，并且混淆后也能够减少安装包的大小。</li>
<li>native code的部分，大多数情况下只需要支持armabi与x86的架构即可。如果非必须，可以考虑拿掉x86的部分。</li>
</ul>


<h3>资源</h3>

<ul>
<li>使用Lint工具查找没有使用到的资源。去除不使用的图片，String，XML等等。</li>
<li>assets目录下的资源请确保没有用不上的文件。</li>
<li>生成APK的时候，aapt工具本身会对png做优化，但是在此之前还可以使用其他工具如tinypng对图片进行进一步的压缩预处理。</li>
<li>jpeg还是png，根据需要做选择，在某些时候jpeg可以减少图片的体积。</li>
<li>对于9.png的图片，可拉伸区域尽量切小，另外可以通过使用9.png拉伸达到大图效果的时候尽量不要使用整张大图。</li>
</ul>


<!-- More -->


<h3>策略</h3>

<ul>
<li>有选择性的提供hdpi，xhdpi，xxhdpi的图片资源。建议优先提供xhdpi的图片，对于mdpi，ldpi与xxxhdpi根据需要提供有差异的部分即可。</li>
<li>尽可能的重用已有的图片资源。例如对称的图片，只需要提供一张，另外一张图片可以通过代码旋转的方式实现。</li>
<li>能用代码绘制实现的功能，尽量不要使用大量的图片。例如减少使用多张图片组成animate-list的AnimationDrawable，这种方式提供了多张图片很占空间。</li>
</ul>


<h3>总结</h3>

<p>一个好的应用，需要具备很多优点，尽可能提供小的安装包是其中一个重要的方面。以上的小技巧，需要综合考虑，结合实际情况进行取舍。当然我们还可以采取一些按需加载的策略来减少安装包的体积，最好提一点，砍掉不必要的功能才是安装包瘦身的终极奥秘。O(∩_∩)O哈！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes - Activity生命周期中的onSaveInstanceState]]></title>
    <link href="http://hukai.me/android-activitylifecycle-onsaveinstancestate/"/>
    <updated>2014-08-31T17:01:00+08:00</updated>
    <id>http://hukai.me/android-activitylifecycle-onsaveinstancestate</id>
    <content type="html"><![CDATA[<p>记录下Activity生命周期中的<a href="http://developer.android.com/reference/android/app/Activity.html">onSaveInstanceState(Bundle outState)</a></p>

<h2>onSaveInstanceState与onRestoreInstanceState的作用：</h2>

<p>在资源紧张的情况下，系统会选择杀死一些处于非栈顶的Activity来回收资源。
为了能够让这些可能被杀死的Activity能够在恢复显示的时候状态不丢失，所以需要在Activity从栈顶往下压的时候提供onSaveInstanceState的回调用来提前保存状态信息。</p>

<p>而onRestoreInstanceState则是在这个Activity真的回收掉之后的恢复显示阶段用来恢复之前保存的数据。</p>

<h2>onSaveInstanceState与onRestoreInstanceState的调用时机：</h2>

<p>只要某个Activity是做入栈并且非栈顶时（启动跳转其他Activity或者点击Home按钮），此Activity是需要调用onSaveInstanceState的，
如果Activity是做出栈的动作（点击back或者执行finish），是不会调用onSaveInstanceState的。</p>

<p>只有在Activity真的被系统非正常杀死过，恢复显示Activity的时候，就会调用onRestoreInstanceState。</p>

<h2><a href="https://github.com/kesenhoo/ActivityLifeCycle">Sample Code</a></h2>

<ul>
<li>从ActivityA启动ActivityB执行顺序是：A：onCreate -> A：onStart -> A：onResume -> B：onCreate -> B：onStart -> B：onResume -> A：onSaveInstanceState –> A：onStop。</li>
<li>正常流程从ActivityB点击Back按钮或者是触发finish方法回退到ActivityA，执行顺序是：B：finish –> B：onPause –> A： onRestart –> A：onStart  -> A：onResume -> B： onStop –> B：onDestroy。</li>
<li>若启动ActivityB之后，选择点击Home按钮，程序退到后台，那么执行顺序是：B：onPause -> B：onSaveInstanceState -> B：onStop。</li>
<li>程序在后台的时候，选择主动杀死程序进程，然后再从桌面点击应用启动，会显示之前的ActivityB，执行顺序是：B：onCreate -> B：onStart –> B：onRestoreInstanceState - > B：onResume。</li>
<li>点击Back按钮或者是执行Activity B里面提供的finish方法：B：finish –> B：onPause –> A：onCreate  -> A：onStart -> A：onRestoreInstanceState -> A：onResume -> B：onStop -> B：onDestory。</li>
<li>最后再点击Back按钮或是执行Activity A里面的finish方法退出程序：A：finish -> A：onPause –> A：onStop -> A：onDestory。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes - 添加Copy to Clipboard的选项到分享列表中]]></title>
    <link href="http://hukai.me/android-notes-add-copy-text-option-to-share-list/"/>
    <updated>2014-07-12T15:26:00+08:00</updated>
    <id>http://hukai.me/android-notes-add-copy-text-option-to-share-list</id>
    <content type="html"><![CDATA[<p>偶然被人问到如何添加复制到剪切板的选项到分享列表，如下图所示：</p>

<p><img src="/images/copy_link_option_at_share_list.png" alt="copy_link_option_at_share_list" /></p>

<p>一般情况下，分享一段文字或者图片，我们会使用如下Android默认的方式：</p>

<p>```java
public void shareText(Context context, String text) {</p>

<pre><code>Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, text);
sendIntent.setType("text/plain");
context.startActivity(Intent.createChooser(sendIntent, "Share via..."));
</code></pre>

<p>}
```</p>

<p>这样系统能够帮忙筛选出那些符合这个Intent的所有Activity，生成分享列表，呈现给用户。因为分享列表的信息是由系统过滤生成的，UI界面也是交给系统进行绘制的，我们的应用无法给这个分享列表设置点击监听器，那么如何才能实现添加一个<strong>"Copy to Clipboard"</strong>的选项到分享列表中，并在点击该选项之后执行对应的动作呢？当然，自己去实现这个分享列表的效果，UI完全交给自己的应用来控制，是可以轻松做到的，可是自己去过滤符合条件的应用，并绘制分享列表的代码量会大很多，实现起来更加复杂？下面介绍一个虽然写法有点奇怪却相对简便很多的方法。</p>

<!-- More -->


<p>实现步骤如下：</p>

<h3>1)创建一个新的Intent</h3>

<p>```java
Intent intent = new Intent(Intent.ACTION_SEND);
intent.setType("text/plain");
intent.putExtra(Intent.EXTRA_SUBJECT, title);
intent.putExtra(Intent.EXTRA_TEXT, body);</p>

<p>Intent clipboardIntent = new Intent("ACTION_COPY_TO_CLIPBOARD");
clipboardIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
clipboardIntent.putExtra("KEY_SHARE_TITLE", title);
clipboardIntent.putExtra("KEY_SHARE_BODY", body);</p>

<p>try {</p>

<pre><code>Intent chooserIntent = Intent.createChooser(intent, "Share via");
chooserIntent.putExtra(Intent.EXTRA_INITIAL_INTENTS, new Intent[] {clipboardIntent});
context.startActivity(chooserIntent);
</code></pre>

<p>} catch (android.content.ActivityNotFoundException ex) {</p>

<pre><code>Toast.makeText(context, "There are no share clients installed.", Toast.LENGTH_SHORT).show();
</code></pre>

<p>}
```</p>

<p>请注意：Action与Flag。</p>

<h3>2)在manifest文件中为当前的actiivty添加Intent Filter</h3>

<p>```xml
&lt;activity</p>

<pre><code>android:name=".TestActivity"
android:label="Copy to clipboard"
android:icon="@drawable/ic_action_copy"
android:launchMode="singleTop"
android:screenOrientation="portrait"
android:windowSoftInputMode="adjustPan"&gt;
&lt;intent-filter&gt;
    &lt;action android:name="ACTION_COPY_TO_CLIPBOARD"/&gt;
    &lt;category android:name="android.intent.category.DEFAULT"/&gt;
&lt;/intent-filter&gt;
</code></pre>

<p></activity>
```</p>

<p>icon与label组成了分享列表中的"复制到剪切板"。launchMode定义为singleTop是因为当前activity已经在栈顶，没有必要因为intent的到来而重新创建一个，所以维持目前的activity，使得点击”复制到剪切板“之后，activity会直接执行onNewIntent()的回调，在这里获取到之前定义的intent，从这个intent获取后续操作的数据。</p>

<h3>3)在onNewIntent()中执行把文字复制到剪切板的任务</h3>

<p>```java
@Override
protected void onNewIntent(Intent intent) {</p>

<pre><code>super.onNewIntent(intent);
Log.i(TAG, "[onNewIntent] intent = " + intent);
if (intent != null &amp;&amp; intent.getAction().equalsIgnoreCase("ACTION_COPY_TO_CLIPBOARD")) {
    String title = intent.getStringExtra("KEY_SHARE_TITLE");
    String body = intent.getStringExtra("KEY_SHARE_BODY");

    ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
    // clipboard.setText(title + body);
    // Creates a new text clip to put on the clipboard
    ClipData clip = ClipData.newPlainText(title, body);
    clipboard.setPrimaryClip(clip);
    Log.d(TAG, "[onNewIntent] copy text title = " + title + ", body = " + body);
    Toast.makeText(this, "Copy Succussed!", Toast.LENGTH_SHORT).show();
}
</code></pre>

<p>}
```</p>

<hr />

<p>至此，这个功能就实现了，这种写法还给了我们更多的启发：可以使用类似的方式添加其他的选项到分享列表中，在activity的onNewIntent回调里面处理这个选项要求实现的任务。这种方式相比起自己去过滤并绘制分享列表要简单很多！欢迎有其他实现方法的同学留言交流！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes(06) - Camera]]></title>
    <link href="http://hukai.me/android-notes-camera/"/>
    <updated>2014-04-21T21:24:00+08:00</updated>
    <id>http://hukai.me/android-notes-camera</id>
    <content type="html"><![CDATA[<p>Android framework为各种不同的Camera与Camera的特色功能提供了支持，使得可以在应用中进行拍照与录像。这篇文章会讨论一种简便，快速的拍照录像方式，为了给用户创建定制的相机体验，文章也会概述相机的高级功能。</p>

<h2>0)开始之前</h2>

<p>在应用中开启Android设备的相机功能之前，应该考量如下几个问题：</p>

<ul>
<li><strong>必须的相机硬件</strong> - 当然不能把一个包含相机功能的应用安装到一个连相机硬件都没有的设备上。因此，应该在mainfest文件中声明需要使用到相机。</li>
<li><strong>快速获取图片还是定制相机</strong> - 应用将如何使用相机？是想做一个快速的抓拍还是录制一小段视频剪辑？还是说想提供一种新的相机使用方式？如果是快速的获取一张抓拍图片或者是一小段视频剪辑，建议查看下面的<strong>3)使用已经安装的相机应用。</strong>如果是为了开发一个定制相机功能的应用，查看下面的<strong>4)创建一个相机应用</strong>。</li>
<li><strong>存储位置</strong> - 生成的图片与视频是只对自己的应用可见还是其它类似Gallery的应用也可以访问？即使自己的应用被卸载后也不能被其他应用访问吗？建议查看<strong>5)保存媒体文件</strong></li>
</ul>


<h2>1)简要概述</h2>

<p>Android framework通过提供Camera API来支持拍照与录制视频的功能。下面是相关的类：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/hardware/Camera.html"><strong>Camera</strong></a><br/>
该类是控制相机硬件的基础的API。它可以用来拍照或者录制视频。</li>
<li><a href="http://developer.android.com/reference/android/view/SurfaceView.html"><strong>SurfaceView</strong></a><br/>
该类是用来呈现一个动态的相机预览界面。</li>
<li><a href="http://developer.android.com/reference/android/media/MediaRecorder.html"><strong>MediaRecorder</strong></a><br/>
该类用来使用相机录制视频。</li>
<li><a href="http://developer.android.com/reference/android/content/Intent.html"><strong>Intent</strong></a><br/>
使用<a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> 或者 <a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a>作为Intent的action可以用来拍照与录制视频。</li>
</ul>


<!-- More -->


<h2>2)Manifest声明</h2>

<p>在使用Camera API开发应用之前，应该确保应用的mainfest中有做恰当的声明，表明需要使用相机或者是相机的相关功能。</p>

<ul>
<li><p><strong>Camera Permission</strong> - 为了使用相机硬件，你的应用必须请求使用Camera的权限。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</code><br/>
<strong>Note:</strong>如果你是通过Intent来使用Camera，你的应用程序则不需要请求这个权限。</p></li>
<li><p><strong>Camera Features</strong> - 你的应用还必须声明使用相机功能，例如：<br/>
<code>xml
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</code><br/>
关于相机功能列表，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">功能引用</a>。增加相机功能到你的mainfest文件，这样Google Play可以阻止那些没有相机硬件或者没有相机特定功能的设备安装你的应用。关于Google Play如何做过滤的信息，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#market-feature-filtering">Google Play and Feature-Based Filtering</a>。<br/>
你还可以为每个相机特性设置<code>android:required</code>的属性，表示这个功能是否为必须的。</p></li>
<li><p><strong>Storage Permission</strong> - 如果你的应用需要保存图片或者视频到设备的外置存储空间(SD card)上，你也需要在manifest中指定存取权限。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
</code></p></li>
<li><p><strong>Audio Recording Permission</strong> - 为了录制音频或者视频，你的程序必须请求audio capture permission。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</code></p></li>
<li><strong>Location Permission</strong> - 如果你的应用需要为图片添加位置信息，你还需要请求location permission:<br/>
<code>xml
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
</code><br/>
关于获取用户位置信息的更多细节，请参考<a href="http://developer.android.com/guide/topics/location/strategies.html">Location Strategies</a>.</li>
</ul>


<h2>3)Using Existing Camera Apps</h2>

<p>在你的应用中快速的实现拍照与录制视频的方法是使用一个Intent来调用已经存在系统中的相机程序。通过已经存在的相机程序拍照或者录制视频，然后返回数据给请求方。这一部分会演示如何使用这种技术。</p>

<p>触发Camera Intent需要遵守如下几个步骤：</p>

<ul>
<li><p><strong>Compose a Camera Intent</strong> - 创建一个请求拍照或者录像的Intent，使用下面的intent类型：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> - 请求拍照的Intent。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a> - 请求录像的Intent。</li>
</ul>
</li>
<li><p><strong>Start the Camera Intent</strong> - 使用<a href="http://developer.android.com/reference/android/app/Activity.html#startActivityForResult(android.content.Intent,%20int">startActivityForResult()</a>)方法来执行这个Intent。在启动这个Intent之后，相机程序会被唤起并提供拍照或者录像的功能。</p></li>
<li><p><strong>Receive the Intent Result</strong> - 在你的程序里面实现<a href="http://developer.android.com/reference/android/app/Activity.html#onActivityResult(int,%20int,%20android.content.Intent">onActivityResult()</a>)的方法用来接收相机程序返回的数据。当用户结束拍照或者录像之后，系统会调用到这个方法。</p></li>
</ul>


<h3>3.1)Image capture intent</h3>

<p>使用Camera Intent是一种使用最少的代码为你的程序开启拍照功能的一种简便的方法。一个拍照程序可以包含下面的附加信息：</p>

<p><strong><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a></strong> - 这定义了一个Uri对象来指定存放图片的路径与文件名。这个设置信息是可选的，但是强烈建议添加。如果你不指定这个值，相机程序会使用默认的文件名保存图片到默认的位置，这个值可以从Intent.getData()的字段中获取到。</p>

<p>下面的示例代码演示了如何构建一个拍照Intent并执行它。<code>getOutputMediaFileUri()</code>方法可以从<strong>Saving Media Files</strong>的段落中涉及到。</p>

<p>```java
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private Uri fileUri;</p>

<p>@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

// create Intent to take a picture and return control to the calling application
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

fileUri = getOutputMediaFileUri(MEDIA_TYPE_IMAGE); // create a file to save the image
intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri); // set the image file name

// start the image capture Intent
startActivityForResult(intent, CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE);
</code></pre>

<p>}
```</p>

<p>当startActivityForResult()方法被执行，用户会看到一个相机拍照的界面。用户执行了拍照(或者取消操作)，用户界面会回退到你的程序，你必须在onActivityResult()方法里面接收返回的数据。关于如何接受完整的intent，可以参考下面的<strong>Receiving camera intent result</strong>段落。</p>

<h3>3.2)Video capture intent</h3>

<p>视频录制的原理和拍照一致。一个视频录制的Intent可以包含如下的参数信息：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a> - 和拍照类似，这里指定保存视频的位置。同样这个字段是可选的，但是也被强烈建议进行填写。如果没有传递这个参数，相机程序会使用默认的文件名保存文件到默认的存储位置。你可以通过在返回的Intent.getData()字段中获取到这个值。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_VIDEO_QUALITY">MediaStore.EXTRA_VIDEO_QUALITY</a> - 这里的值可以为0或者1，分别表示低质量与高质量。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_DURATION_LIMIT">MediaStore.EXTRA_DURATION_LIMIT</a> - 设置这个值用来限制视频的长度，用毫秒计算。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_SIZE_LIMIT">MediaStore.EXTRA_SIZE_LIMIT</a> - 设置这个值用来限制文件的大小，用btye做单位。</li>
</ul>


<p>下面演示了如何构建一个Video Intent并执行：
```java
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;
private Uri fileUri;</p>

<p>@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

//create new Intent
Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);

fileUri = getOutputMediaFileUri(MEDIA_TYPE_VIDEO);  // create a file to save the video
intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);  // set the image file name

intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1); // set the video image quality to high

// start the Video Capture Intent
startActivityForResult(intent, CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE);
</code></pre>

<p>}
```
和拍照类似，也需要在activity的onActivityResult里面去接收数据并做处理。</p>

<h3>3.3)Receiving camera intent result</h3>

<p>一旦你构建并执行了一个拍照或者录像的Intent，你的程序必须确保能够正确接收返回的数据。为了正确的接收到Intent，你必须重写onActivityResult()的方法，下面会演示如何获取到上面示例代码返回的数据。</p>

<p>```java
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;</p>

<p>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {</p>

<pre><code>if (requestCode == CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
        // Image captured and saved to fileUri specified in the Intent
        Toast.makeText(this, "Image saved to:\n" +
                 data.getData(), Toast.LENGTH_LONG).show();
    } else if (resultCode == RESULT_CANCELED) {
        // User cancelled the image capture
    } else {
        // Image capture failed, advise user
    }
}

if (requestCode == CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
        // Video captured and saved to fileUri specified in the Intent
        Toast.makeText(this, "Video saved to:\n" +
                 data.getData(), Toast.LENGTH_LONG).show();
    } else if (resultCode == RESULT_CANCELED) {
        // User cancelled the video capture
    } else {
        // Video capture failed, advise user
    }
}
</code></pre>

<p>}
```</p>

<p>一旦你的activity成功接收了数据，那么你的程序就可以在指定的位置获取到图片或者视频了。</p>

<h2>4)Building a Camera App</h2>

<p>一些开发者也许需要开发一个定制的相机应用，用来提供特殊的功能与体验。创建一个定制的相机界面比起使用Intent需要更多的代码，但是它能够提供一种更加优秀的用户体验。</p>

<p>通常来说创建一个定制化的相机界面有如下几个步骤：</p>

<ul>
<li><strong>Detect and Access Camera</strong> - 检查相机是否存在并可访问。</li>
<li><strong>Create a Preview Class</strong> - 创建一个继承自SurfaceView的preview类，并implement SurfaceHolder的接口的interface。这个类用来预览相机的动态图片。</li>
<li><strong>Build a Preview Layout</strong> - 一旦你拥有了preview class。创建一个Layout用来承载preview并提供交互控制界面。</li>
<li><strong>Setup Listeners for Capture</strong> - 为控制界面建立监听器，用来启动拍照或者录像。</li>
<li><strong>Capture and Save Files</strong> - 建立拍照录像的代码并进行保存。</li>
<li><strong>Release the Camera</strong> - 使用完相机之后，你的程序必须正确的释放它，以便其他程序使用。</li>
</ul>


<p>相机硬件是一个共享资源，它必须被小心谨慎的管理使用。因此你的程序不应该和其他可能使用相机硬件的程序有冲突。下面的段落会介绍如何检测相机硬件，如何请求获取权限，如何拍照录像以及如何在使用完毕时释放相机。</p>

<p><strong>注意:</strong> 当你的程序执行完任务之后，需要记得通过执行Camera.release()来释放相机对象。如果你的相机没有合理的释放相机，后续包括你自己的应用在内的所有的相机应用，都将无法正常打开相机并且可能导致程序崩溃。</p>

<h3>4.1)Detecting camera hardware</h3>

<p>如果你的程序没有在manifest中声明需要使用相机，你应该在运行时去检查相机是否可用。为了执行这个检查，需要使用到<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String">PackageManager.hasSystemFeature()</a>) 方法，如下所示：</p>

<p>```java
/<em>* Check if this device has a camera </em>/
private boolean checkCameraHardware(Context context) {</p>

<pre><code>if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)){
    // this device has a camera
    return true;
} else {
    // no camera on this device
    return false;
}
</code></pre>

<p>}
```</p>

<p>Android设备可以拥有多个摄像头，例如前置与后置摄像头。从Android 2.3 (API Level 9)开始，可以通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#getNumberOfCameras(">Camera.getNumberOfCameras()</a>)方法获取到摄像头的个数。</p>

<h3>4.2)Accessing cameras</h3>

<p>如果你已经判断到程序运行的设备上有摄像头，你需要获取到摄像头的话，需要通过一个相机实例来进行访问。</p>

<p>为了访问到主摄像头，如下所示，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(">Camera.open()</a>)方法。
```java
/<em>* A safe way to get an instance of the Camera object. </em>/
public static Camera getCameraInstance(){</p>

<pre><code>Camera c = null;
try {
    c = Camera.open(); // attempt to get a Camera instance
}
catch (Exception e){
    // Camera is not available (in use or does not exist)
}
return c; // returns null if camera is unavailable
</code></pre>

<p>}
```</p>

<p><strong>注意:</strong> 当使用Camera.open方法时总是需要做检查exceptions的动作。如果没有检查exception，有可能会因为相机正在使用或者相机不存在而使得程序崩溃。</p>

<p>在Android 2.3 (API Level 9)开始, 你可以使用通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(int">Camera.open(int)</a>)方法来访问特定的摄像头。上面演示的代码会优先获取主摄像头。</p>

<h3>4.3)Checking camera features</h3>

<p>一旦你获取到相机，你可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getParameters(">Camera.getParameters()</a>)方法来获取到更多的相机信息。也可以通过获取到的相机参数对象得到相机能够支持的功能。从android 2.3开始，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getCameraInfo(int,%20android.hardware.Camera.CameraInfo">Camera.getCameraInfo()</a>)可以获取到相机是前置还是后置摄像头以及拍摄出来的图片角度。</p>

<h3>4.4)Creating a preview class</h3>

<p>为了给用户提供有效的拍照与录像体验，用户需要能够看到摄像头捕获的数据。相机预览是使用SurfaceView，它能够显示来自摄像头的数据，因此用户可以分割捕获图片或者视频。</p>

<p>下面的示例代码演示了如何创建一个基础的相机预览类，该类可以included到另外一个layout中。为了捕获拍照事件的回调，需要implement<a href="http://developer.android.com/reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a> ，之后可以在这些回调里面进行创建与销毁View的操作。</p>

<p>```java
/<em>* A basic Camera preview class </em>/
public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {</p>

<pre><code>private SurfaceHolder mHolder;
private Camera mCamera;

public CameraPreview(Context context, Camera camera) {
    super(context);
    mCamera = camera;

    // Install a SurfaceHolder.Callback so we get notified when the
    // underlying surface is created and destroyed.
    mHolder = getHolder();
    mHolder.addCallback(this);
    // deprecated setting, but required on Android versions prior to 3.0
    mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
}

public void surfaceCreated(SurfaceHolder holder) {
    // The Surface has been created, now tell the camera where to draw the preview.
    try {
        mCamera.setPreviewDisplay(holder);
        mCamera.startPreview();
    } catch (IOException e) {
        Log.d(TAG, "Error setting camera preview: " + e.getMessage());
    }
}

public void surfaceDestroyed(SurfaceHolder holder) {
    // empty. Take care of releasing the Camera preview in your activity.
}

public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
    // If your preview can change or rotate, take care of those events here.
    // Make sure to stop the preview before resizing or reformatting it.

    if (mHolder.getSurface() == null){
      // preview surface does not exist
      return;
    }

    // stop preview before making changes
    try {
        mCamera.stopPreview();
    } catch (Exception e){
      // ignore: tried to stop a non-existent preview
    }

    // set preview size and make any resize, rotate or
    // reformatting changes here

    // start preview with new settings
    try {
        mCamera.setPreviewDisplay(mHolder);
        mCamera.startPreview();

    } catch (Exception e){
        Log.d(TAG, "Error starting camera preview: " + e.getMessage());
    }
}
</code></pre>

<p>}
```</p>

<p>如果你想为你的相机预览界面设置特定的预览大小，可以在<code>surfaceChanged()</code>的回调里面进行操作(注意上面演示代码的注释)。设置预览大小时，你<strong>必须</strong>使用从<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#getSupportedPreviewSizes(">getSupportedPreviewSizes()</a>)方法获取到的预览值，不能在<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#setPreviewSize(int,%20int">setPreviewSize()</a>)方法里设置随意的预览值。</p>

<h3>4.5)Placing preview in a layout</h3>

<p>在上一段落演示的Camera Preview Class,必须放置在一个activity的layout中。这一段落会演示为了预览如何创建一个基础的layout与activity。</p>

<p>下面的代码提供了一个能够显示相机预览界面的基础layout。在这段代码中，FrameLayout是相机预览类的container。使用framelayout可以在相机预览界面上叠加额外的图片信息或者是操作控制组件。</p>

<p>```xml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:orientation="horizontal"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
&gt;
</code></pre>

<p>  &lt;FrameLayout</p>

<pre><code>android:id="@+id/camera_preview"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:layout_weight="1"
/&gt;
</code></pre>

<p>  &lt;Button</p>

<pre><code>android:id="@+id/button_capture"
android:text="Capture"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_gravity="center"
/&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>在大多数设备上，相机预览的角度默认是横屏的。演示的layout指定了horizontal，并且下面的代码使得activity固定成横屏的模式。</p>

<p>```xml
&lt;activity android:name=".CameraActivity"</p>

<pre><code>      android:label="@string/app_name"

      android:screenOrientation="landscape"&gt;
      &lt;!-- configure this activity to use landscape orientation --&gt;

      &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
</code></pre>

<p></activity>
```</p>

<p><strong>Note:</strong> 相机预览界面不一定是要横屏的。从android 2.2开始，你可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation(int">setDisplayOrientation()</a>)方法来设置预览图片的角度。为了在用户旋转手机时改变相机预览的角度，在<code>surfaceChanged()</code>方法里面，首先要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#stopPreview(">Camera.stopPreview()</a>)停止预览，然后再使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#startPreview(">Camera.startPreview()</a>)方法来重新开启相机预览。</p>

<p>为了在activity中添加相机界面，你的Camera Activity必须确保在activity pause或者是destory的时候释放相机资源。下面的代码演示了如何添加camera preview class到camera activity中。</p>

<p>```java
public class CameraActivity extends Activity {</p>

<pre><code>private Camera mCamera;
private CameraPreview mPreview;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // Create an instance of Camera
    mCamera = getCameraInstance();

    // Create our Preview view and set it as the content of our activity.
    mPreview = new CameraPreview(this, mCamera);
    FrameLayout preview = (FrameLayout) findViewById(R.id.camera_preview);
    preview.addView(mPreview);
}
</code></pre>

<p>}
```</p>

<p><strong>Note:</strong> 上面演示的<code>getCameraInstance()</code>方法出现在4.2)Accessing camera段落中。</p>

<h3>4.6)Capturing pictures</h3>

<p>一旦你建立了preview class并且创建好了显示的layout。那么就可以开始做拍照的动作了。</p>

<p>为了获取到一张图片，需要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#takePicture(android.hardware.Camera.ShutterCallback,%20android.hardware.Camera.PictureCallback,%20android.hardware.Camera.PictureCallback">Camera.takePicture()</a>)方法。为了获取到JPEG格式的图片数据，你必须implement一个<a href="http://developer.android.com/reference/android/hardware/Camera.PictureCallback.html">Camera.PictureCallback</a>接口来接收图片数据并把它写到文件中。</p>

<p>```java
private PictureCallback mPicture = new PictureCallback() {</p>

<pre><code>@Override
public void onPictureTaken(byte[] data, Camera camera) {

    File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
    if (pictureFile == null){
        Log.d(TAG, "Error creating media file, check storage permissions: " +
            e.getMessage());
        return;
    }

    try {
        FileOutputStream fos = new FileOutputStream(pictureFile);
        fos.write(data);
        fos.close();
    } catch (FileNotFoundException e) {
        Log.d(TAG, "File not found: " + e.getMessage());
    } catch (IOException e) {
        Log.d(TAG, "Error accessing file: " + e.getMessage());
    }
}
</code></pre>

<p>};
```</p>

<p>触发拍照的动作，需要使用下面演示到的方法。</p>

<p>```java
// Add a listener to the Capture button
Button captureButton = (Button) findViewById(id.button_capture);
captureButton.setOnClickListener(</p>

<pre><code>new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // get an image from the camera
        mCamera.takePicture(null, null, mPicture);
    }
}
</code></pre>

<p>);
```</p>

<h3>4.7)Capturing videos</h3>

<p>录制视频的内容，暂时跳过，下次再看。</p>

<h3>4.8)Releasing the camera</h3>

<p>相机是被共享的一种资源。获取到一个相机实例之后，程序才可以使用相机，但是，在使用完相机的时候，程序必须小心谨慎的释放它。在程序进入到pause状态时，立即释放相机资源。如果你的程序没有合理的释放相机资源，包括自己程序本身在内，后续所有的相机请求都将失败，甚至可能会导致程序崩溃。下面的代码演示了如何释放相机资源。</p>

<p>```java
public class CameraActivity extends Activity {</p>

<pre><code>private Camera mCamera;
private SurfaceView mPreview;
private MediaRecorder mMediaRecorder;

...

@Override
protected void onPause() {
    super.onPause();
    releaseMediaRecorder();       // if you are using MediaRecorder, release it first
    releaseCamera();              // release the camera immediately on pause event
}

private void releaseMediaRecorder(){
    if (mMediaRecorder != null) {
        mMediaRecorder.reset();   // clear recorder configuration
        mMediaRecorder.release(); // release the recorder object
        mMediaRecorder = null;
        mCamera.lock();           // lock camera for later use
    }
}

private void releaseCamera(){
    if (mCamera != null){
        mCamera.release();        // release the camera for other applications
        mCamera = null;
    }
}
</code></pre>

<p>}
```</p>

<h2>5)Saving Media Files</h2>

<p>用户创建的图片或者视频均需要保存到设备的external storage目录下(SD Card)。可以有多种可能的位置用来保存文件，但是作为一个开发人员，只有下面两种标准的路径进行保存。</p>

<ul>
<li><a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String">Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回用来保存图片与视频所推荐使用的标准共享目录。这个目录是共享开放的，所以其他程序可以轻易的发现，读取并删除这个目录下的文件。如果你的程序被用户卸载，在这个目录下的文件不会被移除。为了避免干扰到用户已经存在的图片与视频目录，你应该为你的程序创建一个子目录。如下面的代码所示。这个方法从Android 2.2 (API Level 8)开始就可以使用。</li>
<li><a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String">Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回一个和你的程序相关联的，用来保存图片与视频的，标准目录。如果你的程序被卸载，在这个目录下的文件也会被一起移除。这个目录并不能阻止其他程序的读写。</li>
</ul>


<p>```java
public static final int MEDIA_TYPE_IMAGE = 1;
public static final int MEDIA_TYPE_VIDEO = 2;</p>

<p>/<em>* Create a file Uri for saving an image or video </em>/
private static Uri getOutputMediaFileUri(int type){</p>

<pre><code>  return Uri.fromFile(getOutputMediaFile(type));
</code></pre>

<p>}</p>

<p>/<em>* Create a File for saving an image or video </em>/
private static File getOutputMediaFile(int type){</p>

<pre><code>// To be safe, you should check that the SDCard is mounted
// using Environment.getExternalStorageState() before doing this.

File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
          Environment.DIRECTORY_PICTURES), "MyCameraApp");
// This location works best if you want the created images to be shared
// between applications and persist after your app has been uninstalled.

// Create the storage directory if it does not exist
if (! mediaStorageDir.exists()){
    if (! mediaStorageDir.mkdirs()){
        Log.d("MyCameraApp", "failed to create directory");
        return null;
    }
}

// Create a media file name
String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
File mediaFile;
if (type == MEDIA_TYPE_IMAGE){
    mediaFile = new File(mediaStorageDir.getPath() + File.separator +
    "IMG_"+ timeStamp + ".jpg");
} else if(type == MEDIA_TYPE_VIDEO) {
    mediaFile = new File(mediaStorageDir.getPath() + File.separator +
    "VID_"+ timeStamp + ".mp4");
} else {
    return null;
}
return mediaFile;
</code></pre>

<p>}
```</p>

<h2>6)Camera Features</h2>

<p>Android提供了控制相机特性的方法，例如图片格式化，闪光灯模式，设置聚焦等等。这一段落列出了通常的相机功能并简短的介绍如何使用这些功能。大多数相机特性可以通过<strong>Camera.Parameters</strong>对象来获取并进行相关的设置。然而，有几个重要的功能不仅仅是通过<strong>Camera.Parameters</strong>能够实现的。请看下面的内容介绍：</p>

<ul>
<li>Metering and focus areas：测光并进行聚焦</li>
<li>Face detection：人脸检测</li>
<li>Time lapse video：延时视频</li>
</ul>


<p>关于上面3个常用的功能会在下面进行更加详细的介绍，除此之外的其他相机功能，请参考下面这张表：</p>

<p><img src="/images/articles/camera_features_table.png" title="Camera Common Features" alt="camera_features_table.png" /></p>

<p><strong>Note:</strong> 因为软硬件的差异性，那些功能并不一定都是支持的。对于检查功能是否可用，请参考下面的Checking feature availability.</p>

<h3>6.1)Checking feature availability</h3>

<p>相机的有些功能在所有手机上并不一定是都支持的。在开发相机应用时就需要提前考虑应该适配到哪个Level。然后开发的时候需要动态的去根据功能是否支持来做不同的处理。</p>

<p>你可以通过获取到相机参数的对象来做检测。下面的例子演示了如何检查autofocus功能是否可用：
```java
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();</p>

<p>List<String> focusModes = params.getSupportedFocusModes();
if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
  // Autofocus mode is supported
}
```</p>

<p>对于大多数的相机特性，都可以使用类型上面的代码来处理。Camera.Parameters对象提供了一系列的类似<code>getSupported...()</code>, <code>is...Supported()</code> 与 <code>getMax...()</code> 方法来判断某个功能是否可用的。</p>

<p>如果你的程序确定需要相机的某个特性，你可以在mainfest文件中就进声明。例如你声明了flash与auto-focus的功能，那么Google Play会阻止那些不支持这些功能的设备安装这个应用。关于相机功能的声明列表，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">Features Reference.</a></p>

<h3>6.2)Using camera features</h3>

<p>前面已经提到过，通过Camera.Parameters对象来操控相机。如下所示：
<code>java
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();
// set the focus mode
params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
// set Camera parameters
mCamera.setParameters(params);
</code>
上面这种方法对大多数相机功能都是可用的，在你获取到相机的实例之后，大多数参数都是在任意时间均可以修改的。参数修改的效果在相机预览的界面是可以立即看到效果的。在软件层面，实际上可能是需要花几帧的时间来产生效果的，因为需要发送指令给相机硬件产生效果。</p>

<p><strong>Important:</strong> 部分功能是不能修改的。特别是，修改相机预览的角度与大小，是需要先停止预览的。从Android Android 4.0 (API Level 14)开始，预览角度可以不用重启预览就可以进行修改。</p>

<p>下面快速的介绍前面提到的3个功能：</p>

<h4>6.2.1）Metering and focus areas</h4>

<p>在某些拍照场景下，自动聚焦与测光并不能拍出我们想要的效果。从Android 4.0 (API Level 14)开始，支持指定特定的区域用来focus与metering。下面的代码演示了如何指定特定的区域用来focus与metering。</p>

<p>```java
// Create an instance of Camera
mCamera = getCameraInstance();</p>

<p>// set Camera parameters
Camera.Parameters params = mCamera.getParameters();</p>

<p>if (params.getMaxNumMeteringAreas() > 0){ // check that metering areas are supported</p>

<pre><code>List&lt;Camera.Area&gt; meteringAreas = new ArrayList&lt;Camera.Area&gt;();

Rect areaRect1 = new Rect(-100, -100, 100, 100);    // specify an area in center of image
meteringAreas.add(new Camera.Area(areaRect1, 600)); // set weight to 60%
Rect areaRect2 = new Rect(800, -1000, 1000, -800);  // specify an area in upper right of image
meteringAreas.add(new Camera.Area(areaRect2, 400)); // set weight to 40%
params.setMeteringAreas(meteringAreas);
</code></pre>

<p>}</p>

<p>mCamera.setParameters(params);
```
<a href="http://developer.android.com/reference/android/hardware/Camera.Area.html">Camera.Area</a>对象包含了2个参数: 一个Rect对象用来指定区域，另外一个是权重用来告诉相机这部分区域的重要性。</p>

<p>Rect的值是基于2000*2000的坐标体系。(-1000, -1000)表示的左上角，(1000, 1000)表示的是右下角。如下图所示：</p>

<p><img src="/images/articles/camera-area-coordinates.png" title="Figure 1. The red lines illustrate the coordinate system for specifying a Camera.Area within a camera preview. The blue box shows the location and shape of an camera area with the Rect values 333,333,667,667." alt="camera-area-coordinates.png" /></p>

<p>这个坐标系统是于相机的可见预览区域相吻合的，不会因为预览效果的放大缩小二改变。同样的，通过Camera.setDisplayOrientation()旋转预览并不会导致坐标系统的变化。</p>

<h4>6.2.2)Face detection</h4>

<p>对于包含人像的图片，头像是最重要的区域。在拍照的时候，这个区域应该用来作为focus与while balance操作的重要参数。从Android 4.0 (API Level 14)开始，系统能够提供API来动态检测人脸并且可以使用人脸识别技术来计算拍照图片的设置参数。</p>

<p><strong>Note:</strong> 当人脸检测功能开启的时候，<code>setWhiteBalance(String)</code>, <code>setFocusAreas(List)</code> 与<code>setMeteringAreas(List)</code>并没有效果。</p>

<p>使用人脸检测功能需要下面的几个步骤：</p>

<ul>
<li>检测在设备上是否有人脸检测的功能。</li>
<li>创建一个人脸检测的监听器。</li>
<li>把这个人脸检测器添加到Camera对象中。</li>
<li>在预览开启之后启动人脸检测(每次预览重启也是)。</li>
</ul>


<p>通过<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#getMaxNumDetectedFaces(">getMaxNumDetectedFaces()</a>)方法来获取设备是否支持检测人脸。如下面的<code>startFaceDetection()</code>方法中演示的：</p>

<p>为了把人脸检测到得结果反馈到界面上，还需要实现检测的监听器，如下所示：
```java
class MyFaceDetectionListener implements Camera.FaceDetectionListener {</p>

<pre><code>@Override
public void onFaceDetection(Face[] faces, Camera camera) {
    if (faces.length &gt; 0){
        Log.d("FaceDetection", "face detected: "+ faces.length +
                " Face 1 Location X: " + faces[0].rect.centerX() +
                "Y: " + faces[0].rect.centerY() );
    }
}
</code></pre>

<p>}
```</p>

<p>创建完这个类之后，需要把这个Listener加到Camera的对象中，如下所示：
<code>java
mCamera.setFaceDetectionListener(new MyFaceDetectionListener());
</code></p>

<p>你得程序必须在每次启动或者重启相机预览的时候开始人脸检测。如下所示：
```java
public void startFaceDetection(){</p>

<pre><code>// Try starting Face Detection
Camera.Parameters params = mCamera.getParameters();

// start face detection only *after* preview has started
if (params.getMaxNumDetectedFaces() &gt; 0){
    // camera supports face detection, so can start it:
    mCamera.startFaceDetection();
}
</code></pre>

<p>}
```</p>

<p>如果使用前面4.4)Creating a preview class段落中提到的预览类，你需要在<code>surfaceCreated()</code> 与 <code>surfaceChanged()</code>方法中执行<code>startFaceDetection()</code>方法。如下所示：
```java
public void surfaceCreated(SurfaceHolder holder) {</p>

<pre><code>try {
    mCamera.setPreviewDisplay(holder);
    mCamera.startPreview();

    startFaceDetection(); // start face detection feature

} catch (IOException e) {
    Log.d(TAG, "Error setting camera preview: " + e.getMessage());
}
</code></pre>

<p>}</p>

<p>public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {</p>

<pre><code>if (mHolder.getSurface() == null){
    // preview surface does not exist
    Log.d(TAG, "mHolder.getSurface() == null");
    return;
}

try {
    mCamera.stopPreview();

} catch (Exception e){
    // ignore: tried to stop a non-existent preview
    Log.d(TAG, "Error stopping camera preview: " + e.getMessage());
}

try {
    mCamera.setPreviewDisplay(mHolder);
    mCamera.startPreview();

    startFaceDetection(); // re-start face detection feature

} catch (Exception e){
    // ignore: tried to stop a non-existent preview
    Log.d(TAG, "Error starting camera preview: " + e.getMessage());
}
</code></pre>

<p>}
```
<strong>Note:</strong> 要在startPreview()方法之后才能开启人脸检测。请不要尝试在onCreate()方法里面启动人脸检测。</p>

<h4>6.2.3)Time lapse video</h4>

<p>Time lapse video使得用户可以通过组合一段时间的图片生成视频片段。这个功能利用了<a href="http://developer.android.com/reference/android/media/MediaRecorder.html">MediaRecorder</a>每隔一段时间来记录一张图片。</p>

<p>为了实现这个功能，你需要像配置一个普通的recorder对象一样。如下面的代码所示：
<code>java
// Step 3: Set a CamcorderProfile (requires API Level 8 or higher)
mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_TIME_LAPSE_HIGH));
...
// Step 5.5: Set the video capture rate to a low number
mMediaRecorder.setCaptureRate(0.1); // capture a frame every 10 seconds
</code>
上面的设置只是对MediaRecorder进行参数设置的一小部分。一旦配置结束，就可以开启视频录制。关于更多的信息，请参考前面的4.7)Capture Video(还没有开始学习)</p>

<p>===</p>

<p>学习自<a href="http://developer.android.com/guide/topics/media/camera.html">http://developer.android.com/guide/topics/media/camera.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes(05) - Tasks and Back Stack]]></title>
    <link href="http://hukai.me/android-notes-task-and-back-stack/"/>
    <updated>2013-04-20T20:42:00+08:00</updated>
    <id>http://hukai.me/android-notes-task-and-back-stack</id>
    <content type="html"><![CDATA[<ul>
<li>所有的activities都归属于一个task。</li>
<li>一个task包含了一些activities，这些activities以用户与他们的交互前后为顺序存放在task中。</li>
<li>Tasks可以把activies放置在background并且保存每一个activites的状态，以便于用户可以切换到其他task而不至于丢失之前的活动状态。</li>
</ul>


<h1>要点概述</h1>

<p>一个程序通常包含了多个actvities。每一个activity都应该围绕用户需要执行的一个特定功能而进行设计，并且可以启动其他的activites。例如:一个邮件程序应该拥有一个显示新邮件的列表。当用户选择其中一封邮件，一个新的activity将打开用来显示邮件内容。</p>

<!-- more -->


<p>一个activity甚至可以启动设备上其他程序的activites。例如：如果你的程序想要发送邮件，你可以定义一个intent来表达你的请求。其他可以接收这个请求的程序则会对这个请求作出响应。当使用其他程序的组件把邮件发送出去之后，你自己的activity将会resume，这样另外一个程序的发邮件组件看起来像是你的程序中的一部分。尽管真正发邮件的activites也许是来自其他不同的程序，Android会通过保存那些activites到同一个task中的方式让用户感觉到无缝的体验。</p>

<p>一个task是用户执行一个确定的动作所会用到的activites的集合。那些activities被安置到一个stack中 (也就是"back stack"), 他们以每个activity被打开的顺序方式存放在stack中。</p>

<p>设备Home界面是大多数tasks的起始点。当用户点击程序在launcher或者Home上的启动图标时，这个程序的task则变成了foreground的。如果程序之前不存在task(程序最近并没有被使用过), 那么一个新的task将被创建并且程序的"main" activity将被打开并作为stack的root activity。</p>

<p>当目前的activity启动另外一个activity时，新的activity被压入栈中作为栈顶并且获取到了focus。前面的那个activity则以stopped的状态继续保留在stack中。当一个activity stops时，系统会保留它的UI状态。当用户点击back按钮时，当前的activity从栈顶退出并被destroyed，之前的activity则resume(之前保存的UI状态得到恢复). 在栈中的Activities的是不会被重新排序的，仅仅是做入栈与出栈的动作。当被启动时入栈，用户点击后退时出栈。下图演示了上面提到的情况：</p>

<p><img src="/images/articles/diagram_backstack.png" title="Figure 1. A representation of how each new activity in a task adds an item to the back stack. When the user presses the Back button, the current activity is destroyed and the previous activity resumes." alt="diagram_backstack.png" /></p>

<p>如果用户持续点击back按钮，那么在栈中的每一个activity都会做退栈并显示之前activity的动作, 直到用户退回到Home界面(或者是用户开始task的地方).当所有的activities都从栈中被移除之后，这个task也就消失了。</p>

<p>一个task是一个紧密结合的单元，当用户开始一个新的task或者通过点击Home按钮回到Home桌面时，之前的task会整体移动到background。当在background时，在task中的所有的activity都是stopped状态的。但是这个task的回退栈仍然保留了与系统交互的特质，仅仅是失去了focus而已。如下图所示：</p>

<p><img src="/images/articles/diagram_multitasking.png" title="Figure 2. Two tasks: Task B receives user interaction in the foreground, while Task A is in the background, waiting to be resumed." alt="diagram_multitasking.png" /></p>

<p>一个task可以返回到"foreground"，这样用户可以从他们离开的地方重新开始操作。例如，当前task(Task A)的栈中有三个activities. 用户点击Home按钮，然后从桌面启动一个新的程序. 当Home界面出现时，Task A变成了background的. 当新的程序启动，系统为它启动一个新的task，里面包含了它自己的activites. 在用户与那个程序交互完之后，重新退回桌面并选择之前启动的task A. 这个时候，Task A重新回到foreground, 在stack中的那三个activities被重新选中，栈顶的那个activity被resume. 此时，用户仍然可以选择通过切回Home，再次启动task B.( 或者通过长按Home按钮触发最近使用的task界面进行选择). 这便是Android中的多任务的一个例子.</p>

<p><strong>Note:</strong> 众多tasks都可以一并在后台被Hold住。然而，如果用户同时执行了多个后台任务，系统便会为了恢复内存而开始销毁后台activities. 这会导致activity状态丢失. 关于着部分内容，请看下面的Activity state部分.</p>

<p>因为在back stack中的activities是不会被重新调整顺序的。如果你的程序中的某个特定的activity可以被多个activity所叫起，那么将会为那个特定activity创建一个新的实例并压入栈中(而不是把那个activity之前的实例移动到栈顶). 如下图所示:你程序中的一个activity可以被多次实例化(即使是在不同的task中)。如果用户通过点击Back按钮回退，每一个实例都将以他们被打开的顺序依次被重新呈现。然而，如果你不想一个activity被重复实例化，你可以修改这种行为。关于如何修改这种行为，将在下面的Managing Tasks中讲到.</p>

<p><img src="/images/articles/diagram_multiple_instances.png" title="Figure 3. A single activity is instantiated multiple times." alt="diagram_multiple_instances.png" /></p>

<p><strong>总结一下系统默认的activities与tasks的行为:</strong></p>

<ul>
<li>当Activity A启动Activity B时, Activity A会是stopped, 但是系统会保存它的状态(例如scroll的位置与填表格的文字). 如果用户在activity B时点击Back按钮，那么activity A会恢复它之前保存的状态信息.</li>
<li>当用户通过点击Home按钮离开一个task时，当前的activity会是stopped并且它的task会退到background. 系统保留task中的每一个activity. 如果用户之后通过点击启动图标来重新叫起它,task会成为foreground的并且栈顶的activity会得到恢复.</li>
<li>如果用户点击Back按钮, 当前activity会从栈中退出并被destroyed. 在栈中的前一个activity得到resumed. 当一个activity被destroyed, 系统不会再保留activity的状态信息.</li>
<li>Activities可以被多次实例化，即使是请求来自其他tasks.</li>
</ul>


<h1>Saving Activity State(保存Activity状态)</h1>

<p>正如上面提到的，当activity stopped时，系统默认会保存它的状态. 这样的话, 当用户回退到之前的activity, 它的UI将和离开时一致. 然而, 如果activity被destoryed并且需要recreated时，你可以并且应该主动使用activity的callback方法来保存它的状态信息.</p>

<p>当系统stop你的某个activity时, 系统可能会在需要恢复内存时destory那个stop状态的activity. 当发生这件事时，关于activity的状态信息则会丢失. 即使真的发生那样的情况, 系统仍然为那个activity在back stack中保留了位置, 但是当这个activity成为栈顶activity时, 系统必须recreate它(而不是resume它). 为了避免丢失用户的工作内容, 你应该主动通过实现<a href="http://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle">onSaveInstanceState()</a>)回调方法来保存那些信息.</p>

<p>想了解更多关于如何保存activity的状态，请参考<a href="http://developer.android.com/guide/components/activities.html#SavingActivityState">Activities</a>.</p>

<h1>Managing Tasks(管理Tasks)</h1>

<p>Android系统默认的管理tasks与back stack的方法使用于大部分情况, 对于大多数程序来说, 你不需要担心你的activites是如何与task进行联系的，它们又是如何存放在back stack中的. 但是你可能想要打断通常的行为, 可能你想要在你的程序中的某个activity被启动时会创建一个新的task而不是放置到旧的task中; 或者, 当你启动一个activity，你想要把已经存在的某个实例放置到栈顶(而不是在栈顶创建一个新的实例); 又或者说, 你想要在用户退出task时除了根activity之外清除栈中其它的activities.</p>

<p>你可以通过在manifest的<activity>标签下设置属性，并且在把intent传递给startActivity()方法之前为intent设置flag.</p>

<p>关于此事, 在<activity>标签下可以设置的主要属性为:<br/>
* taskAffinity
* launchMode
* allowTaskReparenting
* clearTaskOnLaunch
* alwaysRetainTaskState
* finishOnTaskLaunch</p>

<p>你可以为intent设置flag的主要值有:<br/>
* FLAG_ACTIVITY_NEW_TASK
* FLAG_ACTIVITY_CLEAR_TOP
* FLAG_ACTIVITY_SINGLE_TOP</p>

<p>下面将会讲解如何使用上面定义的方法<br/>
<strong>Caution:</strong> 大多数程序不应该打断系统默认的activities与tasks之间的行为. 如果你确定有必要修改默认的行为, 请谨慎使用并确保用户切换与回退的行为是可用正常的. 请确保你的设计行为不会对用户期待的体验有冲突.</p>

<h2>(0)Defining launch modes(定义启动模式)</h2>

<p>启动模式允许你定义一个activity的实例与当前task是如何结合的. 你可以用下面两种方式来定义不同的启动模式:</p>

<ul>
<li><p><strong>Using the manifest file</strong><br/>
当你在manifest文件中定义一个activity时，你可以指定当它启动时与task的结合方式.</p></li>
<li><p><strong>Using Intent flags</strong><br/>
当你调用startActivity(), 你可以对intent进行设置flag来表示这个activity将与task如何进行结合.</p></li>
</ul>


<p>像这样, 如果Activity A 启动 Activity B, 那么Activity B 可以在它的manifest中定义它应该如何与当前的task进行联合，同样Activity A 也可以请求Activity B 应该如何与当前task进行结合. <strong>如果两个都有定义，那么A的请求(定义在Intent中的)的优先级比B的请求(定义在manifest中)要更高</strong>.</p>

<p><strong>Note:</strong>某些可以定义在manifest中的启动模式并不一定在intent flag中可以找到对应的方式. 同样,某些在intent flag中可以找到的并不一定可以在manifest中进行设置.</p>

<h3>Using the manifest file</h3>

<p>在manifest的<activity>标签下设置<strong>launchMode</strong>属性，一共可以设置下面4种类型的启动模式:</p>

<hr />

<ul>
<li><strong>"standard"</strong> (the default mode)</li>
</ul>


<p>系统默认的启动模式. 系统在task中创建一个新的实例，activity可以被多次实例化. 每一个实例可以属于不同的task, 同样一个task可以有多个实例.</p>

<ul>
<li><strong>"singleTop"</strong></li>
</ul>


<p>如果activity的实例已经存在于当前task的栈顶, 系统会通过调用它的onNewIntent()方法把intent导向那个实例, 而不是为那个activity创建新的实例. activity可以被多次实例化，每一个实例可以属于不同的tasks, 同样一个task可以有多个实例 (仅仅当目前栈顶activity不是那个activity时才行，否则栈顶元素就是想要创建的activity的实例的话，则不会重复创建).</p>

<p>例如, 某个栈中的元素由root至top依次为activity A-B-C-D; Acivity D是栈顶. 一个intent来到activity D中. 如果D是默认的"standard"启动模式, 那么stack则会变成A-B-C-D-D. 然而, 如果D的启动模式是"singleTop", 那么D将通过onNewIntent()来接受那个intent, 栈结构仍然是A-B-C-D. 然而, 如果Activity B接受到一个intent, 那么即使现在是single top模式，仍然会创建一个新的B加入到栈中.(A-B-C-D-B)</p>

<p><strong>Note:</strong> 当一个activity的实例被创建时，用户可以点击Back按钮来回退到之前的activity. <strong>但是当已经存在的某个实例需要处理一个新的intent时，用户在这个intent还没有到达onNewIntent()方法之前是没有办法通过点击back按钮来回退的.</strong></p>

<ul>
<li><strong>"singleTask"</strong></li>
</ul>


<p>系统会创建一个新的task并把实例化的activity作为task的root元素(这个task还可以继续添加其他activity的实例). <strong>然而, 如果这个activity的实例已经存在于另外一个task中，系统会通过调用onNewIntent()方法把intent导向已经存在的实例中, 而不是创建一个新的实例. 某一时刻，activity的实例只能存在一个.</strong></p>

<p><strong>Note:</strong>尽管activity是在一个新的task中被启动的, Back按钮仍然是可以回退到上一个activity的.</p>

<ul>
<li><strong>"singleInstance".</strong></li>
</ul>


<p>除了系统不会再对拥有的那个activity的task添加新的其他实例之外，与"singleTask"是类似的. activity的实例总是唯一的，并且是task中唯一的一个元素. 并且task是新创建的.</p>

<hr />

<p>另外一个例子, Android的Browser程序通过为web browser activity在manifest中指定singleTask模式定义了activity总是在它自己的taks中打开. 这意味着，如果你的程序定义了一个intent来打开Android Browser, 它的activity并不是在你的程序task中被打开的. 要么为browser启动一个新的task，要么把browser正在后台允运行的task带到forgound来处理那个Intent.<br/>
<strong>???</strong>(<em>奇怪，前面不是说intent请求的优先级比manifest中的要高吗？这里怎么会这样？</em>)</p>

<p>不管是启动一个新的task还是在原来的task中，Back按钮都可以回退到前面的activity. 然而，如果你启动的activity的launch mode定义为singleTask, 然后如果那个activity的某个实例已经存在于一个background的task中，那么这个background的task的所有activites会<strong>整个全部</strong>被带到foreground的. 下图Figure 4 演示了这种情况：</p>

<p><img src="/images/articles/diagram_backstack_singletask_multiactivity.png" title="Figure 4. A representation of how an activity with launch mode &quot;singleTask&quot; is added to the back stack. If the activity is already a part of a background task with its own back stack, then the entire back stack also comes forward, on top of the current task." alt="diagram_backstack_singletask_multiactivity.png" /></p>

<p><strong>Note:</strong> 通过manifest中launchMode属性设置的方式定义的启动模式可以被intent中的flag所覆盖，请看下面的解释.</p>

<h3>Using Intent flags</h3>

<ul>
<li><p>FLAG_ACTIVITY_NEW_TASK<br/>
在新的task中启动activity. 如果你要启动的activity已经存在于某个运行的task中, 那么这个task会整个被提升为foregound的，activity会通过onNewIntent()来接收intent.这部分的行为与singleTask启动模式是一致的.</p></li>
<li><p>FLAG_ACTIVITY_SINGLE_TOP<br/>
如果在栈顶的activity接受到这样的intent, 那么已经存在于栈顶的实例会通过onNewIntent()来获取intent, 而不是创建一个新的实例. 这部门的行为与singleTop启动模式是一致的.</p></li>
<li><p>FLAG_ACTIVITY_CLEAR_TOP<br/>
如果被启动的activity已经存在于当前运行的task中, 不是为那个activity启动一个新的实例，而是在这个activity实例之上的activities都被destoryed，intent被通过onNewIntent()传递到这个实例中，并且这个时候，它就成了栈顶元素. 这个行为在launchMode的属性中并没有对应的值.<br/>
FLAG_ACTIVITY_CLEAR_TOP通常与FLAG_ACTIVITY_NEW_TASK同时使用. 当他们结合一起时，那意味着把已经存在的activity放置到另外一个task中并且把它作为栈顶元素开始与用户进行交互.</p></li>
</ul>


<p><strong>Note:</strong>如果被启动的activity的launch mode是"standard", 那么这个activity同样会被先清除掉，然后创建一个新的实例来接受intent. 那是因为当launch mode是standard时，新的实例总是为了新的intent而被创建.</p>

<h2>(1)Handling affinities(处理联姻关系)</h2>

<p>Affinity(联姻)意味着activity更倾向归属于哪一个task. 默认的，来自同一程序的所有的activities会拥有同样的联姻关系. 因此，他们更倾向于处于同一个task中. 然而, 你可以修改这种默认的行为. 在不同程序中的activites可以有同样的联姻关系，或者同一程序中的不同activites可以分配到不同的task联姻关系中</p>

<p>可以在manifest的activity中设置taskAffinity属性，一共有下面两种情况：</p>

<ul>
<li>When the intent that launches an activity contains the FLAG_ACTIVITY_NEW_TASK flag.</li>
</ul>


<p>A new activity is, by default, launched into the task of the activity that called startActivity(). It's pushed onto the same back stack as the caller. However, if the intent passed to startActivity() contains the FLAG_ACTIVITY_NEW_TASK flag, the system looks for a different task to house the new activity. Often, it's a new task. However, it doesn't have to be. If there's already an existing task with the same affinity as the new activity, the activity is launched into that task. If not, it begins a new task.<br/>
If this flag causes an activity to begin a new task and the user presses the Home button to leave it, there must be some way for the user to navigate back to the task. Some entities (such as the notification manager) always start activities in an external task, never as part of their own, so they always put FLAG_ACTIVITY_NEW_TASK in the intents they pass to startActivity(). If you have an activity that can be invoked by an external entity that might use this flag, take care that the user has a independent way to get back to the task that's started, such as with a launcher icon (the root activity of the task has a CATEGORY_LAUNCHER intent filter; see the Starting a task section below).</p>

<ul>
<li>When an activity has its allowTaskReparenting attribute set to "true".</li>
</ul>


<p>In this case, the activity can move from the task it starts to the task it has an affinity for, when that task comes to the foreground.<br/>
For example, suppose that an activity that reports weather conditions in selected cities is defined as part of a travel application. It has the same affinity as other activities in the same application (the default application affinity) and it allows re-parenting with this attribute. When one of your activities starts the weather reporter activity, it initially belongs to the same task as your activity. However, when the travel application's task comes to the foreground, the weather reporter activity is reassigned to that task and displayed within it.</p>

<p><strong>Tip:</strong> 如果一个.apk文件从用户的角度看包含了不止一个"application"的话，你可能会想要使用taskAffinity属性来为那些activites设置不同的联姻关系.</p>

<h2>(2)Clearing the back stack(清除回退栈)</h2>

<p>如果用户长时间离开一个task, 系统会清除task中root activity之外的所有的activites. 当用户回退到task时，仅仅只有root activity会被恢复.</p>

<p>有下面一些值可以用来设置，如果你想修改系统默认的行为的话:</p>

<ul>
<li><p><strong>alwaysRetainTaskState</strong><br/>
设置了这个属性为true之后，即使很长时间，也不会被destory的</p></li>
<li><p><strong>clearTaskOnLaunch</strong><br/>
如果这个属性设置为true，那么就是与alwaysRetainTaskState相反的. 每次启动都会清除root以上的activities.</p></li>
<li><p><strong>finishOnTaskLaunch</strong><br/>
这个属性与clearTaskOnLaunch类似, 但是它仅仅是对单个activity进行操作，而不是整个task. It can also cause any activity to go away, including the root activity. When it's set to "true", the activity remains part of the task only for the current session. If the user leaves and then returns to the task, it is no longer present.</p></li>
</ul>


<h2>(3)Starting a task(启动一个任务)</h2>

<p>你可以启动一个activity作为一个task的起点，通过为它的intent filter设置"android.intent.action.MAIN"作为特定的action，设置"android.intent.category.LAUNCHER"作为特定的category. 例如：
```xml
<activity ... ></p>

<pre><code>&lt;intent-filter ... &gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
...
</code></pre>

<p></activity>
```
上面的设置方式不仅仅是使得这个activity作为launcher的图标，允许用户通过点击它启动activity并且随时通过点击它来触发恢复之前的task.</p>

<p>第二点非常重要: 用户必须能够在离开task之后通过activity的launcher来回到task. 因为这点, "singleTask" 与 ""singleInstance" 这两种启动模式总是会初始化一个task, 需要有ACTION_MAIN 与 CATEGORY_LAUNCHER 配合. 例如，用户启动了一个task做了一些动作，然后点击Home回到桌面，这个时候想要回到刚才的task，需要有launcher作为入口.</p>

<p>对于那些你不想用户可以回退的情况，请设置<activity>标签下的finishOnTaskLaunch属性为"true" (参考上面的章节).</p>

<hr />

<p><strong>文章学习自<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html">http://developer.android.com/guide/components/tasks-and-back-stack.html</a></strong><br/>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
</feed>
