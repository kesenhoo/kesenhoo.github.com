<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[胡凯]]></title>
  <link href="http://hukai.me/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2018-07-19T00:13:40+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[HuKai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Jetpack - 使用WorkManager处理简单的后台任务]]></title>
    <link href="http://hukai.me/google-io-2018-android-jetpack-workmanager/"/>
    <updated>2018-05-28T23:24:00+08:00</updated>
    <id>http://hukai.me/google-io-2018-android-jetpack-workmanager</id>
    <content type="html"><![CDATA[<p>时间来到2018年的当下，当我们讨论后台处理任务的时候，一般可能涉及的行为类型有下面一些类型，例如：</p>

<ul>
<li>发送程序运行日志</li>
<li>上传图片和视频</li>
<li>同步数据</li>
<li>处理数据</li>
</ul>


<p>这些行为都需要在后台进行操作，在Android平台上，我们可以利用如下的这些可选方式来实现后台任务：</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_01.png" alt="google_io_2018_android_jetpack_workmanager_01" /></p>

<p>那么到底我们如何做出合理的选择呢？过去的几年，Android系统随着版本的更新针对电量优化这一块做出了不同程度的限制优化，例如在Android M上的<code>Doze Mode</code>，Android N上的<code>Limit Implicit  Broadcast</code>，Android O上的<code>Background Service Limitations</code>以及最新的Android P上面的<code>App Standby Buckets</code>。为了确保后台任务对电量的消耗影响足够小，对待后台任务的处理要更加的慎重小心。</p>

<h2>0）Types of Background Work</h2>

<p>通常来说，我们可以把所有的后台任务按照任务紧迫性(是马上需要执行的任务/还是可以缓期执行的任务)和任务重要性(是确保一定要被执行的任务/还是最好能够执行的任务)进行四象限的划分。通常来说对于非确保一定要执行的任务，无论时间是否紧迫，我们都可以使用ThreadPool来完成这个任务。对于那些比较重要的又时间紧迫的任务，我们一般会使用Foreground Service来完成这个操作。比较有有意思的是最后一个象限：那些希望确保可以被执行但是又可以接受延期执行的任务。这些任务可以使用JobScheduler/JobDispatcher/AlarmManager/BroadcastReceivers来完成。WorkManager也刚好是用来解决这一类的问题的。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_02.png" alt="google_io_2018_android_jetpack_workmanager_02" /></p>

<!-- More -->


<h2>1）WorkManager Features</h2>

<p>下面是WorkManager的一些突出特点：</p>

<ul>
<li>确保可以被执行，并且可以设置执行的限定条件(例如仅仅在有网络连接的时候才进行图片的上传)</li>
<li>同样受到系统后台任务的限制管理(如APP进入Doze Mode的时候，任务不会被执行)</li>
<li>向后兼容；无论是否集成了Google Play Service服务，都是向后兼容的</li>
<li>任务可查询；如论当下在执行什么任务，都是可以直接查询获取到任务状态信息的(例如正在运行的状态是什么，结果是成功还是失败了)</li>
<li>任务可串联；例如执行任务A之前需要任务B或者C先进行完成</li>
<li>任务伺机执行：在条件满足的时候会尽快尝试触发任务的执行，不需要等待JobScheduler的唤醒，也不会需要等待JobScheduler进行批量任务处理的才被执行</li>
</ul>


<p>WorkManager中的核心类有：</p>

<ul>
<li>Worker：这个类是真正干活的，工作逻辑都在这里面</li>
<li>WorkRequest：

<ul>
<li>OneTimeWorkRequest：只执行一次的任务请求</li>
<li>PeriodicWorkRequest：重复执行的任务请求</li>
</ul>
</li>
</ul>


<p>举个例子：图片上传的后台任务是如何执行的。下面是上传图片的Worker示例：</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_03.png" alt="google_io_2018_android_jetpack_workmanager_03" /></p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_04.png" alt="google_io_2018_android_jetpack_workmanager_04" /></p>

<p>其中uploadPhoto是执行在后台线程的，返回值可以是成功或者失败，还可以是重试，这意味着告诉系统这个任务需要后面找机会重新执行。有了上面那些基础，接下去就只需要利用Worker创建对应的WorkRequest，并并添加到WorkManager的执行队列中就好了。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_05.png" alt="google_io_2018_android_jetpack_workmanager_05" /></p>

<p>正常情况下，放到任务队列中的任务会被立马执行，可是如果遇到网络连接失败的情况，这样就会执行失败。此时我们就可以通过添加限定执行条件来达到优化的目的，例如设置限定只在网络连接成功的时候才进行任务的执行。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_06.png" alt="google_io_2018_android_jetpack_workmanager_06" /></p>

<h2>2）Observing Work</h2>

<p>有了上面的任务触发逻辑之后，那么如何做任务的监听呢？例如正在处理过程中显示一个进度圈，处理成功的时候消失进度等等。我们可以使用如下演示的范例来监听任务的执行状态。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_07.png" alt="google_io_2018_android_jetpack_workmanager_07" /></p>

<p><code>LiveData</code>是Google开发的一个感知生命周期的架构组件。使用这个组件来hook监听request任务的<code>WorkStatus</code>。在WorkStatus里面有任务的id和status，其中status有6种状态，分别是<code>ENQUEUED</code>,<code>RUNNING</code>,<code>SUCCEEDED</code>,<code>FAILED</code>,<code>BLOCKED</code>,<code>CANCELLED</code>。</p>

<h2>3）Chaining Work</h2>

<p>通常来说，上传任务真正被执行之前，我们会对数据做一次压缩，因为每一个任务都需要在后台进行，并且需要保证执行顺序。我们可以使用下面的示例方式，先进行压缩，成功之后，再进行上传。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_08.png" alt="google_io_2018_android_jetpack_workmanager_08" /></p>

<p>只所以可以类似上面那样写，是因为每一步任务返回的都是<code>WorkContinuation</code>，使用它可以对不同的任务进行串联。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_09.png" alt="google_io_2018_android_jetpack_workmanager_09" /></p>

<p>如果想要多项任务并发执行，可以同时建立多个WorkRequest，一起交给WorkManager进行执行(根据CPU核心数和架构的不同，并发数量有所差异)。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_10.png" alt="google_io_2018_android_jetpack_workmanager_10" /></p>

<p>我们再把任务链设置的更加复杂一点，例如图片要先分别经过不同的滤镜处理，之后再进行压缩，最后才可以上传，那么使用WorkManager该如何实行呢？</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_11.png" alt="google_io_2018_android_jetpack_workmanager_11" /></p>

<h2>4）Inputs and Outputs</h2>

<p>任务之间如何进行数据的传递呢？在介绍这个之前，我们需要了解下什么叫做MapReduce。例如，我们想要从三本书里面找出使用最多的词语，先把所有词语都进行计算一遍，然后对词语的使用次数进行排序，最后才可以找出使用最多的词语，我们把这个行为叫做MapReduce。</p>

<p>使用WorkManager的输入和输出数据具备如下的特点：</p>

<ul>
<li>简单的KEY-VALUE

<ul>
<li>KEY都是String类型的</li>
<li>VALUE可以是基础数据类型和String</li>
</ul>
</li>
<li>数据本身已经做了序列化处理</li>
<li>限定10KB大小以内</li>
</ul>


<p>我们使用如下的方式进行输入的数据传递，构造一个map类型的Data，通过WorkManager的<code>setInputData()</code>给Worker进行传输数据。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_12.png" alt="google_io_2018_android_jetpack_workmanager_12" /></p>

<p>接下去Worker可以通过<code>getInputData()</code>来获取到输入的数据。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_13.png" alt="google_io_2018_android_jetpack_workmanager_13" /></p>

<p>一般来说，我们会需要把处理的结果进行返回，那么使用<code>setOutputData()</code>来完成这个操作就可以了</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_14.png" alt="google_io_2018_android_jetpack_workmanager_14" /></p>

<p>有意思的事情是，在任务链中，输出的数据一般就是下一个任务的输入。那么当某个环节的一个任务是由多个任务的输出构成的时候，改如何处理呢？</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_15.png" alt="google_io_2018_android_jetpack_workmanager_15" /></p>

<p>为了解决这个问题，我们需要了解<code>InputMergers</code>，顾名思义，它是用来合并多个输入数据变成一个的。一般来说有两种合并实现的方式(也可以自己自定义)</p>

<ul>
<li><code>OverwritingInputMerger</code>(系统默认)：按照输入数据的先后顺序，相同KEY会被覆盖，不同的KEY内容会被保留</li>
</ul>


<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_16.png" alt="google_io_2018_android_jetpack_workmanager_16" /></p>

<ul>
<li><code>ArrayCreatingInputMerger</code>：相同KEY的VALUE值进行合并，需要确保VALUE是相同数据类型的，否者会出现异常</li>
</ul>


<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_17.png" alt="google_io_2018_android_jetpack_workmanager_17" /></p>

<h2>5）Cancelling Work</h2>

<p>想要取消一个任务，只需要调用<code>cancelWorkById()</code>就好了，但是需要注意的是，这个方法只是<strong>尽力而为</strong>，因为相关想要取消的任务有可能已经在运行，也有可能已经执行结束了。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_18.png" alt="google_io_2018_android_jetpack_workmanager_18" /></p>

<h2>6）Tags</h2>

<p>前面我们有提到过好几次任务id，这个id是系统自动生成的，类似UUID这样的数值。我们无法通过这个id来判断这是一个什么样的任务，tags就是为了解决这个任务可读性的问题的。我们可以给任务打上一个或者多个tag来标记这是一个什么样的任务，然后可以通过这个tag来查询，取消任务等等。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_19.png" alt="google_io_2018_android_jetpack_workmanager_19" /></p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_20.png" alt="google_io_2018_android_jetpack_workmanager_20" /></p>

<p>使用Tag可以给我们提供很大的帮助，我们可以根据不同的模块和依赖给任务设置不同的tag，也可以根据任务的类型进行设置tag，这样就可以方便的进行批量任务操作了。</p>

<h2>7）Unique Work</h2>

<p>为了解决多个任务的同步问题，引入了Unique Work的机制。它有三种类型，分别为</p>

<ul>
<li><code>KEEP</code>：新启动的Unique任务，如果之前已经存在，就继续保留旧的任务，如果不存在，则触发这次新的任务</li>
</ul>


<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_21.png" alt="google_io_2018_android_jetpack_workmanager_21" /></p>

<ul>
<li><code>REPLACE</code>：取消或者删除之前的所有此类Unique任务，使用这次的任务作为最新任务，重复调用多次的时候，会以最后一次为准</li>
</ul>


<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_22.png" alt="google_io_2018_android_jetpack_workmanager_22" /></p>

<ul>
<li><code>APPEND</code>：按照添加顺序，逐个执行任务</li>
</ul>


<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_23.png" alt="google_io_2018_android_jetpack_workmanager_23" /></p>

<h2>8）Periodic Work</h2>

<p>重复任务和我们之前认知的其他重复任务一样，具备一些如下的特点：</p>

<ul>
<li>最短间隔时间15分钟(和JobScheduler一样)</li>
<li>同样受系统doze mode和其他的后台任务限制</li>
<li>不可以有任务链</li>
<li>不可以有触发延迟</li>
</ul>


<h2>9）Under The Hood</h2>

<p>当系统接受到一个Work任务的时候，会先记录到自己的任务数据库中，接下去系统是如何判断执行的呢？如果任务符合当下执行的条件，那么会由Executor(可自定义，系统默认有实现)立即执行；如果我们的进程已经被杀死，那么任务什么时候可以被执行呢？如果设备运行在>=API 23，会交给JobScheduler触发IPC请求，唤醒我们的进程进行任务的执行；如果设备运行在&lt; API 23的情况下，系统会判断设备是否有Firebase JobDispatcher，如果有会交给它进行处理；如果那些Google Play Service服务都没有，系统会使用AlarmManager和BroadcastReceivers的方式在合适的时候唤醒应用进行处理。</p>

<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_24.png" alt="google_io_2018_android_jetpack_workmanager_24" /></p>

<h2>10）Best Practice</h2>

<ul>
<li>何时使用WorkManager呢？下面给一些最佳实践的例子：

<ul>
<li>OK：上传图片和视频</li>
<li>OK：解析数据并存储到数据库中</li>
<li>NO：从调色板中获取颜色并设置到图片上</li>
<li>NO：解析数据并呈现到视图上进行显示</li>
<li>NO：处理交易的请求</li>
</ul>
</li>
<li>不要使用WorkManager来存储数据，记得只有10kb的限制</li>
<li>记得给不同的任务设置各自的执行限定条件，避免无谓的资源浪费</li>
</ul>


<p><img src="http://hukai.me/images/google_io_2018_android_jetpack_workmanager_25.png" alt="google_io_2018_android_jetpack_workmanager_25" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android相机开发 - 1)基础概览篇]]></title>
    <link href="http://hukai.me/android-dev-camera-basics/"/>
    <updated>2017-01-30T21:24:00+08:00</updated>
    <id>http://hukai.me/android-dev-camera-basics</id>
    <content type="html"><![CDATA[<p>在Android平台上面实现自定义相机，根据业务的复杂度，涉及到的知识范畴大致如下，开篇优先描述下基础概览的部分:</p>

<p><img src="http://hukai.me/images/android_dev_custom_camera_basic.jpeg" alt="android_dev_custom_camera_basic.jpeg" /></p>

<h2>0)开始之前</h2>

<p>在应用中开启Android设备的相机功能之前，应该考虑如下几个问题：</p>

<ul>
<li><strong>必须的相机硬件</strong> - 当然不能把一个包含相机功能的应用安装到一个连相机硬件都没有的设备上。因此，应该在mainfest文件中声明需要使用到相机。</li>
<li><strong>快速获取图片还是自定义相机</strong> - 应用将如何使用相机？是想实现一个快速的抓拍功能还是录制一小段视频剪辑？还是说想提供一种全新的相机使用方式？如果是快速的获取一张抓拍图片或者是一小段视频剪辑，建议查看下面的<strong>3)使用已经存在的相机应用。</strong>如果是为了开发一个自定义的相机功能的应用，查看下面的<strong>4)创建自定义相机应用</strong>。</li>
<li><strong>存储位置</strong> - 生成的图片与视频是只对自己的应用可见还是其它相册Gallery类的应用也可以访问？即使自己的应用被卸载后也不能被其他应用访问吗？建议查看<strong>5)保存媒体文件</strong></li>
</ul>


<h2>1)简要概述</h2>

<p>Android framework通过提供Camera API来支持拍照与录制视频的功能。下面是相关的类：</p>

<ul>
<li><a href="https://developer.android.com/reference/android/hardware/camera2/package-summary.html"><strong>android.hardware.camera2</strong></a><br/>
这里列举了控制相机的核心API，使用它可以实现拍照和录制视频的功能。</li>
<li><a href="https://developer.android.com/reference/android/hardware/Camera.html"><strong>Camera</strong></a><br/>
该类是已经被废弃的控制相机的基础的API。</li>
<li><a href="http://developer.android.com/reference/android/view/SurfaceView.html"><strong>SurfaceView</strong></a><br/>
该类用来呈现一个动态的相机预览界面。</li>
<li><a href="http://developer.android.com/reference/android/media/MediaRecorder.html"><strong>MediaRecorder</strong></a><br/>
该类用来使用相机录制视频(后续的文章中都不会对视频录制的部分进行过多描述，不属于该系列文章的主要讨论范畴)</li>
<li><a href="http://developer.android.com/reference/android/content/Intent.html"><strong>Intent</strong></a><br/>
使用<a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> 或者 <a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a>作为Intent的action可以用来拍照与录制视频。</li>
</ul>


<!-- More -->


<h2>2)AndroidManifest.xml声明</h2>

<p>在使用Camera API开发应用之前，应该确保应用的mainfest中有做恰当的权限声明，表明此应用需要使用相机或者是相机的相关功能。</p>

<ul>
<li><strong>Camera Permission</strong> - 为了使用相机硬件，你的应用必须请求使用Camera的权限。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">&quot;android.permission.CAMERA&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<strong>Note:</strong>如果你是通过Intent来调用其他已经存在的Camera应用，自己的应用程序是不需要声明这个权限的。</p>

<ul>
<li><strong>Camera Features</strong> - 你的应用还必须声明使用相机功能，例如：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;uses-feature</span> <span class="na">android:name=</span><span class="s">&quot;android.hardware.camera&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
关于相机功能列表，请参考<a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">功能引用</a>。增加相机功能到你的mainfest文件，这样Google Play可以阻止那些没有相机硬件或者没有相机特定功能的设备安装你的应用。关于Google Play如何做过滤的信息，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#market-feature-filtering">Google Play and Feature-Based Filtering</a>(关于这一点，国内的分发市场暂时都没有做一条的过滤)。你还可以为每个相机特性设置<code>android:required</code>的属性，表示这个功能是否为必须的。</p>

<ul>
<li><strong>Storage Permission</strong> - 如果你的应用需要保存图片或者视频到设备的外置存储空间(SDCard)上，你也需要在manifest中指定存储的读写权限。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Location Permission</strong> - 如果你的应用需要为图片添加位置信息，你还需要请求location permission，如果应用需要执行在Android 5.0及更高的的版本上，还需要声明GPS权限。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>...
</span><span class='line'><span class="c">&lt;!-- Needed only if your app targets Android 5.0 (API level 21) or higher. --&gt;</span>
</span><span class='line'><span class="nt">&lt;uses-feature</span> <span class="na">android:name=</span><span class="s">&quot;android.hardware.location.gps&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>关于获取用户位置信息的更多细节信息，请参考<a href="https://developer.android.com/guide/topics/location/strategies.html">Location Strategies</a>。</p>

<h2>3)使用已经存在的相机应用</h2>

<p>在你的应用中快速的实现拍照与录制视频的方法是使用一个Intent来调用已经存在系统中的相机程序。通过已经存在的相机程序拍照或者录制视频，然后返回数据给请求方。这一部分会演示如何使用这种技术。</p>

<p>触发Camera Intent需要遵守如下几个步骤：</p>

<ul>
<li><p><strong>Compose a Camera Intent</strong> - 创建一个请求拍照或者录像的Intent，使用下面的intent类型：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> - 请求拍照的Intent。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a> - 请求录像的Intent。</li>
</ul>
</li>
<li><p><strong>Start the Camera Intent</strong> - 使用<a href="http://developer.android.com/reference/android/app/Activity.html#startActivityForResult(android.content.Intent,%20int">startActivityForResult()</a>)方法来执行这个Intent。在启动这个Intent之后，相机程序会被唤起并提供拍照或者录像的功能。</p></li>
<li><p><strong>Receive the Intent Result</strong> - 在你的程序里面实现<a href="http://developer.android.com/reference/android/app/Activity.html#onActivityResult(int,%20int,%20android.content.Intent">onActivityResult()</a>)的方法用来接收相机程序返回的数据。当用户结束拍照或者录像之后，系统会调用到这个方法。</p></li>
</ul>


<h3>3.1)Image capture intent</h3>

<p>使用Camera Intent是一种使用最少的代码为你的程序开启拍照功能的一种简便的方法。一个拍照程序可以包含下面的附加信息：</p>

<p><strong><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a></strong> - 这定义了一个Uri对象来指定存放图片的路径与文件名。这个设置信息是可选的，但是强烈建议添加。如果你不指定这个值，相机程序会使用默认的文件名保存图片到默认的位置，这个值可以从Intent.getData()的字段中获取到。</p>

<p>下面的示例代码演示了如何构建一个拍照Intent并执行它。<code>getOutputMediaFileUri()</code>方法可以从<strong>Saving Media Files</strong>的段落中涉及到。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="n">Uri</span> <span class="n">fileUri</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>    <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">main</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// create Intent to take a picture and return control to the calling application</span>
</span><span class='line'>    <span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">(</span><span class="n">MediaStore</span><span class="o">.</span><span class="na">ACTION_IMAGE_CAPTURE</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">fileUri</span> <span class="o">=</span> <span class="n">getOutputMediaFileUri</span><span class="o">(</span><span class="n">MEDIA_TYPE_IMAGE</span><span class="o">);</span> <span class="c1">// create a file to save the image</span>
</span><span class='line'>    <span class="n">intent</span><span class="o">.</span><span class="na">putExtra</span><span class="o">(</span><span class="n">MediaStore</span><span class="o">.</span><span class="na">EXTRA_OUTPUT</span><span class="o">,</span> <span class="n">fileUri</span><span class="o">);</span> <span class="c1">// set the image file name</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// start the image capture Intent</span>
</span><span class='line'>    <span class="n">startActivityForResult</span><span class="o">(</span><span class="n">intent</span><span class="o">,</span> <span class="n">CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当startActivityForResult()方法被执行，用户会看到一个相机拍照的界面。用户执行了拍照(或者取消操作)，用户界面会回退到你的程序，你必须在onActivityResult()方法里面接收返回的数据。关于如何接受完整的intent，可以参考下面的<strong>Receiving camera intent result</strong>段落。</p>

<h3>3.2)Video capture intent</h3>

<p>视频录制的原理和拍照一致。一个视频录制的Intent可以包含如下的参数信息：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a> - 和拍照类似，这里指定保存视频的位置。同样这个字段是可选的，但是也被强烈建议进行填写。如果没有传递这个参数，相机程序会使用默认的文件名保存文件到默认的存储位置。你可以通过在返回的Intent.getData()字段中获取到这个值。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_VIDEO_QUALITY">MediaStore.EXTRA_VIDEO_QUALITY</a> - 这里的值可以为0或者1，分别表示低质量与高质量。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_DURATION_LIMIT">MediaStore.EXTRA_DURATION_LIMIT</a> - 设置这个值用来限制视频的长度，用毫秒计算。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_SIZE_LIMIT">MediaStore.EXTRA_SIZE_LIMIT</a> - 设置这个值用来限制文件的大小，用btye做单位。</li>
</ul>


<p>下面演示了如何构建一个Video Intent并执行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="n">Uri</span> <span class="n">fileUri</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>    <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">main</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//create new Intent</span>
</span><span class='line'>    <span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">(</span><span class="n">MediaStore</span><span class="o">.</span><span class="na">ACTION_VIDEO_CAPTURE</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">fileUri</span> <span class="o">=</span> <span class="n">getOutputMediaFileUri</span><span class="o">(</span><span class="n">MEDIA_TYPE_VIDEO</span><span class="o">);</span>  <span class="c1">// create a file to save the video</span>
</span><span class='line'>    <span class="n">intent</span><span class="o">.</span><span class="na">putExtra</span><span class="o">(</span><span class="n">MediaStore</span><span class="o">.</span><span class="na">EXTRA_OUTPUT</span><span class="o">,</span> <span class="n">fileUri</span><span class="o">);</span>  <span class="c1">// set the image file name</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">intent</span><span class="o">.</span><span class="na">putExtra</span><span class="o">(</span><span class="n">MediaStore</span><span class="o">.</span><span class="na">EXTRA_VIDEO_QUALITY</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// set the video image quality to high</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// start the Video Capture Intent</span>
</span><span class='line'>    <span class="n">startActivityForResult</span><span class="o">(</span><span class="n">intent</span><span class="o">,</span> <span class="n">CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>和拍照类似，也需要在activity的onActivityResult里面去接收数据并做处理。</p>

<h3>3.3)Receiving camera intent result</h3>

<p>一旦你构建并执行了一个拍照或者录像的Intent，你的程序必须确保能够正确接收返回的数据。为了正确的接收到Intent，你必须重写onActivityResult()的方法，下面会演示如何获取到上面示例代码返回的数据。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onActivityResult</span><span class="o">(</span><span class="kt">int</span> <span class="n">requestCode</span><span class="o">,</span> <span class="kt">int</span> <span class="n">resultCode</span><span class="o">,</span> <span class="n">Intent</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">requestCode</span> <span class="o">==</span> <span class="n">CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">resultCode</span> <span class="o">==</span> <span class="n">RESULT_OK</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// Image captured and saved to fileUri specified in the Intent</span>
</span><span class='line'>            <span class="n">Toast</span><span class="o">.</span><span class="na">makeText</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;Image saved to:\n&quot;</span> <span class="o">+</span>
</span><span class='line'>                     <span class="n">data</span><span class="o">.</span><span class="na">getData</span><span class="o">(),</span> <span class="n">Toast</span><span class="o">.</span><span class="na">LENGTH_LONG</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">resultCode</span> <span class="o">==</span> <span class="n">RESULT_CANCELED</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// User cancelled the image capture</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// Image capture failed, advise user</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">requestCode</span> <span class="o">==</span> <span class="n">CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">resultCode</span> <span class="o">==</span> <span class="n">RESULT_OK</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// Video captured and saved to fileUri specified in the Intent</span>
</span><span class='line'>            <span class="n">Toast</span><span class="o">.</span><span class="na">makeText</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;Video saved to:\n&quot;</span> <span class="o">+</span>
</span><span class='line'>                     <span class="n">data</span><span class="o">.</span><span class="na">getData</span><span class="o">(),</span> <span class="n">Toast</span><span class="o">.</span><span class="na">LENGTH_LONG</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">resultCode</span> <span class="o">==</span> <span class="n">RESULT_CANCELED</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// User cancelled the video capture</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// Video capture failed, advise user</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一旦你的activity成功接收了数据，那么你的程序就可以在指定的位置获取到图片或者视频了。</p>

<h2>4)创建自定义相机应用</h2>

<p>很多时候，我们都会需要开发自定义的相机应用，它能够提供更多特殊的相机功能并带来不同的用户体验。创建一个自定义的相机应用比起使用Intent调用已经存在的相机应用会复杂许多，后续我们都会基于自定义的相机扩展描述其他的相关内容。</p>

<p>通常来说创建一个自定义的相机有如下几个步骤：</p>

<ul>
<li><strong>Detect and Access Camera</strong> - 检查相机是否存在并可访问。</li>
<li><strong>Create a Preview Class</strong> - 创建一个继承自SurfaceView的preview类，并实现SurfaceHolder的接口，用这个类用来预览相机的画面。</li>
<li><strong>Build a Preview Layout</strong> - 一旦你拥有了预览组件。创建一个Layout用来承载preview并提供交互控制界面。</li>
<li><strong>Setup Listeners for Capture</strong> - 为控制界面建立监听器，用来启动拍照或者录像。</li>
<li><strong>Capture and Save Files</strong> - 建立拍照录像的代码并进行保存。</li>
<li><strong>Release the Camera</strong> - 使用完相机之后，你的程序必须正确的释放它，以便其他程序使用。</li>
</ul>


<p>相机硬件是一个共享资源，必须谨慎正确的使用，我们的程序不应该和其他可能使用相机硬件的程序有冲突。下面的段落会介绍如何检测相机硬件，如何请求获取权限，如何拍照录像以及如何在使用完毕时释放相机。</p>

<p><strong>注意:</strong> 当你的程序执行完任务之后，切记需要通过执行Camera.release()来释放相机对象。如果你的相机没有合理的释放相机，后续包括你自己的应用在内的所有的相机应用，都将无法正常打开相机并且可能导致程序崩溃。</p>

<h3>4.1)Detecting camera hardware</h3>

<p>如果你的程序没有在manifest中声明需要使用相机，你应该在运行时去检查相机是否可用。为了执行这个检查，需要使用到<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String">PackageManager.hasSystemFeature()</a>) 方法，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/** Check if this device has a camera */</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">checkCameraHardware</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getPackageManager</span><span class="o">().</span><span class="na">hasSystemFeature</span><span class="o">(</span><span class="n">PackageManager</span><span class="o">.</span><span class="na">FEATURE_CAMERA</span><span class="o">)){</span>
</span><span class='line'>        <span class="c1">// this device has a camera</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// no camera on this device</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Android设备可以拥有多个摄像头，例如前置与后置摄像头。从Android 2.3 (API level 9)开始，可以通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#getNumberOfCameras(">Camera.getNumberOfCameras()</a>)方法获取到摄像头的个数。</p>

<h3>4.2)Accessing cameras</h3>

<p>如果已经判断到程序运行的设备上存在摄像头，接下去想要获取到某个具体的摄像头实例，需要通过先打开这个摄像头的实例来进行访问操作。</p>

<p>为了访问到主摄像头，如下所示，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(">Camera.open()</a>)方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/** A safe way to get an instance of the Camera object. */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">Camera</span> <span class="nf">getCameraInstance</span><span class="o">(){</span>
</span><span class='line'>    <span class="n">Camera</span> <span class="n">c</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">c</span> <span class="o">=</span> <span class="n">Camera</span><span class="o">.</span><span class="na">open</span><span class="o">();</span> <span class="c1">// attempt to get a Camera instance</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
</span><span class='line'>        <span class="c1">// Camera is not available (in use or does not exist)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">c</span><span class="o">;</span> <span class="c1">// returns null if camera is unavailable</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意:</strong>当使用<code>Camera.open()</code>方法时总是需要做异常捕获。如果没有进行检查捕获，很有可能会因为相机正在使用或者相机不存在而使得程序崩溃。</p>

<p>在Android 2.3 (API level 9)开始, 可以使用通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(int">Camera.open(int)</a>)方法来访问指定的摄像头。上面演示的代码会优先获取主摄像头。</p>

<h3>4.3)Checking camera features</h3>

<p>一旦获取到相机实例，可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getParameters(">Camera.getParameters()</a>)方法来获取到更多的相机信息。也可以通过获取到的相机参数对象得到相机能够支持的功能。从android 2.3开始，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getCameraInfo(int,%20android.hardware.Camera.CameraInfo">Camera.getCameraInfo()</a>)可以获取到相机是前置还是后置摄像头以及将要拍摄出来的图片角度。</p>

<h3>4.4)Creating a preview class</h3>

<p>为了给用户提供有效的拍照与录像体验，用户需要能够对摄像头捕获的数据进行预览。相机预览是使用SurfaceView，它用来显示来自摄像头硬件传递过来的画面数据。</p>

<p>下面的示例代码演示了如何创建一个基础的相机预览类，该类可以included到另外一个layout中。为了捕获拍照事件的回调，需要实现<a href="http://developer.android.com/reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a>，之后可以在这些回调里面进行创建与销毁View的操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/** A basic Camera preview class */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CameraPreview</span> <span class="kd">extends</span> <span class="n">SurfaceView</span> <span class="kd">implements</span> <span class="n">SurfaceHolder</span><span class="o">.</span><span class="na">Callback</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">SurfaceHolder</span> <span class="n">mHolder</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Camera</span> <span class="n">mCamera</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">CameraPreview</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">Camera</span> <span class="n">camera</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>        <span class="n">mCamera</span> <span class="o">=</span> <span class="n">camera</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Install a SurfaceHolder.Callback so we get notified when the</span>
</span><span class='line'>        <span class="c1">// underlying surface is created and destroyed.</span>
</span><span class='line'>        <span class="n">mHolder</span> <span class="o">=</span> <span class="n">getHolder</span><span class="o">();</span>
</span><span class='line'>        <span class="n">mHolder</span><span class="o">.</span><span class="na">addCallback</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">// deprecated setting, but required on Android versions prior to 3.0</span>
</span><span class='line'>        <span class="n">mHolder</span><span class="o">.</span><span class="na">setType</span><span class="o">(</span><span class="n">SurfaceHolder</span><span class="o">.</span><span class="na">SURFACE_TYPE_PUSH_BUFFERS</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">surfaceCreated</span><span class="o">(</span><span class="n">SurfaceHolder</span> <span class="n">holder</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// The Surface has been created, now tell the camera where to draw the preview.</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">mCamera</span><span class="o">.</span><span class="na">setPreviewDisplay</span><span class="o">(</span><span class="n">holder</span><span class="o">);</span>
</span><span class='line'>            <span class="n">mCamera</span><span class="o">.</span><span class="na">startPreview</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;Error setting camera preview: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">surfaceDestroyed</span><span class="o">(</span><span class="n">SurfaceHolder</span> <span class="n">holder</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// empty. Take care of releasing the Camera preview in your activity.</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">surfaceChanged</span><span class="o">(</span><span class="n">SurfaceHolder</span> <span class="n">holder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">format</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// If your preview can change or rotate, take care of those events here.</span>
</span><span class='line'>        <span class="c1">// Make sure to stop the preview before resizing or reformatting it.</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">mHolder</span><span class="o">.</span><span class="na">getSurface</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>          <span class="c1">// preview surface does not exist</span>
</span><span class='line'>          <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// stop preview before making changes</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">mCamera</span><span class="o">.</span><span class="na">stopPreview</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
</span><span class='line'>          <span class="c1">// ignore: tried to stop a non-existent preview</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// set preview size and make any resize, rotate or</span>
</span><span class='line'>        <span class="c1">// reformatting changes here</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// start preview with new settings</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">mCamera</span><span class="o">.</span><span class="na">setPreviewDisplay</span><span class="o">(</span><span class="n">mHolder</span><span class="o">);</span>
</span><span class='line'>            <span class="n">mCamera</span><span class="o">.</span><span class="na">startPreview</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
</span><span class='line'>            <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;Error starting camera preview: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你想为你的相机预览界面设置特定的预览大小，可以在<code>surfaceChanged()</code>的回调里面进行操作(注意上面演示代码的注释)。设置预览大小时，你<strong>必须</strong>使用从<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#getSupportedPreviewSizes(">getSupportedPreviewSizes()</a>)方法获取到的预览值，不能在<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#setPreviewSize(int,%20int">setPreviewSize()</a>)方法里设置随意的预览值。</p>

<p><strong>Notes:</strong>请注意这里只是为了演示操作相机的基础步骤，实际项目中很少用下面这么简单的结构来进行操作。</p>

<h3>4.5)Placing preview in a layout</h3>

<p>在上一段落演示的Camera Preview Class，必须放置在一个activity的layout中。这一段落会演示为了预览如何创建一个基础的layout与activity。</p>

<p>下面的代码提供了一个能够显示相机预览界面的基础layout。在这段代码中，FrameLayout是相机预览类的container。使用framelayout可以在相机预览界面上叠加额外的图片信息或者是操作控制组件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;LinearLayout</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
</span><span class='line'>    <span class="na">android:orientation=</span><span class="s">&quot;horizontal&quot;</span>
</span><span class='line'>    <span class="na">android:layout_width=</span><span class="s">&quot;fill_parent&quot;</span>
</span><span class='line'>    <span class="na">android:layout_height=</span><span class="s">&quot;fill_parent&quot;</span>
</span><span class='line'>    <span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;FrameLayout</span>
</span><span class='line'>    <span class="na">android:id=</span><span class="s">&quot;@+id/camera_preview&quot;</span>
</span><span class='line'>    <span class="na">android:layout_width=</span><span class="s">&quot;fill_parent&quot;</span>
</span><span class='line'>    <span class="na">android:layout_height=</span><span class="s">&quot;fill_parent&quot;</span>
</span><span class='line'>    <span class="na">android:layout_weight=</span><span class="s">&quot;1&quot;</span>
</span><span class='line'>    <span class="nt">/&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nt">&lt;Button</span>
</span><span class='line'>    <span class="na">android:id=</span><span class="s">&quot;@+id/button_capture&quot;</span>
</span><span class='line'>    <span class="na">android:text=</span><span class="s">&quot;Capture&quot;</span>
</span><span class='line'>    <span class="na">android:layout_width=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>    <span class="na">android:layout_height=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>    <span class="na">android:layout_gravity=</span><span class="s">&quot;center&quot;</span>
</span><span class='line'>    <span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/LinearLayout&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在大多数设备上，相机预览的角度默认是横屏的。演示的layout指定了horizontal，并且下面的代码使得activity固定成横屏的模式。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">&quot;.CameraActivity&quot;</span>
</span><span class='line'>          <span class="na">android:label=</span><span class="s">&quot;@string/app_name&quot;</span>
</span><span class='line'>
</span><span class='line'>          <span class="na">android:screenOrientation=</span><span class="s">&quot;landscape&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>          <span class="c">&lt;!-- configure this activity to use landscape orientation --&gt;</span>
</span><span class='line'>
</span><span class='line'>          <span class="nt">&lt;intent-filter&gt;</span>
</span><span class='line'>        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.action.MAIN&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.category.LAUNCHER&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class='line'><span class="nt">&lt;/activity&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Note:</strong> 相机预览界面不一定是要横屏的。从android 2.2开始，你可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation(int">setDisplayOrientation()</a>)方法来设置预览图片的角度。为了在用户旋转手机时改变相机预览的角度，在<code>surfaceChanged()</code>方法里面，首先要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#stopPreview(">Camera.stopPreview()</a>)停止预览，然后再使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#startPreview(">Camera.startPreview()</a>)方法来重新开启相机预览，后面会新写文章展开来讲这一部分的细节。</p>

<p>为了在activity中添加相机界面，你的Camera Activity必须确保在activity pause或者是destory的时候释放相机资源。下面的代码演示了如何添加camera preview class到camera activity中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CameraActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Camera</span> <span class="n">mCamera</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">CameraPreview</span> <span class="n">mPreview</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">main</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Create an instance of Camera</span>
</span><span class='line'>        <span class="n">mCamera</span> <span class="o">=</span> <span class="n">getCameraInstance</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Create our Preview view and set it as the content of our activity.</span>
</span><span class='line'>        <span class="n">mPreview</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CameraPreview</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">mCamera</span><span class="o">);</span>
</span><span class='line'>        <span class="n">FrameLayout</span> <span class="n">preview</span> <span class="o">=</span> <span class="o">(</span><span class="n">FrameLayout</span><span class="o">)</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">camera_preview</span><span class="o">);</span>
</span><span class='line'>        <span class="n">preview</span><span class="o">.</span><span class="na">addView</span><span class="o">(</span><span class="n">mPreview</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Note:</strong> 上面演示的<code>getCameraInstance()</code>方法出现在4.2)Accessing camera段落中。</p>

<h3>4.6)触发拍照行为</h3>

<p>一旦你建立了preview class并且创建好了显示的layout。那么就可以开始做拍照的动作了。</p>

<p>为了获取到一张图片，需要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#takePicture(android.hardware.Camera.ShutterCallback,%20android.hardware.Camera.PictureCallback,%20android.hardware.Camera.PictureCallback">Camera.takePicture()</a>)方法。为了获取到JPEG格式的图片数据，你必须implement一个<a href="http://developer.android.com/reference/android/hardware/Camera.PictureCallback.html">Camera.PictureCallback</a>接口来接收图片数据并把它写到文件中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">PictureCallback</span> <span class="n">mPicture</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PictureCallback</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onPictureTaken</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">,</span> <span class="n">Camera</span> <span class="n">camera</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">File</span> <span class="n">pictureFile</span> <span class="o">=</span> <span class="n">getOutputMediaFile</span><span class="o">(</span><span class="n">MEDIA_TYPE_IMAGE</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">pictureFile</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>            <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;Error creating media file, check storage permissions: &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">pictureFile</span><span class="o">);</span>
</span><span class='line'>            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
</span><span class='line'>            <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;File not found: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;Error accessing file: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>触发拍照的动作，需要使用下面演示到的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// Add a listener to the Capture button</span>
</span><span class='line'><span class="n">Button</span> <span class="n">captureButton</span> <span class="o">=</span> <span class="o">(</span><span class="n">Button</span><span class="o">)</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="na">button_capture</span><span class="o">);</span>
</span><span class='line'><span class="n">captureButton</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span>
</span><span class='line'>    <span class="k">new</span> <span class="n">View</span><span class="o">.</span><span class="na">OnClickListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="nd">@Override</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// get an image from the camera</span>
</span><span class='line'>            <span class="n">mCamera</span><span class="o">.</span><span class="na">takePicture</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">mPicture</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.7)释放相机实例</h3>

<p>相机实例是被共享的系统资源。获取到相机实例之后，程序才可以使用相机，但是，在使用完相机的时候，程序必须谨慎的释放它。建议在程序进入到pause状态时，立即释放相机资源。如果你的程序没有合理的释放相机资源，包括自己程序本身在内，后续所有的相机请求都将失败，甚至可能会导致程序崩溃。下面的代码演示了如何释放相机资源。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CameraActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Camera</span> <span class="n">mCamera</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">SurfaceView</span> <span class="n">mPreview</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">MediaRecorder</span> <span class="n">mMediaRecorder</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPause</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onPause</span><span class="o">();</span>
</span><span class='line'>        <span class="n">releaseMediaRecorder</span><span class="o">();</span>       <span class="c1">// if you are using MediaRecorder, release it first</span>
</span><span class='line'>        <span class="n">releaseCamera</span><span class="o">();</span>              <span class="c1">// release the camera immediately on pause event</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">releaseMediaRecorder</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">mMediaRecorder</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">mMediaRecorder</span><span class="o">.</span><span class="na">reset</span><span class="o">();</span>   <span class="c1">// clear recorder configuration</span>
</span><span class='line'>            <span class="n">mMediaRecorder</span><span class="o">.</span><span class="na">release</span><span class="o">();</span> <span class="c1">// release the recorder object</span>
</span><span class='line'>            <span class="n">mMediaRecorder</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>            <span class="n">mCamera</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>           <span class="c1">// lock camera for later use</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">releaseCamera</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">mCamera</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>            <span class="n">mCamera</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>        <span class="c1">// release the camera for other applications</span>
</span><span class='line'>            <span class="n">mCamera</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5)保存媒体文件</h2>

<p>前面介绍了自定义相机，使用相机拍摄的照片或者视频都需要保存到设备的external storage目录下(SDCard)。可以有多种可能的位置用来保存文件，但是作为一个开发人员，建议使用下面两种标准的路径进行保存。</p>

<ul>
<li><a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String">Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回用来保存图片与视频所推荐使用的标准共享目录。这个目录是共享开放的，所有其他的程序都可以轻易的访问，读取并删除这个目录下的文件。如果你的程序被用户卸载，在这个目录下的文件不会被移除。为了避免干扰到用户已经存在的图片与视频目录，你应该为你的程序创建一个子目录。如下面的代码所示。这个方法从Android 2.2 (API level 8)开始就可以使用。</li>
<li><a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String">Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回一个和你的程序相关联的，用来保存图片与视频的，标准目录。如果你的程序被卸载，在这个目录下的文件也会被一起移除。这个目录并不能阻止其他程序的读写。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MEDIA_TYPE_IMAGE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MEDIA_TYPE_VIDEO</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Create a file Uri for saving an image or video */</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="n">Uri</span> <span class="nf">getOutputMediaFileUri</span><span class="o">(</span><span class="kt">int</span> <span class="n">type</span><span class="o">){</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">Uri</span><span class="o">.</span><span class="na">fromFile</span><span class="o">(</span><span class="n">getOutputMediaFile</span><span class="o">(</span><span class="n">type</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Create a File for saving an image or video */</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="n">File</span> <span class="nf">getOutputMediaFile</span><span class="o">(</span><span class="kt">int</span> <span class="n">type</span><span class="o">){</span>
</span><span class='line'>    <span class="c1">// To be safe, you should check that the SDCard is mounted</span>
</span><span class='line'>    <span class="c1">// using Environment.getExternalStorageState() before doing this.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">File</span> <span class="n">mediaStorageDir</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">Environment</span><span class="o">.</span><span class="na">getExternalStoragePublicDirectory</span><span class="o">(</span>
</span><span class='line'>              <span class="n">Environment</span><span class="o">.</span><span class="na">DIRECTORY_PICTURES</span><span class="o">),</span> <span class="s">&quot;MyCameraApp&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">// This location works best if you want the created images to be shared</span>
</span><span class='line'>    <span class="c1">// between applications and persist after your app has been uninstalled.</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create the storage directory if it does not exist</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span> <span class="n">mediaStorageDir</span><span class="o">.</span><span class="na">exists</span><span class="o">()){</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span> <span class="n">mediaStorageDir</span><span class="o">.</span><span class="na">mkdirs</span><span class="o">()){</span>
</span><span class='line'>            <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="s">&quot;MyCameraApp&quot;</span><span class="o">,</span> <span class="s">&quot;failed to create directory&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create a media file name</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">timeStamp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleDateFormat</span><span class="o">(</span><span class="s">&quot;yyyyMMdd_HHmmss&quot;</span><span class="o">).</span><span class="na">format</span><span class="o">(</span><span class="k">new</span> <span class="n">Date</span><span class="o">());</span>
</span><span class='line'>    <span class="n">File</span> <span class="n">mediaFile</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">MEDIA_TYPE_IMAGE</span><span class="o">){</span>
</span><span class='line'>        <span class="n">mediaFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">mediaStorageDir</span><span class="o">.</span><span class="na">getPath</span><span class="o">()</span> <span class="o">+</span> <span class="n">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span>
</span><span class='line'>        <span class="s">&quot;IMG_&quot;</span><span class="o">+</span> <span class="n">timeStamp</span> <span class="o">+</span> <span class="s">&quot;.jpg&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">MEDIA_TYPE_VIDEO</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">mediaFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">mediaStorageDir</span><span class="o">.</span><span class="na">getPath</span><span class="o">()</span> <span class="o">+</span> <span class="n">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span>
</span><span class='line'>        <span class="s">&quot;VID_&quot;</span><span class="o">+</span> <span class="n">timeStamp</span> <span class="o">+</span> <span class="s">&quot;.mp4&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">mediaFile</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>6)相机相关特性</h2>

<p>Android提供了控制相机特性的方法，例如图片格式，闪光灯模式，聚焦模式等等。这一段落列出了大部分相机共有的功能并简短的介绍如何使用这些功能。大多数相机特性可以通过<strong>Camera.Parameters</strong>对象来获取并进行相关的设置。然而，有几个重要的功能不仅仅是通过<strong>Camera.Parameters</strong>能够实现的。请看下面的内容介绍：</p>

<ul>
<li>Metering and focus areas：测光并进行聚焦</li>
<li>Face detection：人脸检测</li>
</ul>


<p>关于上面2个常用的功能会在以后的文章中进行更加详细的介绍，除此之外的其他相机特性功能，请参考下面这张表：</p>

<p><img src="http://hukai.me/images/articles/camera_features_table.png" title="Camera Common Features" alt="camera_features_table.png" /></p>

<p><strong>Note:</strong> 因为软硬件的差异性，那些功能并不一定都是支持的。对于检查功能是否可用，请参考下面的Checking feature availability.</p>

<h3>6.1)Checking feature availability</h3>

<p>相机的有些功能在所有手机上并不一定是都支持的。在开发相机应用时就需要提前考虑应该适配到哪个level。然后开发的时候需要动态的去根据功能是否支持来做不同的处理。</p>

<p>你可以通过获取到相机参数的对象来做检测。下面的例子演示了如何检查autofocus功能是否可用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// get Camera parameters</span>
</span><span class='line'><span class="n">Camera</span><span class="o">.</span><span class="na">Parameters</span> <span class="n">params</span> <span class="o">=</span> <span class="n">mCamera</span><span class="o">.</span><span class="na">getParameters</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">focusModes</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="na">getSupportedFocusModes</span><span class="o">();</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">focusModes</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">Camera</span><span class="o">.</span><span class="na">Parameters</span><span class="o">.</span><span class="na">FOCUS_MODE_AUTO</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Autofocus mode is supported</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于大多数的相机特性，都可以使用类型上面的代码来处理。Camera.Parameters对象提供了一系列的类似<code>getSupported...()</code>, <code>is...Supported()</code> 与 <code>getMax...()</code> 方法来判断某个功能是否可用的。</p>

<p>如果你的程序确定需要相机的某个特性，你可以在mainfest文件中就进声明。例如你声明了flash与auto-focus的功能，那么Google Play会阻止那些不支持这些功能的设备安装这个应用。关于相机功能的声明列表，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">Features Reference.</a></p>

<h3>6.2)Using camera features</h3>

<p>前面已经提到过，通过Camera.Parameters对象来操控相机。如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// get Camera parameters</span>
</span><span class='line'><span class="n">Camera</span><span class="o">.</span><span class="na">Parameters</span> <span class="n">params</span> <span class="o">=</span> <span class="n">mCamera</span><span class="o">.</span><span class="na">getParameters</span><span class="o">();</span>
</span><span class='line'><span class="c1">// set the focus mode</span>
</span><span class='line'><span class="n">params</span><span class="o">.</span><span class="na">setFocusMode</span><span class="o">(</span><span class="n">Camera</span><span class="o">.</span><span class="na">Parameters</span><span class="o">.</span><span class="na">FOCUS_MODE_AUTO</span><span class="o">);</span>
</span><span class='line'><span class="c1">// set Camera parameters</span>
</span><span class='line'><span class="n">mCamera</span><span class="o">.</span><span class="na">setParameters</span><span class="o">(</span><span class="n">params</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这种方法对大多数相机功能都是可用的，在你获取到相机的实例之后，大多数参数都是在任意时间均可以修改的。参数修改的效果在相机预览的界面是可以立即看到效果的。在软件层面，实际上可能是需要花几帧的时间来产生效果的，因为需要发送指令给相机硬件产生效果。</p>

<p><strong>Important:</strong> 有部分相机特性不是想要修改的时候就可以直接修改的。尤其是，修改相机预览的角度与相机预览大小，很多时候是需要先停止预览，设置参数，再重启预览的。从Android Android 4.0(API level 14)开始，预览角度可以不用重启预览就可以进行修改。</p>

<hr />

<p><strong>后记:</strong>这篇概览大致介绍了Android平台上相机开发相关的基础概念，上面的演示代码仅仅是为了说明问题，在真实项目的实践中，相机实例的相关操作都会放在单独的线程中，很多基础的操作都可能遇到复杂的兼容性问题，为了解决兼容性的问题，提高性能等等的需要，会做很大的调整，更多细节请期待后续的文章，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第6季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-6/"/>
    <updated>2016-10-04T23:12:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-6</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_perf_patterns_season_common.png" alt="android_perf_patterns_season_common" /></p>

<blockquote><p>这里是<a href="https://www.youtube.com/watch?v=Vw1G1s73DsY&amp;index=74&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第6季的课程学习笔记，从被@知会到有连载更新，这篇学习笔记就一直被惦记着，现在学习记录分享一下，请多多指教包涵！这次一共才6个小段落，涉及的内容主要有：程序启动时间性能优化的三个方面：优化activity的创建过程，优化application对象的启动过程，正确使用启动显屏达到优化程序启动性能的目的。另外还介绍了减少安装包大小的checklist以及如何使用VectorDrawable来减少安装包的大小。</p></blockquote>

<h2>1）App Launch time 101</h2>

<p>提高程序的启动速度意义重大，很显然，启动时间越短，用户才越有耐心等待打开这个APP进行使用，反之启动时间越长，用户则越有可能来不及等到APP打开就已经切换到其他APP了。程序启动过程中的那些复杂错误的操作很可能导致严重的性能问题。Android系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他APP界面切换回来）。那么关键的问题是，用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他APP了。更严重的是，如果启动时间过长，可能导致程序出现ANR。我们应该避免出现这两种糟糕的情况。</p>

<p>从技术角度来说，当用户点击桌面图标开始，系统会立即为这个APP创建独立的专属进程，然后显示启动窗口，直到APP在自己的进程里面完成了程序的创建以及主线程完成了Activity的初始化显示操作，再然后系统进程就会把启动窗口替换成APP的显示窗口。</p>

<p><img src="http://hukai.me/images/android_perf_6_launch_time_start_process.png" alt="android_perf_6_launch_time_start_process" /></p>

<!-- More -->


<p>上述流程里面的绝大多数步骤都是由系统控制的，一般来说不会出现什么问题，可是对于启动速度，我们能够控制并且需要特别关注的地方主要有三处：</p>

<ul>
<li>1）Activity的onCreate流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题。</li>
<li>2）Application的onCreate流程，对于大型的APP来说，通常会在这里做大量的通用组件的初始化操作。</li>
<li>3）目前有部分APP会提供自定义的启动窗口，这里可以做成品牌宣传界面或者是给用户提供一种程序已经启动的视觉效果。</li>
</ul>


<p>在正式着手解决问题之前，我们需要掌握一套正确测量评估启动性能的方法。所幸的是，Android系统有提供一些工具来帮助我们定位问题。</p>

<ul>
<li>1）首先是<strong>display time</strong>：从Android KitKat版本开始，Logcat中会输出从程序启动到某个Activity显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_launch_time_display_time.png" alt="android_perf_6_launch_time_display_time" /></p>

<ul>
<li>2）其次是<strong>reportFullyDrawn</strong>方法：我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用<code>activity.reportFullyDrawn()</code>方法来告诉系统此时的状态，以便获取整个加载的耗时。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_launch_time_report_fully_drawn.png" alt="android_perf_6_launch_time_report_fully_drawn" /></p>

<ul>
<li>3）然后是<strong>Method Tracing</strong>：前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用Method Tracing工具来进行详细的测量。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_launch_time_method_tracing.png" alt="android_perf_6_launch_time_method_tracing" /></p>

<ul>
<li>4）最后是<strong>Systrace</strong>：我们可以在onCreate方法里面添加trace.beginSection()与trace.endSection()方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_launch_time_systrace.png" alt="android_perf_6_launch_time_systrace" /></p>

<h2>2）App Launch Time &amp; Activity Creation</h2>

<p>提升Activity的创建速度是优化APP启动速度的首要关注目标。从桌面点击APP图标启动应用开始，程序会显示一个启动窗口等待Activity的创建加载完毕再进行显示。在Activity的创建加载过程中，会执行很多的操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写Preference等等。</p>

<p><img src="http://hukai.me/images/android_perf_6_activity_creation_0.png" alt="android_perf_6_activity_creation_0" /></p>

<p>上述操作的任何一个环节出现性能问题都可能导致画面不能及时显示，影响了程序的启动速度。上一个段落我们介绍了使用Method Tracing来发现那些耗时占比相对较多的方法。假设我们发现某个方法执行时间过长，接下去就可以使用Systrace来帮忙定位到底是什么原因导致那个方法执行时间过长。</p>

<p>除了使用工具进行具体定位分析性能问题之外，以下两点经验可以帮助我们对Activity启动做性能优化：</p>

<ul>
<li>1）优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！</li>
<li>2）异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。</li>
</ul>


<h2>3）App Launch Time &amp; Bloated Application Objects</h2>

<p>在Application初始化的地方做太多繁重的事情是可能导致严重启动性能问题的元凶之一。Application里面的初始化操作不结束，其他任意的程序操作都无法进行。</p>

<p><img src="http://hukai.me/images/android_perf_6_application_objs.png" alt="android_perf_6_application_objs" /></p>

<p>有时候，我们会一股脑的把绝大多数全局组件的初始化操作都放在Application的onCreate里面，但其实很多组件是需要做区队对待的，有些可以做延迟加载，有些可以放到其他的地方做初始化操作，特别需要留意包含Disk IO操作，网络访问等严重耗时的任务，他们会严重阻塞程序的启动。</p>

<p><img src="http://hukai.me/images/android_perf_6_application_create.png" alt="android_perf_6_application_create" /></p>

<p>优化这些问题的解决方案是做延迟加载，可以在application里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。</p>

<p><img src="http://hukai.me/images/android_perf_6_application_lazyload.png" alt="android_perf_6_application_lazyload" /></p>

<h2>4）App Launch Time &amp; Theme Launch Screens</h2>

<p>启动闪屏不仅仅可以作为品牌宣传页，还能够减轻用户对启动耗时的感知，但是如果使用不恰当，将适得其反。前面介绍过当点击桌面图标启动APP的时候，程序会显示一个启动窗口，一直到页面的渲染加载完毕。如果程序的启动速度足够快，我们看的闪屏窗口停留显示的时间则会很短，但是当程序启动速度偏慢的时候，这个启动闪屏可以一定程度上减轻用户等待的焦虑感，避免用户过于轻易的关闭应用。</p>

<p>目前大多数开发者都会通过设置启动窗口主题的方式来替换系统默认的启动窗口，通过这种方式只是使用『障眼法』弱化了用户对启动时间的感知，但本质上并没有对启动速度做什么优化。也有些APP通过关闭启动窗口属性<code>android:windowDisablePreview</code>的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，这样的用户体验是十分糟糕的！</p>

<p><img src="http://hukai.me/images/android_perf_6_launch_screen.png" alt="android_perf_6_launch_screen" />
<img src="http://hukai.me/images/android_perf_6_launch_screen2.png" alt="android_perf_6_launch_screen2" /></p>

<p>对于启动闪屏，正确的使用方法是自定义一张图片，把这张图片通过设置主题的方式显示为启动闪屏，代码执行到主页面的onCreate的时候设置为程序正常的主题。</p>

<p><img src="http://hukai.me/images/android_perf_6_launch_screen3.png" alt="android_perf_6_launch_screen3" />
<img src="http://hukai.me/images/android_perf_6_launch_screen4.png" alt="android_perf_6_launch_screen4" /></p>

<h2>5）Smaller APKs: A Checklist</h2>

<p>减少应用程序安装包的大小，不仅仅减少了用户的网络数据流量还减少了下载等待的时间。毋庸置疑，尽量减少程序安装包的大小是十分有必要的。通常来说，减少程序安装包的大小有两条规律：要么减少程序资源的大小，要么就是减少程序的代码量。这里总结一个简易版的减少安装包大小的Checklist:</p>

<h3>减少程序图片资源的大小</h3>

<ul>
<li>1）确保在build.gradle文件中开启了<code>minifEnabled</code>与<code>shrinkResources</code>的属性，这两个属性可以帮助移除那些在程序中使用不到的代码与资源，帮助减少APP的安装包大小。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_smaller_apks_gradle.png" alt="android_perf_6_smaller_apks_gradle" /></p>

<ul>
<li>2）有选择性的提供对应分辨率的图片资源，系统会自动匹配最合适分辨率的图片并执行拉伸或者压缩的处理。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_smaller_apks_dpi.png" alt="android_perf_6_smaller_apks_dpi" /></p>

<ul>
<li>3）在符合条件的情况下，使用Vertor Drawable替代传统的PNG/JPEG图片，能够极大的减少图片资源的大小。传统模式下，针对不同dpi的手机都需要提供一套PNG/JPEG的图片，而如果使用Vector Drawable的话，只需要一个XML文件即可。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_smaller_apks_vector.png" alt="android_perf_6_smaller_apks_vector" /></p>

<ul>
<li>4）尽量复用已经存在的资源图片，使用代码的方式对已有的资源进行复用，如下图所示：</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_smaller_apks_reuse.png" alt="android_perf_6_smaller_apks_reuse" /></p>

<p>以上几点虽然看起来都微不足道，但是真正执行之后，能够显著减少安装包的资源图片大小。</p>

<h3>减少程序的代码量</h3>

<ul>
<li><p>1）开启MinifEnabled，Proguard。打开这些编译属性之后，程序在打包的时候就不会把没有引用到的代码编译进来，以此达到减少安装包大小的目的。</p></li>
<li><p>2）注意因为编译行为额外产生的方法数，例如类似Enum，Protocal Buffer可能导致方法数与类的个数增加。</p></li>
<li><p>3）部分引入到工程中的jar类库可能并不是专门针对移动端APP而设计的，他们最开始可能是运用在PC或者Server上的。使用这些类库不仅仅额外增加了包的大小，还增加了编译时间。单纯依靠Proguard可能无法完全移除那些使用不到的方法，最佳的方式是使用一些更加轻量化，专门为Android APP设计的jar类库。</p></li>
</ul>


<h3>安装包的拆分</h3>

<p>设想一下，一个low dpi，API&lt;14的用户手机下载安装的APK里面却包含了大量xxhdpi的资源文件，对于这个用户来说，这个APK是存在很大的资源浪费的。幸好Android平台为我们提供了拆分APK的方法，它能够根据API Level，屏幕大小以及GPU版本的不同进行拆分，使得对应平台的用户下载到最合适自己手机的安装包。</p>

<p><img src="http://hukai.me/images/android_perf_6_smaller_apks_split.png" alt="android_perf_6_smaller_apks_split" /></p>

<p>更多关于安装包拆分的信息，请查看<a href="https://developer.android.com/studio/build/configure-apk-splits.html">Configure APK Splits</a>与<a href="https://developer.android.com/training/multiple-apks/index.html">Maintaining Multiple APKs</a>(由于国内应用分发市场的现状，这一条几乎没有办法执行)。</p>

<h2>6）VectorDrawable for smaller APKs</h2>

<p>针对不同的分辨率提供多张精度的图片会额外增加APK的大小，针对这个问题的解决方案是考虑使用VectorDrawable，它仅仅只需要一个文件，能够动态生成对应分辨率的图片。</p>

<p><a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html">VectorDrawable</a>通过XML文件描述图片的形状，大小，样式。</p>

<p><img src="http://hukai.me/images/android_perf_6_vectordrawable_origin.png" alt="android_perf_6_vectordrawable_origin" /></p>

<p>通过这种方式，我们可以显著减少图片资源对安装包大小的影响。</p>

<p><img src="http://hukai.me/images/android_perf_6_vectordrawable_dpi.png" alt="android_perf_6_vectordrawable_dpi" />
<img src="http://hukai.me/images/android_perf_6_vectordrawable_dpi2.png" alt="android_perf_6_vectordrawable_dpi2" /></p>

<p>使用VectorDrawable还可以避免因为使用帧动画导致的图片资源过多的情况，如下图所示</p>

<p><img src="http://hukai.me/images/android_perf_6_vectordrawable_animation.png" alt="android_perf_6_vectordrawable_animation" /></p>

<p>前面介绍了VectorDrawable(VD)的优势，但是在使用VectorDrawable的时候，还是有以下的问题需要特别注意的？</p>

<ul>
<li>首先VD的加载有异于JPEG/PNG文件，图片文件可以依靠硬件进行纹理的渲染，而VD文件需要先进行加载解析，然后才能够进行纹理的渲染。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_vectordrawable_load.png" alt="android_perf_6_vectordrawable_load" /></p>

<ul>
<li>其次VD文件适用于简单有规则的图片渲染，不适用于那些纹理过于复杂的图片，这样不仅仅会过度增加描述文件的复杂度还可能无法获取到想要的渲染效果。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_vectordrawable_simple.png" alt="android_perf_6_vectordrawable_simple" /></p>

<ul>
<li>最后VD文件中关于Path的描述需要尽量简化，复杂冗余的Path信息不仅对得到想要的图片没有益处，还增加了加载渲染的难度。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_6_vectordrawable_path.png" alt="android_perf_6_vectordrawable_path" /></p>

<hr />

<p>首发于CSDN：<a href="http://geek.csdn.net/news/detail/106513">Android性能优化典范（六）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google I/O 2016随笔]]></title>
    <link href="http://hukai.me/google-io-2016/"/>
    <updated>2016-05-24T05:06:01+08:00</updated>
    <id>http://hukai.me/google-io-2016</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/oasisfeng">冯老师</a>，<a href="https://github.com/liaohuqiu">秋百万</a>，<a href="http://www.race604.com/">吴晶</a>还有我！四人约好从北京转机一起前往旧金山。</p>

<p><img src="http://hukai.me/images/google_io_2016_00.JPG" alt="google_io_2016_00" /></p>

<p>在航班上研究KMP算法的同学</p>

<p><img src="http://hukai.me/images/google_io_2016_01.JPG" alt="google_io_2016_01" /></p>

<p>到达旧金山机场，去提取事先租好的车，自驾</p>

<!-- More -->


<p><img src="http://hukai.me/images/google_io_2016_02.JPG" alt="google_io_2016_02" /></p>

<p><img src="http://hukai.me/images/google_io_2016_03.JPG" alt="google_io_2016_03" /></p>

<p><img src="http://hukai.me/images/google_io_2016_04.JPG" alt="google_io_2016_04" /></p>

<p>入住通过Airbnb上找的房子</p>

<p><img src="http://hukai.me/images/google_io_2016_05.JPG" alt="google_io_2016_05" /></p>

<p><img src="http://hukai.me/images/google_io_2016_06.JPG" alt="google_io_2016_06" /></p>

<p>到美国吃的第一顿（中式餐馆）没预料到这会是之后几天我吃的最满意的一次了</p>

<p><img src="http://hukai.me/images/google_io_2016_07.JPG" alt="google_io_2016_07" /></p>

<p>第二天一早清晨，在海边小镇上闲逛</p>

<p><img src="http://hukai.me/images/google_io_2016_08.JPG" alt="google_io_2016_08" />
<img src="http://hukai.me/images/google_io_2016_09.JPG" alt="google_io_2016_09" />
<img src="http://hukai.me/images/google_io_2016_10.JPG" alt="google_io_2016_10" />
<img src="http://hukai.me/images/google_io_2016_11.JPG" alt="google_io_2016_11" />
<img src="http://hukai.me/images/google_io_2016_12.JPG" alt="google_io_2016_12" /></p>

<p>之后去了旁边的半月湾海边走走，以及不远处的森林公园爬山</p>

<p><img src="http://hukai.me/images/google_io_2016_13.JPG" alt="google_io_2016_13" />
<img src="http://hukai.me/images/google_io_2016_14.JPG" alt="google_io_2016_14" />
<img src="http://hukai.me/images/google_io_2016_15.JPG" alt="google_io_2016_15" /></p>

<p>晚上跑到旧金山最高点，看全市夜景</p>

<p><img src="http://hukai.me/images/google_io_2016_16.JPG" alt="google_io_2016_16" /></p>

<p>离开半月湾海边公寓之前的合影（从左至右，依次为吴晶，冯老师，秋百万和我）</p>

<p><img src="http://hukai.me/images/google_io_2016_17.JPG" alt="google_io_2016_17" /></p>

<p>窗外的全景</p>

<p><img src="http://hukai.me/images/google_io_2016_19.JPG" alt="google_io_2016_19" /></p>

<p>I/O的头一天签到</p>

<p><img src="http://hukai.me/images/google_io_2016_21.JPG" alt="google_io_2016_21" />
<img src="http://hukai.me/images/google_io_2016_20.JPG" alt="google_io_2016_20" />
<img src="http://hukai.me/images/google_io_2016_22.JPG" alt="google_io_2016_22" />
<img src="http://hukai.me/images/google_io_2016_23.JPG" alt="google_io_2016_23" />
<img src="http://hukai.me/images/google_io_2016_24.JPG" alt="google_io_2016_24" /></p>

<p>顺便参观了下Google总部</p>

<p><img src="http://hukai.me/images/google_io_2016_25.JPG" alt="google_io_2016_25" />
<img src="http://hukai.me/images/google_io_2016_26.JPG" alt="google_io_2016_26" />
<img src="http://hukai.me/images/google_io_2016_27.JPG" alt="google_io_2016_27" />
<img src="http://hukai.me/images/google_io_2016_28.JPG" alt="google_io_2016_28" />
<img src="http://hukai.me/images/google_io_2016_29.JPG" alt="google_io_2016_29" />
<img src="http://hukai.me/images/google_io_2016_30.JPG" alt="google_io_2016_30" /></p>

<p>签到当天晚上，又是一群聚会聊天</p>

<p><img src="http://hukai.me/images/google_io_2016_32.JPG" alt="google_io_2016_32" />
<img src="http://hukai.me/images/google_io_2016_31.JPG" alt="google_io_2016_31" /></p>

<p>次日I/O正式开场，主会场，分会场持续三天</p>

<p><img src="http://hukai.me/images/google_io_2016_33.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_34.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_35.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_36.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_37.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_38.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_39.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_40.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_41.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_42.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_43.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_44.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_45.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_46.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_47.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_48.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_49.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_50.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_51.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_52.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_53.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_54.JPG" alt="google_io_2016_31" />
<img src="http://hukai.me/images/google_io_2016_55.JPG" alt="google_io_2016_31" /></p>

<p>用一张合影结尾</p>

<p><img src="http://hukai.me/images/google_io_2016_18.JPG" alt="google_io_2016_18" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第5季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-5/"/>
    <updated>2016-04-28T00:08:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-5</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_perf_patterns_season_5.png" alt="android_perf_patterns_season_5" /></p>

<blockquote><p>这是<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第5季的课程学习笔记，拖拖拉拉很久，记录分享给大家，请多多包涵担待指正！文章共10个段落，涉及的内容有：多线程并发的性能问题，介绍了AsyncTask，HandlerThread，IntentService与ThreadPool分别适合的使用场景以及各自的使用注意事项，这是一篇了解Android多线程编程不可多得的基础文章，清楚的了解这些Android系统提供的多线程基础组件之间的差异以及优缺点，才能够在项目实战中做出最恰当的选择。</p></blockquote>

<h2>1)Threading Performance</h2>

<p>在程序开发的实践当中，为了让程序表现得更加流畅，我们肯定会需要使用到多线程来提升程序的并发执行性能。但是编写多线程并发的代码一直以来都是一个相对棘手的问题，所以想要获得更佳的程序性能，我们非常有必要掌握多线程并发编程的基础技能。</p>

<p>众所周知，Android程序的大多数代码操作都必须执行在主线程，例如系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程。</p>

<p><img src="http://hukai.me/images/android_perf_5_threading_main_thread.png" alt="android_perf_5_threading_main_thread" /></p>

<!-- More -->


<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的UI绘制等等。我们知道，为了让屏幕的刷新帧率达到60fps，我们需要确保16ms内完成单次刷新的操作。一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了(一旦刷新帧率降到20fps左右，用户就可以明显感知到卡顿不流畅了)。</p>

<p><img src="http://hukai.me/images/android_perf_5_threading_dropframe.png" alt="android_perf_5_threading_dropframe" /></p>

<p>为了避免上面提到的掉帧问题，我们需要使用多线程的技术方案，把那些操作复杂的任务移动到其他线程当中执行，这样就不容易阻塞主线程的操作，也就减小了出现掉帧的可能性。</p>

<p><img src="http://hukai.me/images/android_perf_5_threading_workthread.png" alt="android_perf_5_threading_workthread" /></p>

<p>那么问题来了，为主线程减轻负的多线程方案有哪些呢？这些方案分别适合在什么场景下使用？Android系统为我们提供了若干组工具类来帮助解决这个问题。</p>

<ul>
<li><strong>AsyncTask</strong>: 为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li><strong>HandlerThread</strong>: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li><strong>ThreadPool</strong>: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li><strong>IntentService</strong>: 适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。</li>
</ul>


<p>了解这些系统提供的多线程工具类分别适合在什么场景下，可以帮助我们选择合适的解决方案，避免出现不可预期的麻烦。虽然使用多线程可以提高程序的并发量，但是我们需要特别注意因为引入多线程而可能伴随而来的内存问题。举个例子，在Activity内部定义的一个AsyncTask，它属于一个内部类，该类本身和外面的Activity是有引用关系的，如果Activity要销毁的时候，AsyncTask还仍然在运行，这会导致Activity没有办法完全释放，从而引发内存泄漏。所以说，多线程是提升程序性能的有效手段之一，但是使用多线程却需要十分谨慎小心，如果不了解背后的执行机制以及使用的注意事项，很可能引起严重的问题。</p>

<h2>2)Understanding Android Threading</h2>

<p>通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。</p>

<p><img src="http://hukai.me/images/android_perf_5_thread_lifecycle.png" alt="android_perf_5_thread_lifecycle" /></p>

<p>在很多时候，线程不仅仅是线性执行一系列的任务就结束那么简单的，我们会需要增加一个任务队列，让线程不断的从任务队列中获取任务去进行执行，另外我们还可能在线程执行的任务过程中与其他的线程进行协作。如果这些细节都交给我们自己来处理，这将会是件极其繁琐又容易出错的事情。</p>

<p><img src="http://hukai.me/images/android_perf_5_thread_thread.png" alt="android_perf_5_thread_thread" /></p>

<p>所幸的是，Android系统为我们提供了Looper，Handler，MessageQueue来帮助实现上面的线程任务模型：</p>

<p><strong>Looper</strong>: 能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。</p>

<p><img src="http://hukai.me/images/android_perf_5_thread_looper.png" alt="android_perf_5_thread_looper" /></p>

<p><strong>Handler</strong>: 能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。</p>

<p><img src="http://hukai.me/images/android_perf_5_thread_handler.png" alt="android_perf_5_thread_handler" /></p>

<p><strong>MessageQueue</strong>: 使用Intent，Message，Runnable作为任务的载体在不同的线程之间进行传递。</p>

<p><img src="http://hukai.me/images/android_perf_5_thread_messagequeue.png" alt="android_perf_5_thread_messagequeue" /></p>

<p>把上面三个组件打包到一起进行协作，这就是<strong>HandlerThread</strong></p>

<p><img src="http://hukai.me/images/android_perf_5_thread_handlerthread.png" alt="android_perf_5_thread_handlerthread" /></p>

<p>我们知道，当程序被启动，系统会帮忙创建进程以及相应的主线程，而这个主线程其实就是一个HandlerThread。这个主线程会需要处理系统事件，输入事件，系统回调的任务，UI绘制等等任务，为了避免主线程任务过重，我们就会需要不断的开启新的工作线程来处理那些子任务。</p>

<h2>3)Memory &amp; Threading</h2>

<p>增加并发的线程数会导致内存消耗的增加，平衡好这两者的关系是非常重要的。我们知道，多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a>等等。为了解决这些问题，我们会需要引入<strong>锁</strong>的概念。</p>

<p>在Android系统中也无法避免因为多线程的引入而导致出现诸如上文提到的种种问题。Android UI对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>

<p> <img src="http://hukai.me/images/android_perf_5_memory_thread_update.png" alt="android_perf_5_memory_thread_update" /></p>

<p>另外，在非UI线程中直接持有UI对象的引用也很可能出现问题。例如Work线程中持有某个UI对象的引用，在Work线程执行完毕之前，UI对象在主线程中被从ViewHierarchy中移除了，这个时候UI对象的任何属性都已经不再可用了，另外对这个UI对象的更新操作也都没有任何意义了，因为它已经从ViewHierarchy中被移除，不再绘制到画面上了。</p>

<p><img src="http://hukai.me/images/android_perf_5_memory_view_remove.png" alt="android_perf_5_memory_view_remove" /></p>

<p>不仅如此，View对象本身对所属的Activity是有引用关系的，如果工作线程持续保有View的引用，这就可能导致Activity无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。例如通常我们会看到在Activity里面定义的一个AsyncTask，这种类型的AsyncTask与外部的Activity是存在隐式引用关系的，只要Task没有结束，引用关系就会一直存在，这很容易导致Activity的泄漏。更糟糕的情况是，它不仅仅发生了内存泄漏，还可能导致程序异常或者崩溃。</p>

<p><img src="http://hukai.me/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>为了解决上面的问题，我们需要谨记的原则就是：不要在任何非UI线程里面去持有UI对象的引用。系统为了确保所有的UI对象都只会被UI线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当Activity被销毁的时候，由该Activity所触发的非UI线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止UI对象被错误的使用。</p>

<h2>4)Good AsyncTask Hunting</h2>

<p>AsyncTask是一个让人既爱又恨的组件，它提供了一种简便的异步处理机制，但是它又同时引入了一些令人厌恶的麻烦。一旦对AsyncTask使用不当，很可能对程序的性能带来负面影响，同时还可能导致内存泄露。</p>

<p>举个例子，常遇到的一个典型的使用场景：用户切换到某个界面，触发了界面上的图片的加载操作，因为图片的加载相对来说耗时比较长，我们需要在子线程中处理图片的加载，当图片在子线程中处理完成之后，再把处理好的图片返回给主线程，交给UI更新到画面上。</p>

<p><img src="http://hukai.me/images/android_perf_5_asynctask_main.png" alt="android_perf_5_asynctask_main" /></p>

<p>AsyncTask的出现就是为了快速的实现上面的使用场景，AsyncTask把在主线程里面的准备工作放到<code>onPreExecute()</code>方法里面进行执行，<code>doInBackground()</code>方法执行在工作线程中，用来处理那些繁重的任务，一旦任务执行完毕，就会调用<code>onPostExecute()</code>方法返回到主线程。</p>

<p><img src="http://hukai.me/images/android_perf_5_asynctask_mode.png" alt="android_perf_5_asynctask_mode" /></p>

<p>使用AsyncTask需要注意的问题有哪些呢？请关注以下几点：</p>

<ul>
<li>首先，默认情况下，所有的AsyncTask任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个AsyncTask，一旦其中的某个AsyncTask执行时间过长，队列中的其他剩余AsyncTask都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。情况如下图所示：</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_5_asynctask_single_queue.png" alt="android_perf_5_asynctask_single_queue" /></p>

<p>为了解决上面提到的线性队列等待的问题，我们可以使用<code>AsyncTask.executeOnExecutor()</code>强制指定AsyncTask使用线程池并发调度任务。</p>

<p><img src="http://hukai.me/images/android_perf_5_asynctask_thread_pool.png" alt="android_perf_5_asynctask_thread_pool" /></p>

<ul>
<li>其次，如何才能够真正的取消一个AsyncTask的执行呢？我们知道AsyncTaks有提供<code>cancel()</code>的方法，但是这个方法实际上做了什么事情呢？线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在<code>doInBackground()</code>的代码中不断的添加程序是否被中止的判断逻辑，如下图所示：</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_5_asynctask_cancel.png" alt="android_perf_5_asynctask_cancel" /></p>

<p>一旦任务被成功中止，AsyncTask就不会继续调用<code>onPostExecute()</code>，而是通过调用<code>onCancelled()</code>的回调方法反馈任务执行取消的结果。我们可以根据任务回调到哪个方法（是onPostExecute还是onCancelled）来决定是对UI进行正常的更新还是把对应的任务所占用的内存进行销毁等。</p>

<ul>
<li>最后，使用AsyncTask很容易导致内存泄漏，一旦把AsyncTask写成Activity的内部类的形式就很容易因为AsyncTask生命周期的不确定而导致Activity发生泄漏。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>综上所述，AsyncTask虽然提供了一种简单便捷的异步机制，但是我们还是很有必要特别关注到他的缺点，避免出现因为使用错误而导致的严重系统性能问题。</p>

<h2>5）Getting a HandlerThread</h2>

<p>大多数情况下，AsyncTask都能够满足多线程并发的场景需要（在工作线程执行任务并返回结果到主线程），但是它并不是万能的。例如打开相机之后的预览帧数据是通过<code>onPreviewFrame()</code>的方法进行回调的，<code>onPreviewFrame()</code>和<code>open()</code>相机的方法是执行在同一个线程的。</p>

<p><img src="http://hukai.me/images/android_perf_5_handlerthread_camera_open.png" alt="android_perf_5_handlerthread_camera_open" /></p>

<p>如果这个回调方法执行在UI线程，那么在onPreviewFrame()里面将要执行的数据转换操作将和主线程的界面绘制，事件传递等操作争抢系统资源，这就有可能影响到主界面的表现性能。</p>

<p><img src="http://hukai.me/images/android_perf_5_handlerthread_main_thread2.png" alt="android_perf_5_handlerthread_main_thread2" /></p>

<p>我们需要确保onPreviewFrame()执行在工作线程。如果使用AsyncTask，会因为AsyncTask默认的线性执行的特性(即使换成并发执行)会导致因为无法把任务及时传递给工作线程而导致任务在主线程中被延迟，直到工作线程空闲，才可以把任务切换到工作线程中进行执行。</p>

<p><img src="http://hukai.me/images/android_perf_5_handlerthread_asynctask.png" alt="android_perf_5_handlerthread_asynctask" /></p>

<p>所以我们需要的是一个执行在工作线程，同时又能够处理队列中的复杂任务的功能，而HandlerThread的出现就是为了实现这个功能的，它组合了Handler，MessageQueue，Looper实现了一个长时间运行的线程，不断的从队列中获取任务进行执行的功能。</p>

<p><img src="http://hukai.me/images/android_perf_5_handlerthread_outline.png" alt="android_perf_5_handlerthread_outline" /></p>

<p>回到刚才的处理相机回调数据的例子，使用HandlerThread我们可以把open()操作与onPreviewFrame()的操作执行在同一个线程，同时还避免了AsyncTask的弊端。如果需要在onPreviewFrame()里面更新UI，只需要调用runOnUiThread()方法把任务回调给主线程就够了。</p>

<p><img src="http://hukai.me/images/android_perf_5_handlerthread_camera.png" alt="android_perf_5_handlerthread_camera" /></p>

<p>HandlerThread比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。</p>

<p>另外很重要的一点是，一旦我们使用了HandlerThread，需要特别注意给HandlerThread设置不同的线程优先级，CPU会根据设置的不同线程优先级对所有的线程进行调度优化。</p>

<p><img src="http://hukai.me/images/android_perf_5_handlerthread_priority.png" alt="android_perf_5_handlerthread_priority" /></p>

<p>掌握HandlerThread与AsyncTask之间的优缺点，可以帮助我们选择合适的方案。</p>

<h2>6）Swimming in Threadpools</h2>

<p>线程池适合用在把任务进行分解，并发进行执行的场景。通常来说，系统里面会针对不同的任务设置一个单独的守护线程用来专门处理这项任务。例如使用Networking Thread用来专门处理网络请求的操作，使用IO Thread用来专门处理系统的I\O操作。针对那些场景，这样设计是没有问题的，因为对应的任务单次执行的时间并不长而且可以是顺序执行的。但是这种专属的单线程并不能满足所有的情况，例如我们需要一次性decode 40张图片，每个线程需要执行4ms的时间，如果我们使用专属单线程的方案，所有图片执行完毕会需要花费160ms(40*4)，但是如果我们创建10个线程，每个线程执行4个任务，那么我们就只需要16ms就能够把所有的图片处理完毕。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpool_1.png" alt="android_perf_5_threadpool_1" /></p>

<p>为了能够实现上面的线程池模型，系统为我们提供了<code>ThreadPoolExecutor</code>帮助类来简化实现，剩下需要做的就只是对任务进行分解就好了。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpool_2.png" alt="android_perf_5_threadpool_2" /></p>

<p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为CPU只能同时执行固定数量的线程数，一旦同时并发的线程数量超过CPU能够同时执行的阈值，CPU就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpool_3.png" alt="android_perf_5_threadpool_3" /></p>

<p>一旦同时并发的线程数量达到一定的量级，这个时候CPU在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少64K+的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpool_4.png" alt="android_perf_5_threadpool_4" /></p>

<p>另外需要关注的一个问题是：<code>Runtime.getRuntime().availableProcesser()</code>方法并不可靠，他返回的值并不是真实的CPU核心数，因为CPU会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的CPU核心数。</p>

<h2>7）The Zen of IntentService</h2>

<p>默认的Service是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的AsyncTask与HandlerThread，我们还可以选择使用IntentService来实现异步操作。IntentService继承自普通Service同时又在内部创建了一个HandlerThread，在<code>onHandlerIntent()</code>的回调里面处理扔到IntentService的任务。所以IntentService就不仅仅具备了异步线程的特性，还同时保留了Service不受主页面生命周期影响的特点。</p>

<p><img src="http://hukai.me/images/android_perf_5_intentservice_outline.png" alt="android_perf_5_intentservice_outline" /></p>

<p>如此一来，我们可以在IntentService里面通过设置闹钟间隔性的触发异步任务，例如刷新数据，更新缓存的图片或者是分析用户操作行为等等，当然处理这些任务需要小心谨慎。</p>

<p>使用IntentService需要特别留意以下几点：</p>

<ul>
<li>首先，因为IntentService内置的是HandlerThread作为异步线程，所以每一个交给IntentService的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</li>
<li>其次，通常使用到IntentService的时候，我们会结合使用BroadcastReceiver把工作线程的任务执行结果返回给主UI线程。使用广播容易引起性能问题，我们可以使用LocalBroadcastManager来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用<code>runOnUiThread()</code>快速回调到主UI线程。</li>
<li>最后，包含正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>


<h2>8）Threading and Loaders</h2>

<p>当启动工作线程的Activity被销毁的时候，我们应该做点什么呢？为了方便的控制工作线程的启动与结束，Android为我们引入了Loader来解决这个问题。我们知道Activity有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在Activity不停的创建与销毁的过程当中，很有可能因为工作线程持有Activity的View而导致内存泄漏(因为工作线程很可能持有View的强引用，另外工作线程的生命周期还无法保证和Activity的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在Activity被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。</p>

<p><img src="http://hukai.me/images/android_perf_5_loader_bad.png" alt="android_perf_5_loader_bad" /></p>

<p>Loader的出现就是为了确保工作线程能够和Activity的生命周期保持一致，同时避免出现前面提到的问题。</p>

<p><img src="http://hukai.me/images/android_perf_5_loader_good.png" alt="android_perf_5_loader_good" /></p>

<p>LoaderManager会对查询的操作进行缓存，只要对应Cursor上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader可以直接把缓存的数据回调到<code>onLoadFinished()</code>，从而避免重新查询数据。另外系统会在Loader不再需要使用到的时候(例如使用Back按钮退出当前页面)回调<code>onLoaderReset()</code>方法，我们可以在这里做数据的清除等等操作。</p>

<p>在Activity或者Fragment中使用Loader可以方便的实现异步加载的框架，Loader有诸多优点。但是实现Loader的这套代码还是稍微有点点复杂，Android官方为我们提供了使用Loader的<a href="http://developer.android.com/intl/zh-cn/reference/android/content/AsyncTaskLoader.html">示例代码</a>进行参考学习。</p>

<h2>9）The Importance of Thread Priority</h2>

<p>理论上来说，我们的程序可以创建出非常多的子线程一起并发执行的，可是基于CPU时间片轮转调度的机制，不可能所有的线程都可以同时被调度执行，CPU需要根据线程的优先级赋予不同的时间片。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpriority_CPU.png" alt="android_perf_5_threadpriority_CPU" /></p>

<p>Android系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为forground的那部分线程会大致占用掉CPU的90%左右的时间片，background的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为forground的程序本身的优先级就更高，理应得到更多的执行时间。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpriority_90.png" alt="android_perf_5_threadpriority_90" /></p>

<p>默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主UI线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占CPU资源，需要把这些线程的优先级进行降低处理，这样才能给帮组CPU识别主次，提高主线程所能得到的系统资源。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpriority_less.png" alt="android_perf_5_threadpriority_less" /></p>

<p>在Android系统里面，我们可以通过<code>android.os.Process.setThreadPriority(int)</code>设置线程的优先级，参数范围从-20到24，数值越小优先级越高。Android系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpriority_const.png" alt="android_perf_5_threadpriority_const" /></p>

<p>大多数情况下，新创建的线程优先级会被设置为默认的0，主线程设置为0的时候，新创建的线程还可以利用<code>THREAD_PRIORITY_LESS_FAVORABLE</code>或者<code>THREAD_PRIORITY_MORE_FAVORABLE</code>来控制线程的优先级。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpriority_value.png" alt="android_perf_5_threadpriority_value" /></p>

<p>Android系统里面的AsyncTask与IntentService已经默认帮助我们设置线程的优先级，但是对于那些非官方提供的多线程工具类，我们需要特别留意根据需要自己手动来设置线程的优先级。</p>

<p><img src="http://hukai.me/images/android_perf_5_threadpriority_asynctask.png" alt="android_perf_5_threadpriority_asynctask" />
<img src="http://hukai.me/images/android_perf_5_threadpriority_intentservice.png" alt="android_perf_5_threadpriority_intentservice" /></p>

<h2>10）Profile GPU Rendering : M Update</h2>

<p>从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process，Execute，Update三大步骤的时间耗费情况。</p>

<p><img src="http://hukai.me/images/android_perf_5_gpu_profiling_old.png" alt="android_perf_5_gpu_profiling_old" /></p>

<p>但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在Android M版本开始，GPU Profiling工具把渲染操作拆解成如下8个详细的步骤进行显示。</p>

<p><img src="http://hukai.me/images/android_perf_5_gpu_profiling_8steps.png" alt="android_perf_5_gpu_profiling_8steps" /></p>

<p>旧版本中提到的Proces，Execute，Update还是继续得到了保留，他们的对应关系如下：</p>

<p><img src="http://hukai.me/images/android_perf_5_gpu_profiling_3steps.png" alt="android_perf_5_gpu_profiling_3steps" /></p>

<p>接下去我们看下其他五个步骤分别代表了什么含义：</p>

<ul>
<li><strong>Sync &amp; Upload</strong>：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</li>
<li><strong>Measure &amp; Layout</strong>：这里表示的是布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</li>
<li><strong>Animation</strong>：表示的是计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</li>
<li><strong>Input Handling</strong>：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</li>
<li><strong>Misc/Vsync Delay</strong>：如果稍加注意，我们可以在开发应用的Log日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况。</li>
</ul>


<!-- ![android_perf_5_gpu_profiling_sync_upload](/images/android_perf_5_gpu_profiling_sync_upload.png) -->


<!-- ![android_perf_5_gpu_profiling_vsync](/images/android_perf_5_gpu_profiling_vsync.png)
 -->


<!-- ![android_perf_5_gpu_profiling_measure](/images/android_perf_5_gpu_profiling_measure.png) -->


<p>上面八种不同的颜色区分了不同的操作所耗费的时间，为了便于我们迅速找出那些有问题的步骤，GPU Profiling工具会显示16ms的阈值线，这样就很容易找出那些不合理的性能问题，再仔细看对应具体哪个步骤相对来说耗费时间比例更大，结合上面介绍的细化步骤，从而快速定位问题，修复问题。</p>

<hr />

<p>首发于CSDN：<a href="http://ms.csdn.net/geek/71031">Android性能优化典范（五）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第4季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-4/"/>
    <updated>2015-12-31T23:39:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-4</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_perf_patterns_season_4.png" alt="android_perf_patterns_season_4" /></p>

<blockquote><p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第4季的课程学习笔记终于在2015年的最后一天完成了，文章共17个段落，包含的内容大致有：优化网络请求的行为，优化安装包的资源文件，优化数据传输的效率，性能优化的几大基础原理等等。因为学习认知水平有限，肯定存在不少理解偏差甚至错误的地方，请多多交流指正！</p></blockquote>

<h2>1)Cachematters for networking</h2>

<p>想要使得Android系统上的网络访问操作更加的高效就必须做好网络数据的缓存。这是提高网络访问性能最基础的步骤之一。从手机的缓存中直接读取数据肯定比从网络上获取数据要更加的便捷高效，特别是对于那些会被频繁访问到的数据，需要把这些数据缓存到设备上，以便更加快速的进行访问。</p>

<p>Android系统上关于网络请求的Http Response Cache是默认关闭的，这样会导致每次即使请求的数据内容是一样的也会需要重复被调用执行，效率低下。我们可以通过下面的代码示例开启<a href="http://developer.android.com/reference/android/net/http/HttpResponseCache.html">HttpResponseCache</a>。</p>

<!-- More -->


<p><img src="http://hukai.me/images/android_perf_4_network_cache_enable.png" alt="android_perf_4_network_cache_enable" /></p>

<p>开启Http Response Cache之后，Http操作相关的返回数据就会缓存到文件系统上，不仅仅是主程序自己编写的网络请求相关的数据会被缓存，另外引入的library库中的网络相关的请求数据也会被缓存到这个Cache中。</p>

<p>网络请求的场景有可以是普通的http请求，也可以打开某个URL去获取数据，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_network_cache_code.png" alt="android_perf_4_network_cache_code" /></p>

<p>我们有两种方式来清除<code>HttpResponseCache</code>的缓存数据：第一种方式是缓存溢出的时候删除最旧最老的文件，第二种方式是通过Http返回Header中的<code>Cache-Control</code>字段来进行控制的。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_network_cache_control.png" alt="android_perf_4_network_cache_control" /></p>

<p>通常来说，<code>HttpResponseCache</code>会缓存所有的返回信息，包括实际的数据与Header的部分.一般情况下，这个Cache会自动根据协议返回<code>Cache-Control</code>的内容与当前缓存的数据量来决定哪些数据应该继续保留，哪些数据应该删除。但是在一些极端的情况下，例如服务器返回的数据没有设置Cache废弃的时间，或者是本地的Cache文件系统与返回的缓存数据有冲突，或者是某些特殊的网络环境导致HttpResponseCache工作异常，在这些情况下就需要我们自己来实现Http的缓存Cache。</p>

<p>实现自定义的http缓存，需要解决两个问题：第一个是实现一个DiskCacheManager，另外一个是制定Cache的缓存策略。关于DiskCacheManager，我们可以扩展Android系统提供的<a href="https://developer.android.com/intl/zh-cn/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">DiskLruCache</a>来实现。而Cache的缓存策略，相对来说复杂一些，我们可能需要把部分JSON数据设计成不能缓存的，另外一些JSON数据设计成可以缓存几天的，把缩略图设计成缓存一两天的等等，为不同的数据类型根据他们的使用特点制定不同的缓存策略。</p>

<p><img src="http://hukai.me/images/android_perf_4_network_cache_diff.png" alt="android_perf_4_network_cache_diff" /></p>

<p>想要比较好的实现这两件事情，如果全部自己从头开始写会比较繁琐复杂，所幸的是，有不少著名的开源框架帮助我们快速的解决了那些问题。我们可以使用<a href="https://developer.android.com/training/volley/index.html">Volly</a>，<a href="http://square.github.io/okhttp/">okHTTP</a>，<a href="http://square.github.io/picasso/">Picasso</a>来实现网络缓存。</p>

<p>实现好网络缓存之后，我们可以使用Android Studio里面的<code>Network Traffic Tools</code>来查看网络数据的请求与返回情况，另外我们还可以使用<a href="https://developer.att.com/application-resource-optimizer">AT&amp;T ARO</a>工具来抓取网络数据包进行分析查看。</p>

<h2>2)Optimizing Network Request Frequencies</h2>

<p>应用程序的一个基础功能是能够保持确保界面上呈现的信息是即时最新的，例如呈现最新的新闻，天气，信息流等等信息。但是，过于频繁的促使手机客户端应用去同步最新的服务器数据会对性能产生很大的负面影响，不仅仅使得CPU不停的在工作，内存，网络流量，电量等等都会持续的被消耗，所以在进行网络请求操作的时候一定要避免多度同步操作。</p>

<p>退到后台的应用为了能够在切换回前台的时候呈现最新的数据，会偷偷在后台不停的做同步的操作。这种行为会带来很严重的问题，首先因为网络请求的行为异常的耗电，其次不停的进行网络同步会耗费很多带宽流量。</p>

<p>为了能够尽量的减少不必要的同步操作，我们需要遵守下面的一些规则：</p>

<ul>
<li>首先我们要对网络行为进行分类，区分需要立即更新数据的行为和其他可以进行延迟的更新行为，为不同的场景进行差异化处理。</li>
<li>其次要避免客户端对服务器的轮询操作，这样会浪费很多的电量与带宽流量。解决这个问题，我们可以使用Google Cloud Message来对更新的数据进行推送。</li>
<li>然后在某些必须做同步的场景下，需要避免使用固定的间隔频率来进行更新操作，我们应该在返回的数据无更新的时候，使用双倍的间隔时间来进行下一次同步。</li>
<li>最后更进一步，我们还可以通过判断当前设备的状态来决定同步的频率，例如判断设备处于休眠，运动等不同的状态设计各自不同时间间隔的同步频率。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_4_network_frequencies_backoff.png" alt="android_perf_4_network_frequencies_backoff" /></p>

<p>另外，我们还可以通过判断设备是否连接上WiFi，是否正在充电来决定更新的频率。为了能够方便的实现这个功能，Android为我们提供了<a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmNetworkManager">GCMNetworkManager</a>来判断设备当下的状态，从而设计更加高效的网络同步操作，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_network_frequencies_gcm.png" alt="android_perf_4_network_frequencies_gcm" /></p>

<h2>3)Effective Prefetching</h2>

<p>关于提升网络操作的性能，除了避免频繁的网络同步操作之外，还可以使用捆绑批量访问的方式来减少访问的频率，为了达到这个目的，我们就需要了解Prefetching。</p>

<p>举个例子，在某个场景下，一开始发出了网络请求得到了某张图片，隔了10s之后，发出第二次请求想要拿到另外一张图片，再隔了6s发出第三张图片的网络请求。这会导致设备的无线蜂窝一直处于高消耗的状态。Prefetching就是预先判定那些可能马上就会使用到的网络资源，捆绑一起集中进行网络请求。这样能够极大的减少电量的消耗，提升设备的续航时间。</p>

<p><img src="http://hukai.me/images/android_perf_4_prefetching_bundle.png" alt="android_perf_4_prefetching_bundle" /></p>

<p>使用Prefetching的难点在于如何判断事先获取的数据量到底是多少，如果预取的数据量偏少，那么就起不到什么效果，但是如果预取过多，又可能导致访问的时间过长。</p>

<p><img src="http://hukai.me/images/android_perf_4_prefetching_tricky.png" alt="android_perf_4_prefetching_tricky" /></p>

<p>那么问题来了，到底预取多少才比较合适呢？一个比较普适的规则是，在3G网络下可以预取1-5Mb的数据量，或者是按照提前预期后续1-2分钟的数据作为基线标准。在实际的操作当中，我们还需要考虑当前的网络速度来决定预取的数据量，例如在同样的时间下，4G网络可以获取到12张图片的数据，而2G网络则只能拿到3张图片的数据。所以，我们还需要把当前的网络环境情况添加到设计预取数据量的策略当中去。判断当前设备的状态与网络情况，可以使用前面提到过的<a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmNetworkManager">GCMNetworkManager</a>。</p>

<h2>4)Adapting to Latency</h2>

<p>网络延迟通常来说很容易被用户察觉到，严重的网络延迟会对用户体验造成很大的影响，用户很容易抱怨应用程序写的不好。</p>

<p>一个典型的网络操作行为，通常包含以下几个步骤：首先手机端发起网络请求，到达网络服务运营商的基站，再转移到服务提供者的服务器上，经过解码之后，接着访问本地的存储数据库，获取到数据之后，进行编码，最后按照原来传递的路径逐层返回。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_network_latency.png" alt="android_perf_4_network_latency" /></p>

<p>在上面的网络请求链路当中的任何一个环节都有可能导致严重的延迟，成为性能瓶颈，但是这些环节可能出现的问题，客户端应用是无法进行调节控制的，应用能够做的就只是根据当前的网络环境选择当下最佳的策略来降低出现网络延迟的概率。主要的实施步骤有两步：第1步检测收集当前的网络环境信息，第2步根据当前收集到的信息进行网络请求行为的调整。</p>

<p>关于第1步检测当前的网络环境，我们可以使用系统提供的API来获取到相关的信息，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_network_latency_detect.png" alt="android_perf_4_network_latency_detect" /></p>

<p>通过上面的示例，我们可以获取到移动网络的详细子类型，例如4G(LTE),3G等等，详细分类见下图，获取到详细的移动网络类型之后，我们可以根据当前网络的速率来调整网络请求的行为：</p>

<p><img src="http://hukai.me/images/android_perf_4_network_latency_subtype.png" alt="android_perf_4_network_latency_subtype" /></p>

<p>关于第2步根据收集到的信息进行策略的调整，通常来说，我们可以把网络请求延迟划分为三档：例如把网络延迟小于60ms的划分为GOOD，大于220ms的划分为BAD，介于两者之间的划分为OK（这里的60ms，220ms会需要根据不同的场景提前进行预算推测）。如果网络延迟属于GOOD的范畴，我们就可以做更多比较激进的预取数据的操作，如果网络延迟属于BAD的范畴，我们就应该考虑把当下的网络请求操作Hold住等待网络状况恢复到GOOD的状态再进行处理。</p>

<p><img src="http://hukai.me/images/android_perf_4_network_latency_three_category.png" alt="android_perf_4_network_latency_three_category" /></p>

<p>前面提到说60ms，220ms是需要提前自己预测的，可是预测的工作相当复杂。首先针对不同的机器与网络环境，网络延迟的三档阈值都不太一样，出现的概率也不尽相同，我们会需要针对这些不同的用户与设备选择不同的阈值进行差异化处理：</p>

<p><img src="http://hukai.me/images/android_perf_4_network_latency_three_level.png" alt="android_perf_4_network_latency_three_level" /></p>

<p>Android官方为了帮助我们设计自己的网络请求策略，为我们提供了模拟器的网络流量控制功能来对实际环境进行模拟测量，或者还可以使用AT&amp;T提供的<a href="http://developer.att.com/developer/legalAgreementPage.jsp?passedItemId=14500040">AT&amp;T Network Attenuator</a>来帮助预估网络延迟。</p>

<h2>5)Minimizing Asset Payload</h2>

<p>为了能够减小网络传输的数据量，我们需要对传输的数据做压缩的处理，这样能够提高网络操作的性能。首先不同的网络环境，下载速度以及网络延迟是存在差异的，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_min_asset_load.png" alt="android_perf_4_min_asset_load" /></p>

<p>如果我们选择在网速更低的网络环境下进行数据传输，这就意味着需要执行更长的时间，而更长的网络操作行为，会导致电量消耗更加严重。另外传输的数据如果不做压缩处理，也同样会增加网络传输的时间，消耗更多的电量。不仅如此，未经过压缩的数据，也会消耗更多的流量，使得用户需要付出更多的流量费。</p>

<p>通常来说，网络传输数据量的大小主要由两部分组成：图片与序列化的数据，那么我们需要做的就是减少这两部分的数据传输大小，分下面两个方面来讨论。</p>

<ul>
<li>A)首先需要做的是减少图片的大小，选择合适的图片保存格式是第一步。下图展示了PNG,JPEG,WEBP三种主流格式在占用空间与图片质量之间的对比：</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_4_min_asset_png_jpeg_webp.png" alt="android_perf_4_min_asset_png_jpeg_webp" /></p>

<p>对于JPEG与WEBP格式的图片，不同的清晰度对占用空间的大小也会产生很大的影响，适当的减少JPG Quality，可以大大的缩小图片占用的空间大小。</p>

<p>另外，我们需要为不同的使用场景提供当前场景下最合适的图片大小，例如针对全屏显示的情况我们会需要一张清晰度比较高的图片，而如果只是显示为缩略图的形式，就只需要服务器提供一个相对清晰度低很多的图片即可。服务器应该支持到为不同的使用场景分别准备多套清晰度不一样的图片，以便在对应的场景下能够获取到最适合自己的图片。这虽然会增加服务端的工作量，可是这个付出却十分值得！</p>

<ul>
<li>B)其次需要做的是减少序列化数据的大小。JSON与XML为了提高可读性，在文件中加入了大量的符号，空格等等字符，而这些字符对于程序来说是没有任何意义的。我们应该使用Protocal Buffers，Nano-Proto-Buffers，FlatBuffer来减小序列化的数据的大小。</li>
</ul>


<p>Android系统为我们提供了工具来查看网络传输的数据情况，打开Android Studio的Monitor，里面有网络访问的模块。或者是打开AT&amp;T提供的<a href="https://developer.att.com/application-resource-optimizer">ARO</a>工具来查看网络请求状态。</p>

<h2>6)Service Performance Patterns</h2>

<p>Service是Android程序里面最常用的基础组件之一，但是使用Service很容易引起电量的过度消耗以及系统资源的未及时释放。学会在何时启用Service以及使用何种方式杀掉Service就显得十分有必要了。</p>

<p>简要过一下Service的特性：Service和UI没有关联，Service的创建，执行，销毁Service都是需要占用系统时间和内存的。另外Service是默认运行在UI线程的，这意味着Service可能会影响到系统的流畅度。</p>

<p>使用Service应该遵循下面的一些规则：</p>

<ul>
<li>避免错误的使用Service，例如我们不应该使用Service来监听某些事件的变化，不应该搞一个Service在后台对服务器不断的进行轮询(应该使用Google Cloud Messaging)</li>
<li>如果已经事先知道Service里面的任务应该执行在后台线程(非默认的主线程)的时候，我们应该使用IntentService或者结合HanderThread，AsycnTask Loader实现的Service。</li>
</ul>


<p>Android系统为我们提供了以下的一些异步相关的工具类</p>

<ul>
<li>GCM</li>
<li>BroadcastReciever</li>
<li>LocalBroadcastReciever</li>
<li>WakefulBroadcastReciver</li>
<li>HandlerThreads</li>
<li>AsyncTaskLoaders</li>
<li>IntentService</li>
</ul>


<p>如果使用上面的诸多方案还是无法替代普通的Service，那么需要注意的就是如何正确的关闭Service。</p>

<ul>
<li>普通的Started Service，需要通过stopSelf()来停止Service</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_4_service_started.png" alt="android_perf_4_service_started" /></p>

<ul>
<li>另外一种Bound Service，会在其他组件都unBind之后自动关闭自己</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_4_service_bound.png" alt="android_perf_4_service_bound" /></p>

<p>把上面两种Service进行合并之后，我们可以得到如下图所示的Service(相关知识，还可以参考<a href="http://hukai.me/android-notes-services/">http://hukai.me/android-notes-services/</a>, <a href="http://hukai.me/android-notes-bound-services/">http://hukai.me/android-notes-bound-services/</a>)</p>

<p><img src="http://hukai.me/images/android_perf_4_service_mix.png" alt="android_perf_4_service_mix" /></p>

<h2>7)Removing unused code</h2>

<p>使用第三方库(library)可以在不用自己编写大量代码的前提下帮助我们解决一些难题，节约大量的时间，但是这些引入的第三方库很可能会导致主程序代码臃肿冗余。</p>

<p>如果我们处在人力，财力都相对匮乏的情况下，通常会倾向大量使用第三方库来帮助编写应用程序。这其实是无可厚非的，那些著名的第三方库的可行性早就被很多应用所采用并实践证明过。但是这里面存在的问题是，如果我们因为只需要某个library的一小部分功能而把整个library都导入自己的项目，这就会引起代码臃肿。一旦发生代码臃肿，用户就会下载到安装包偏大的应用程序，另外因为代码臃肿，还很有可能会超过单个编译文件只能有65536个方法的上限。解决这个问题的办法是使用<strong>MultiDex</strong>的方案，可是这实在是无奈之举，原则上，我们还是应该尽量避免出现这种情况。</p>

<p>Android为我们提供了Proguard的工具来帮助应用程序对代码进行瘦身，优化，混淆的处理。它会帮助移除那些没有使用到的代码，还可以对类名，方法名进行混淆处理以避免程序被反编译。举个例子，Google I/O 2015这个应用使用了大量的library，没有经过Proguard处理之前编译出来的包是8.4Mb大小，经过处理之后的包仅仅是4.1Mb大小。</p>

<p>使用Proguard相当的简单，只需要在build.gradle文件中配置minifEnable为true即可，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_remove_unused_code_proguard.png" alt="android_perf_4_remove_unused_code_proguard" /></p>

<p>但是Proguard还是不足够聪明到能够判断哪些类，哪些方法是不能够被混淆的，针对这些情况，我们需要手动的把这些需要保留的类名与方法名添加到Proguard的配置文件中，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_remove_unused_code_proguard_setting.png" alt="android_perf_4_remove_unused_code_proguard_setting" /></p>

<p>在使用library的时候，需要特别注意这些library在proguard配置上的说明文档，我们需要把这些配置信息添加到自己的主项目中。关于Proguard的详细说明，请看官方文档<a href="http://developer.android.com/tools/help/proguard.html">http://developer.android.com/tools/help/proguard.html</a></p>

<h2>8)Removing unused resources</h2>

<p>减少APK安装包的大小也是Android程序优化中很重要的一个方面，我们不应该给用户下载到一个臃肿的安装包。假设这样一个场景，我们引入了Google Play Service的library，是想要使用里面的Maps的功能，但是里面的登入等等其他功能是不需要的，可是这些功能相关的代码与图片资源，布局资源如果也被引入我们的项目，这样就会导致我们的程序安装包臃肿。</p>

<p>所幸的是，我们可以使用Gradle来帮助我们分析代码，分析引用的资源，对于那些没有被引用到的资源，会在编译阶段被排除在APK安装包之外，要实现这个功能，对我们来说仅仅只需要在build.gradle文件中配置shrinkResource为true就好了，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_remove_unused_resource.png" alt="android_perf_4_remove_unused_resource" /></p>

<p>为了辅助gradle对资源进行瘦身，或者是某些时候的特殊需要，我们可以通过tools:keep或者是tools:discard标签来实现对特定资源的保留与废弃，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_remove_unused_resource_tools.png" alt="android_perf_4_remove_unused_resource_tools" /></p>

<p>Gradle目前无法对values，drawable等根据运行时来决定使用的资源进行优化，对于这些资源，需要我们自己来确保资源不会有冗余。</p>

<h2>9)Perf Theory: Caching</h2>

<p>当我们讨论性能优化的时候，缓存是最常见最有效的策略之一。无论是为了提高CPU的计算速度还是提高数据的访问速度，在绝大多数的场景下，我们都会使用到缓存。关于缓存是如何提高效率的，这里就不赘述了。</p>

<p>那么在什么地方，在何时应该利用好缓存来提高效率呢？请看下面的例子，很明显的演示了在某些细节上是如何利用缓存的原理来提高代码的执行效率的：</p>

<p><img src="http://hukai.me/images/android_perf_4_cache_1.png" alt="android_perf_4_cache_1" />
<img src="http://hukai.me/images/android_perf_4_cache_2.png" alt="android_perf_4_cache_2" /></p>

<p>类似上面的例子采用缓存原理的地方还有很多，例如缓存到内存里面的图片资源，网络请求返回数据的缓存等等。总之，使用缓存就是为了减少不必要的操作，尽量复用已有的对象来提高效率。</p>

<h2>10)Perf Theory: Approximation(近似法)</h2>

<p>很多时候，我们都需要学会在性能更优与体验更好之间做一定的权衡取舍。为了获取更好的表现性能，我们可能会需要牺牲一些用户体验，例如把某些细节做删除或者是降级处理以便有更好的性能。例如，导航类的应用，如果在导航期间是不停的执行定位的操作，这样能够很及时的获取到最新的位置信息以及当下位置相关的其他提示信息，但是这样会导致网络流量以及手机电量的过度消耗。所以我们可以做一定的降级处理，每隔固定的一段时间才去获取一次位置信息，损失一点及时性来换取更长的续航时间。</p>

<p>还有很多地方都会用到近似法则来优化程序的性能，例如使用一张比较接近实际大小的图片来替代原图，换取更快的加载速度。所以对于那些对计算结果要求不需要十分精确的场景，我们可以使用近似法则来提高程序的性能。</p>

<h2>11)Perf Theory: Culling(遴选，挑选)</h2>

<p>在以前的性能优化课程里面，我们知道可以通过减少Overdraw来提高程序的渲染性能（主要手段有移除非必须的background，减少重叠的布局，使用clipRect来提高自定义View的绘制性能），今天在这里要介绍的另外一个提高性能的方法是逐步对数据进行过滤筛选，减小搜索的数据集，以此提高程序的执行性能。例如我们需要搜索到居住在某个地方，年龄是多少，符合某些特定条件的候选人，就可以通过逐层过滤筛选的方式来提高后续搜索的执行效率。</p>

<h2>12)Perf Theory: Threading</h2>

<p>使用多线程并发处理任务，从某种程度上可以快速提高程序的执行性能。对于Android程序来说，主线程通常也成为UI线程，需要处理UI的渲染，响应用户的操作等等。对于那些可能影响到UI线程的任务都需要特别留意是否有必要放到其他的线程来进行处理。如果处理不当，很有可能引起程序ANR。关于多线程的使用建议，可以参考官方的培训课程<a href="http://developer.android.com/training/best-background.html">http://developer.android.com/training/best-background.html</a></p>

<h2>13)Perf Theory: Batching</h2>

<p>关于Batching，在前几季的性能优化课程里面也不止一次提到，下面使用一张图演示下Batching的原理：</p>

<p><img src="http://hukai.me/images/android_perf_4_batching.png" alt="android_perf_4_batching" /></p>

<p>网络请求的批量执行是另外一个比较适合说明batching使用场景的例子，因为每次发起网络请求都相对来说比较耗时耗电，如果能够做到批量一起执行，可以大大的减少电量的消耗。</p>

<p><img src="http://hukai.me/images/android_perf_4_batching_network.png" alt="android_perf_4_batching_network" /></p>

<h2>14)Serialization performance</h2>

<p>数据的序列化是程序代码里面必不可少的组成部分，当我们讨论到数据序列化的性能的时候，需要了解有哪些候选的方案，他们各自的优缺点是什么。首先什么是序列化？用下面的图来解释一下：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation.png" alt="android_perf_4_serialIzation" /></p>

<p>数据序列化的行为可能发生在数据传递过程中的任何阶段，例如网络传输，不同进程间数据传递，不同类之间的参数传递，把数据存储到磁盘上等等。通常情况下，我们会把那些需要序列化的类实现Serializable接口(如下图所示)，但是这种传统的做法效率不高，实施的过程会消耗更多的内存。</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_implement.png" alt="android_perf_4_serialIzation_implement" /></p>

<p>但是我们如果使用GSON库来处理这个序列化的问题，不仅仅执行速度更快，内存的使用效率也更高。Android的XML布局文件会在编译的阶段被转换成更加复杂的格式，具备更加高效的执行性能与更高的内存使用效率。</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_gson.png" alt="android_perf_4_serialIzation_gson" /></p>

<p>下面介绍三个数据序列化的候选方案：</p>

<ul>
<li><strong><a href="https://developers.google.com/protocol-buffers/?utm_campaign=android_series_serialization_performance_101315&amp;utm_source=anddev&amp;utm_medium=yt-annt">Protocal Buffers</a></strong>：强大，灵活，但是对内存的消耗会比较大，并不是移动终端上的最佳选择。</li>
<li><strong><a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt?utm_campaign=android_series_serialization_performance_101315&amp;utm_source=anddev&amp;utm_medium=yt-annt">Nano-Proto-Buffers</a></strong>：基于Protocal，为移动终端做了特殊的优化，代码执行效率更高，内存使用效率更佳。</li>
<li><strong><a href="https://google.github.io/flatbuffers/">FlatBuffers</a></strong>：这个开源库最开始是由Google研发的，专注于提供更优秀的性能。</li>
</ul>


<p>上面这些方案在性能方面的数据对比如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_filesize.png" alt="android_perf_4_serialIzation_filesize" />
<img src="http://hukai.me/images/android_perf_4_serialIzation_encode.png" alt="android_perf_4_serialIzation_encode" /></p>

<p>为了避免序列化带来的性能问题，我们其实可以考虑使用SharedPreference或者SQLite来存储那些数据，避免需要先把那些复杂的数据进行序列化的操作。</p>

<h2>15)Smaller Serialized Data</h2>

<p>数据呈现的顺序以及结构会对序列化之后的空间产生不小的影响。通常来说，一般的数据序列化的过程如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_java_2_json.png" alt="android_perf_4_serialIzation_java_2_json" /></p>

<p>上面的过程，存在两个弊端，第一个是重复的属性名称：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_java_2_json_dup.png" alt="android_perf_4_serialIzation_java_2_json_dup" /></p>

<p>另外一个是GZIP没有办法对上面的数据进行更加有效的压缩，假如相似数据间隔了32k的数据量，这样GZIP就无法进行更加有效的压缩：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_java_2_json_gzip.png" alt="android_perf_4_serialIzation_java_2_json_gzip" /></p>

<p>但是我们稍微改变下数据的记录方式，就可以得到占用空间更小的数据，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_java_2_json2.png" alt="android_perf_4_serialIzation_java_2_json2" /></p>

<p>通过优化，至少有三方面的性能提升，如下图所示：</p>

<p>1）减少了重复的属性名：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_opt_1.png" alt="android_perf_4_serialIzation_opt_1" /></p>

<p>2）使得GZIP的压缩效率更高：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_opt_2.png" alt="android_perf_4_serialIzation_opt_2" /></p>

<p>3）同样的数据类型可以批量优化：</p>

<p><img src="http://hukai.me/images/android_perf_4_serialIzation_opt_3.png" alt="android_perf_4_serialIzation_opt_3" /></p>

<h2>16)Caching UI data</h2>

<p>如今绝大多数的应用界面上呈现的数据都依赖于网络请求返回的结果，如何做到在网络数据返回之前避免呈现一个空白的等待页面呢（当然这里说的是非首次冷启动的情况）？这就会涉及到如何缓存UI界面上的数据。</p>

<p>缓存UI界面上的数据，可以采用方案有存储到文件系统，Preference，SQLite等等，做了缓存之后，这样就可以在请求数据返回结果之前，呈现给用户旧的数据，而不是使用正在加载的方式让用户什么数据都看不到，当然在请求网络最新数据的过程中，需要有正在刷新的提示。至于到底选择哪个方案来对数据进行缓存，就需要根据具体情况来做选择了。</p>

<h2>17)CPU Frequency Scaling</h2>

<p>调节CPU的频率会执行的性能产生较大的影响，为了最大化的延长设备的续航时间，系统会动态调整CPU的频率，频率越高执行代码的速度自然就越快。</p>

<p><img src="http://hukai.me/images/android_perf_4_CPU.png" alt="android_perf_4_CPU" /></p>

<p>Android系统会在电量消耗与表现性能之间不断的做权衡，当有需要的时候会迅速调整CPU的频率到一个比较高负荷的状态，当程序不需要高性能的时候就会降低频率来确保更长的续航时间。</p>

<p><img src="http://hukai.me/images/android_perf_4_CPU_adjust.png" alt="android_perf_4_CPU_adjust" /></p>

<p>Android系统检测到需要调整CPU的频率到CPU频率真的达到对应频率会需要花费大概20ms的时间，在此期间很有可能会因为CPU频率不够而导致代码执行偏慢。</p>

<p><img src="http://hukai.me/images/android_perf_4_CPU_gap.png" alt="android_perf_4_CPU_gap" /></p>

<p>我们可以使用Systrace工具来导出CPU的执行情况，以便帮助定位性能问题。</p>

<hr />

<p>首发于CSDN：<a href="http://geek.csdn.net/news/detail/50692">Android性能优化典范（四）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android开发最佳实践]]></title>
    <link href="http://hukai.me/android-dev-patterns/"/>
    <updated>2015-10-02T15:38:00+08:00</updated>
    <id>http://hukai.me/android-dev-patterns</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_dev_patterns_logo.png" alt="android_dev_patterns_logo" /></p>

<blockquote><p>前段时间，Google公布了<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc-lJo_RGGXL2Psr8vVCTWjM">Android开发最佳实践</a>的一系列课程，涉及到一些平时开发过程中应该保持的良好习惯以及如何使用最新的<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a>来快速实现官方推荐的Material Design样式的应用。下面是个人的学习摘要总结，不对的地方请多多交流指点，谢谢！</p></blockquote>

<h2>1）注意对隐式Intent的运行时检查保护</h2>

<p>类似打开相机，发送图片等隐式Intent，是并不一定能够在所有的Android设备上都正常运行。例如打开相机的隐式Intent，如果系统相机应用被关闭或者不存在相机应用，又或者是相机应用的某些权限被关闭等等情况都可能导致这个隐式的Intent无法正常工作。一旦发生隐式Intent找不到合适的调用组件的情况，系统就会抛出<code>ActivityNotFoundException</code>的异常，如果我们的应用没有对这个异常做任何处理，那应用就会发生Crash。</p>

<p>预防这个问题的最佳解决方案是在发出这个隐式Intent之前调用<code>resolveActivity</code>做检查，关于这个API的解释以及用法如下：</p>

<!-- More -->


<p><img src="http://hukai.me/images/android_dev_patterns_implicit_intent.png" alt="android_dev_patterns_implicit_intent" /></p>

<p>然后这个API的使用范例如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">ACTION_XXX</span><span class="o">);</span>
</span><span class='line'><span class="n">ComponentName</span> <span class="n">componentName</span> <span class="o">=</span> <span class="n">intent</span><span class="o">.</span><span class="na">resolveActivity</span><span class="o">(</span><span class="n">getPackageManager</span><span class="o">());</span>
</span><span class='line'><span class="k">if</span><span class="o">(</span><span class="n">componentName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">componentName</span><span class="o">.</span><span class="na">getClassName</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>2）使用NotificationCompat兼容包来处理消息通知</h2>

<p>为了解决Android系统版本差异导致的Notification兼容性问题，Android官方提供了<code>NotificationCompat</code>兼容类来帮助开发实现体验统一的Notification。通常来说，建立一个Notification至少会有三种元素：图标，标题，文本。我们通常会使用如下的代码来实现一个基础的Notification功能：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_notification_base.png" alt="android_dev_patterns_notification_base" /></p>

<p>上面那段代码，运行时候的效果应该如下所示：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_notification_base_show.png" alt="android_dev_patterns_notification_base_show" /></p>

<p>为了给上面的Notification添加点击之后的响应效果，我们还需要构造一个<code>PendingIntent</code>作为contentIntent，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">PendingIntent</span> <span class="n">intent</span> <span class="o">=</span> <span class="n">xxx</span><span class="o">;</span>
</span><span class='line'><span class="n">builder</span><span class="o">.</span><span class="na">setContentIntent</span><span class="o">(</span><span class="n">intent</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了使得Notification更加的具有辨识度，我们还有可能做如下的设置：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_notification_set_large.png" alt="android_dev_patterns_notification_set_large" /></p>

<p>从Android 4.1开始，Notification可以支持展开显示的模式，这样一来，Notification就演变出了下面4种不同的风格样式：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_notification_4_styles.png" alt="android_dev_patterns_notification_4_styles" /></p>

<p>Notification还提供了快捷操作的功能，如下图所示：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_notification_set_action_show.png" alt="android_dev_patterns_notification_set_action_show" />
<img src="http://hukai.me/images/android_dev_patterns_notification_set_action.png" alt="android_dev_patterns_notification_set_action" /></p>

<p>除了显示在手机上的Notification，我们还可以给Notification分别设置在Wearable，Auto上的不同表现行为，例如针对可穿戴设备上显示Notification，我们可以如下的设置：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_notification_wearable.png" alt="android_dev_patterns_notification_wearable" /></p>

<p>关于更多的Wearable上的Notification相关的知识，还可以参考<a href="https://www.youtube.com/watch?v=N7aJPyvHPgs&amp;feature=iv&amp;src_vid=-iog_fmm6mE&amp;annotation_id=annotation_347477041">Pages of Content</a>与<a href="https://www.youtube.com/watch?v=L4LvKOTkZ7Q&amp;feature=iv&amp;src_vid=-iog_fmm6mE&amp;annotation_id=annotation_2485794965">Stackable Notifications</a></p>

<h2>3）Android 6.0 Marshmallow的运行时权限</h2>

<p>Android 6.0开始引入了新的运行时权限检查授权机制，替代了之前安装应用的时候对权限进行授权的方案。为了避免6.0及以上的机器运行发生运行时异常，我们需要做到至少以下5个步骤：</p>

<ul>
<li><strong>检查系统版本号</strong>：针对6.0以下的系统版本，默认权限在安装的时候已经获取到了，对于6.0开始的版本，才需要做运行时的权限检查。</li>
<li><strong>检查申请的权限</strong>：在使用某个权限之前，需要检查权限是否已经获取到了。</li>
<li><strong>解释申请的权限</strong>：在权限没有获取到的情况下，需要通过<code>shouldShowRequestPermissionRationable()</code>的判断来决定如何给用户进行提示。</li>
<li><strong>执行申请权限操作</strong>：前面判断没有获取到权限，为了能够让功能顺利执行，我们会需要在代码里面再次执行申请此权限的操作。</li>
</ul>


<p><img src="http://hukai.me/images/android_dev_patterns_permission_check.png" alt="android_dev_patterns_permission_check" /></p>

<ul>
<li><strong>处理权限申请的结果</strong>：申请权限之后，我们需要处理申请的响应结果，分别处理权限申请成功与失败的情况</li>
</ul>


<p><img src="http://hukai.me/images/android_dev_patterns_permission_response.png" alt="android_dev_patterns_permission_response" /></p>

<h2>4）使用MediaSessionCompat操作音乐的播放</h2>

<p>MediaSessionCompat来自Android官方的兼容包，通过它可以告诉Android系统与其他的应用，自己正在播放的内容是什么以及自己支持哪些类型的播放控制：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_media_session.png" alt="android_dev_patterns_media_session" /></p>

<p>在Android的官方培训课程中有介绍过关于<a href="http://developer.android.com/training/managing-audio/volume-playback.html">Media Button Receiver</a>的概念，Android系统会把来自蓝牙控制器或者是耳机等其他设备的操作事件转换成Media Button事件传递出来，如果我们的应用程序需要监听这些事件并做出相应的响应，就需要注册MEDIA_BUTTON的action，接收到这些事件之后，再传递给音乐播放模块进行控制处理。</p>

<p><img src="http://hukai.me/images/android_dev_patterns_media_receiver.png" alt="android_dev_patterns_media_receiver" /></p>

<p>基于上面的认知，我们现在演示如何使用MediaSessionCompat，下面演示了如何构造一个MediaSessionCompat以及构造完之后通常需要做的三件事情：设置合理的flag，设置回调（在5.0开始会响应onPlay，onPause等等回调），设置激活。</p>

<p><img src="http://hukai.me/images/android_dev_patterns_media_usage.png" alt="android_dev_patterns_media_usage" /></p>

<p>搭建好了MediaSessionCompat之后，还需要通过<code>MediaMetadataCompat</code>来传递播放的资料信息，通过<code>PlaybackStateCompat</code>来传递播放的状态信息。</p>

<p><img src="http://hukai.me/images/android_dev_patterns_media_set.png" alt="android_dev_patterns_media_set" /></p>

<p>做了上面那些操作之后，MediaSessionCompat的任务就算是完成了。</p>

<p><img src="http://hukai.me/images/android_dev_patterns_media_done.png" alt="android_dev_patterns_media_done" /></p>

<h2>5）使用Toolbar替代ActionBar</h2>

<p>自从MaterialDesign开始，Android官方就开始使用Toolbar替代了原来的ActionBar，现在Toolbar已经加入Support兼容包。Toolbar是一个相比起ActionBar更加丰富，更加灵活的组件，另外它的布局本身还是View Hierarchy的一部分，这就意味着可以对Toolbar执行动画操作，增加点击滑动事件等等，甚至我们还可以在一个页面里面加入两个Toolbar。</p>

<p>为了启用Toolbar，首先要做的事情就是关闭当前Activity的ActionBar。我们可以通过使得Activity的主题继承<code>Theme.AppCompat.NoActionBar</code>，然后在对应的XML布局文件中，添加类似下面的toolbar布局信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="c">&lt;!--Toolbar--&gt;</span>
</span><span class='line'><span class="nt">&lt;android.support.v7.widget.Toolbar</span>
</span><span class='line'>    <span class="na">android:id=</span><span class="s">&quot;@+id/toolbar_layout&quot;</span>
</span><span class='line'>    <span class="na">android:layout_width=</span><span class="s">&quot;match_parent&quot;</span>
</span><span class='line'>    <span class="na">android:layout_height=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>    <span class="na">android:layout_alignParentTop=</span><span class="s">&quot;true&quot;</span>
</span><span class='line'>    <span class="na">android:minHeight=</span><span class="s">&quot;?attr/actionBarSize&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;/android.support.v7.widget.Toolbar&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在布局文件中添加Toolbar的信息之后，需要启动Toolbar替代ActionBar，需要像下面一样做设置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>    <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Toolbar</span> <span class="n">toolbar</span> <span class="o">=</span> <span class="o">(</span><span class="n">Toolbar</span><span class="o">)</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">toolbar_layout</span><span class="o">);</span>
</span><span class='line'>    <span class="n">setSupportActionBar</span><span class="o">(</span><span class="n">toolbar</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于更多Toolbar的细节，请参考官方文档<a href="https://developer.android.com/reference/android/support/v7/widget/Toolbar.html">https://developer.android.com/reference/android/support/v7/widget/Toolbar.html</a></p>

<h2>6）使用AppBarLayout并处理滑动手势</h2>

<p>AppBarLayout是一个在android.support.design兼容包（这里有关于该兼容包的官方博客介绍<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">http://android-developers.blogspot.com/2015/05/android-design-support-library.html</a>）里面的新推出的组件，它是一个垂直方向的LinearLayout，包装了很多Material Design的设计元素，例如滑动手势的处理。我们可以使用<code>app:layout_scrollFlags</code>这样的标签来设置滑动的行为表现。关于App Bar，官方还有这样一段描述：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_appbar_des.png" alt="android_dev_patterns_appbar_des" /></p>

<p>使用AppBarLayout需要注意下面几个要点：</p>

<ul>
<li>首先，AppBarLayout必须作为<code>CoordinatorLayout</code>的直接子View</li>
<li>其次，在AppBarLayout里面必须包含一个ToolBar</li>
<li>最后，在CoordinatorLayout里面可以添加那些可以滑动的组件，例如RecyclerView</li>
</ul>


<p>一个标准的布局文件应该是类似下面结构的：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_appbar_scroll_xml.png" alt="android_dev_patterns_appbar_scroll_xml" /></p>

<p>我们需要注意，在Toolbar里面设置的layout_scrollFlags会影响到滑动之后的显示效果，请看下面的具体解释：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_appbar_scroll_flag.png" alt="android_dev_patterns_appbar_scroll_flag" /></p>

<h2>7）使用SearchView来实现搜索功能</h2>

<p>关于在使用搜索的时候及时显示给用户的候选词，会需要根据数据的类型以及具体的情况做不同的处理，这里先暂时不讨论那一块的内容。</p>

<p><img src="http://hukai.me/images/android_dev_patterns_searchview_show.png" alt="android_dev_patterns_searchview_show" />
<img src="http://hukai.me/images/android_dev_patterns_searchview_tips.png" alt="android_dev_patterns_searchview_tips" /></p>

<p>上面的图示已经清楚的演示了使用SearchView处理搜索的通常情况，关于如何实现这个功能，需要做到以下几个步骤：</p>

<ul>
<li>在Menu的XML文件中，声明使用SearchView</li>
</ul>


<p><img src="http://hukai.me/images/android_dev_patterns_searchview_xml.png" alt="android_dev_patterns_searchview_xml" /></p>

<ul>
<li>在onCreateOptionsMenu的回调函数里面获取到SearchView，并设置监听（请注意使用MenuItemCompat的那行代码，否则会出现很多兼容性问题，获取不到这个View等等奇怪的BUG），在监听回调里面处理业务逻辑</li>
</ul>


<p><img src="http://hukai.me/images/android_dev_patterns_searchview_code.png" alt="android_dev_patterns_searchview_code" /></p>

<p>至此，其实就已经实现了一个基础的搜索功能。但是，如果为了能够让自己的应用的某些功能被Android系统的Search功能检索到，我们就需要做更进一步的操作，例如定义Searchable，实现一个SearchableActivity，响应系统的Search行为等等。国内的应用很少会去关注这个功能，这里就不展开了，感兴趣点击下面的链接进一步学习：<a href="https://developer.android.com/guide/topics/search/index.html">https://developer.android.com/guide/topics/search/index.html</a></p>

<h2>8）Navigation Drawer, DrawerLayout, NavigationView</h2>

<p>Navigation Drawer是Material Design当中很重要的一种设计元素，为了能够快速的实现这种设计，Android在新的design support包里面为我们提供了DrawerLayout与NavigationView。</p>

<p><img src="http://hukai.me/images/android_dev_patterns_navigation_show.png" alt="android_dev_patterns_navigation_show" /></p>

<p>实现这样的一个功能，我们需要在XML中写下类似下面的布局文件</p>

<p><img src="http://hukai.me/images/android_dev_patterns_navigation_xml.png" alt="android_dev_patterns_navigation_xml" /></p>

<p>在NavigationView中有两个重要的标签，app:headerLayout与app:menu，分别代表了拉出菜单的顶部布局与下面的菜单项列表。创建菜单项列表，可以使用类似下面的MenuItem文件：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_navigation_menu.png" alt="android_dev_patterns_navigation_menu" /></p>

<p><code>android:checked</code>表示当前选中的Item，会被系统Highlight出来。除了上面简单的平铺的菜单，还可以使用菜单嵌套的方式实现多级的菜单。关于点击具体某个菜单的时候的监听与响应，需要做如下的设置：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_navigation_click.png" alt="android_dev_patterns_navigation_click" /></p>

<p>除了点击菜单事件，我们还需要处理整个侧滑菜单的打开与关闭事件，当我们给DrawerLayout设置了setDrawerListener之后，可以得到下面两个回调：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_navigation_drawer_event.png" alt="android_dev_patterns_navigation_drawer_event" /></p>

<p>大多数时候，侧滑菜单都是从左到右滑出的，但是我们也可以做到从右往左滑出，只需要在DrawerLayout的菜单布局LinearLayout里面修改一下margin的相关属性即可：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_navigation_right.png" alt="android_dev_patterns_navigation_right" /></p>

<h2>9）Tabs and ViewPager</h2>

<p><img src="http://hukai.me/images/android_dev_patterns_viewpager_show.png" alt="android_dev_patterns_viewpager_show" /></p>

<p>ViewPager是Android上面实现横向滑动的基础组件，能够帮助大家迅速搭建类似上面图示一样的左右滑动交互设计。ViewPager需要使用PagerAdapter来提供内容，除了PagerAdpater，Android还提供了FragmentPagerAdpater与FragmentStatePagerAdapter，前者会把所有的fragment都保存在内存中，以便提高切换速度，后者仅仅保留了fragment状态信息，fragment还是会进行正常的重建与销毁。一个典型的使用demo代码如下：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_viewpager_code.png" alt="android_dev_patterns_viewpager_code" /></p>

<p>为了实现前面图示的Tab与ViewPager的绑定，我们可以使用<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a>提供的<code>TabLayout</code>，仅仅需要按照下面的代码示例一样把TabLayout与ViewPager做一个绑定，就能够实现左右滑动与点击Tab快速切换的功能：</p>

<p><img src="http://hukai.me/images/android_dev_patterns_viewpager_tablayout.png" alt="android_dev_patterns_viewpager_tablayout" /></p>

<p>关于Material Design里面的Tabs设计，请再参考<a href="http://www.google.com/design/spec/components/tabs.html">http://www.google.com/design/spec/components/tabs.html</a>以及官方Training课程里面的<a href="http://developer.android.com/training/implementing-navigation/lateral.html">http://developer.android.com/training/implementing-navigation/lateral.html</a></p>

<h2>10）Making Apps Accessible</h2>

<p>为了照顾部分视力或者听觉不好的用户，我们需要做一定的处理使得自己的应用能够被每一个可用。Android系统为了帮助应用实现辅助功能，提供了诸如文本朗读，触感反馈，指向炳导航，手势导航等等功能来更好的帮助用户使用这些应用。</p>

<p><img src="http://hukai.me/images/android_dev_patterns_accessible_feature.png" alt="android_dev_patterns_accessible_feature" /></p>

<p>为了确保你的应用能够被Android系统提供的辅助功能正常使用，需要做以下三个步骤的检查：</p>

<ul>
<li><strong>Content Description</strong>：确保类似ImageView，ImageButton，CheckBox等组件都包含了content descrption。</li>
</ul>


<p><img src="http://hukai.me/images/android_dev_patterns_accessible_content.png" alt="android_dev_patterns_accessible_content" /></p>

<ul>
<li><strong>Focus Order</strong>：确保给布局里面的关键元素增加了Focus的指示顺序，只有这样，辅助功能才能够在指向导航的时候帮助用户按照指定的顺序来聚焦界面元素。</li>
</ul>


<p><img src="http://hukai.me/images/android_dev_patterns_accessible_focus_order.png" alt="android_dev_patterns_accessible_focus_order" />
<img src="http://hukai.me/images/android_dev_patterns_accessible_focus_code.png" alt="android_dev_patterns_accessible_focus_code" /></p>

<ul>
<li><strong>Feedback Mechanisms</strong>：确保部分关键的操作有多个反馈，例如当短信来的时候，既有声音也有震动，这样才能够确保听力不好的用户可以通过震动的反馈来感知到响应。</li>
</ul>


<p>更多关于辅助功能的知识，请参考<a href="http://developer.android.com/guide/topics/ui/accessibility/checklist.html">http://developer.android.com/guide/topics/ui/accessibility/checklist.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android内存优化之OOM]]></title>
    <link href="http://hukai.me/android-performance-oom/"/>
    <updated>2015-09-12T14:53:00+08:00</updated>
    <id>http://hukai.me/android-performance-oom</id>
    <content type="html"><![CDATA[<blockquote><p>Android的内存优化是性能优化中很重要的一部分，而避免OOM又是内存优化中比较核心的一点，这是一篇关于内存优化中如何避免OOM的总结性概要文章，内容大多都是和OOM有关的实践总结概要。理解错误或是偏差的地方，还请多包涵指正，谢谢！</p></blockquote>

<h2>(一)Android的内存管理机制</h2>

<p>Google在Android的官网上有这样一篇文章，初步介绍了Android是如何管理应用的进程与内存分配：<a href="http://developer.android.com/training/articles/memory.html">http://developer.android.com/training/articles/memory.html</a>。
Android系统的Dalvik虚拟机扮演了常规的内存垃圾自动回收的角色，Android系统没有为内存提供交换区，它使用<a href="http://en.wikipedia.org/wiki/Paging">paging</a>与<a href="http://en.wikipedia.org/wiki/Memory-mapped_files">memory-mapping(mmapping)</a>的机制来管理内存，下面简要概述一些Android系统中重要的内存管理基础概念。</p>

<h3>1）共享内存</h3>

<p>Android系统通过下面几种方式来实现共享内存：</p>

<ul>
<li>Android应用的进程都是从一个叫做Zygote的进程fork出来的。Zygote进程在系统启动并且载入通用的framework的代码与资源之后开始启动。为了启动一个新的程序进程，系统会fork Zygote进程生成一个新的进程，然后在新的进程中加载并运行应用程序的代码。这使得大多数的RAM pages被用来分配给framework的代码，同时使得RAM资源能够在应用的所有进程之间进行共享。</li>
<li>大多数static的数据被mmapped到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。常见的static数据包括Dalvik Code，app resources，so文件等。</li>
<li>大多数情况下，Android通过显式的分配共享内存区域(例如ashmem或者gralloc)来实现动态RAM区域能够在不同进程之间进行共享的机制。例如，Window Surface在App与Screen Compositor之间使用共享的内存，Cursor Buffers在Content Provider与Clients之间共享内存。</li>
</ul>


<!-- More -->


<h3>2）分配与回收内存</h3>

<ul>
<li>每一个进程的Dalvik heap都反映了使用内存的占用范围。这就是通常逻辑意义上提到的Dalvik Heap Size，它可以随着需要进行增长，但是增长行为会有一个系统为它设定的上限。</li>
<li>逻辑上讲的Heap Size和实际物理意义上使用的内存大小是不对等的，Proportional Set Size(PSS)记录了应用程序自身占用以及和其他进程进行共享的内存。</li>
<li>Android系统并不会对Heap中空闲内存区域做碎片整理。系统仅仅会在新的内存分配之前判断Heap的尾端剩余空间是否足够，如果空间不够会触发gc操作，从而腾出更多空闲的内存空间。在Android的高级系统版本里面针对Heap空间有一个Generational Heap Memory的模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。系统会根据内存中不同的内存数据类型分别执行不同的gc操作。例如，刚分配到Young Generation区域的对象通常更容易被销毁回收，同时在Young Generation区域的gc操作速度会比Old Generation区域的gc操作速度更快。如下图所示：</li>
</ul>


<p><img src="http://hukai.me/images/memory_mode_generation.png" alt="memory_mode_generation" />
<img src="http://hukai.me/images/android_memory_gc_mode.png" alt="android_memory_gc_mode" /></p>

<p>每一个Generation的内存区域都有固定的大小，随着新的对象陆续被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发GC的操作，以便腾出空间来存放其他新的对象。如下图所示：</p>

<p><img src="http://hukai.me/images/gc_threshold.png" alt="gc_threshold" /></p>

<p>通常情况下，GC发生的时候，所有的线程都是会被暂停的。执行GC所占用的时间和它发生在哪一个Generation也有关系，Young Generation中的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。执行时间的长短也和当前Generation中的对象数量有关，遍历树结构查找20000个对象比起遍历50个对象自然是要慢很多的。</p>

<h3>3）限制应用的内存</h3>

<ul>
<li>为了整个Android系统的内存控制需要，Android系统为每一个应用程序都设置了一个硬性的Dalvik Heap Size最大限制阈值，这个阈值在不同的设备上会因为RAM大小不同而各有差异。如果你的应用占用内存空间已经接近这个阈值，此时再尝试分配内存的话，很容易引起<code>OutOfMemoryError</code>的错误。</li>
<li><code>ActivityManager.getMemoryClass()</code>可以用来查询当前应用的Heap Size阈值，这个方法会返回一个整数，表明你的应用的Heap Size阈值是多少Mb(megabates)。</li>
</ul>


<h3>4）应用切换操作</h3>

<ul>
<li>Android系统并不会在用户切换应用的时候做交换内存的操作。Android会把那些不包含Foreground组件的应用进程放到LRU Cache中。例如，当用户开始启动了一个应用，系统会为它创建了一个进程，但是当用户离开这个应用，此进程并不会立即被销毁，而是会被放到系统的Cache当中，如果用户后来再切换回到这个应用，此进程就能够被马上完整的恢复，从而实现应用的快速切换。</li>
<li>如果你的应用中有一个被缓存的进程，这个进程会占用一定的内存空间，它会对系统的整体性能有影响。因此当系统开始进入Low Memory的状态时，它会由系统根据LRU的规则与应用的优先级，内存占用情况以及其他因素的影响综合评估之后决定是否被杀掉。</li>
<li>对于那些非foreground的进程，Android系统是如何判断Kill掉哪些进程的问题，请参考<a href="http://developer.android.com/guide/components/processes-and-threads.html">Processes and Threads</a>。</li>
</ul>


<h2>(二)OOM（OutOfMemory）</h2>

<p>前面我们提到过使用getMemoryClass()的方法可以得到Dalvik Heap的阈值。简要的获取某个应用的内存占用情况可以参考下面的示例（
关于更多内存查看的知识，可以参考这篇官方教程：<a href="http://developer.android.com/tools/debugging/debugging-memory.html">Investigating Your RAM Usage</a>
）</p>

<h3>1）查看内存使用情况</h3>

<ul>
<li>通过命令行查看内存详细占用情况：</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_oom_dumpsys_meminfo.png" alt="android_perf_oom_dumpsys_meminfo.png" /></p>

<ul>
<li>通过Android Studio的Memory Monitor查看内存中Dalvik Heap的实时变化</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_oom_studio_mem_monitor.png" alt="android_perf_oom_studio_mem_monitor" />
<img src="http://hukai.me/images/memory_monitor_free_allocation.png" alt="memory_monitor_free_allocation" />
<img src="http://hukai.me/images/memory_monitor_gc_event.png" alt="memory_monitor_gc_event" /></p>

<h3>2）发生OOM的条件</h3>

<p>关于Native Heap，Dalvik Heap，Pss等内存管理机制比较复杂，这里不展开描述。简单的说，通过不同的内存分配方式（malloc/mmap/JNIEnv/etc）对不同的对象（bitmap，etc）进行操作会因为Android系统版本的差异而产生不同的行为，对Native Heap与Dalvik Heap以及OOM的判断条件都会有所影响。在2.x的系统上，我们常常可以看到Heap Size的total值明显超过了通过getMemoryClass()获取到的阈值而不会发生OOM的情况，那么针对2.x与4.x的Android系统，到底是如何判断会发生OOM呢？</p>

<ul>
<li><p>Android 2.x系统
GC LOG中的dalvik allocated + external allocated + 新分配的大小 >= getMemoryClass()值的时候就会发生OOM。
例如，假设有这么一段Dalvik输出的GC LOG：GC_FOR_MALLOC free 2K, 13% free 32586K/37455K, external 8989K/10356K, paused 20ms，那么32586+8989+(新分配23975)=65550>64M时，就会发生OOM。</p></li>
<li><p>Android 4.x系统
Android 4.x的系统废除了external的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 >= getMemoryClass()的时候就会发生OOM，如下图所示（虽然图示演示的是art运行环境，但是统计规则还是和dalvik保持一致）</p></li>
</ul>


<p><img src="http://hukai.me/images/android_perf_oom_gc_log.png" alt="android_perf_oom_gc_log.png" /></p>

<h2>(三)如何避免OOM总结</h2>

<p>前面介绍了一些基础的内存管理机制以及OOM的基础知识，那么在实践操作当中，有哪些指导性的规则可以参考呢？归纳下来，可以从四个方面着手，首先是减小对象的内存占用，其次是内存对象的重复利用，然后是避免对象的内存泄露，最后是内存使用策略优化。</p>

<h3>减小对象的内存占用</h3>

<p>避免OOM的第一步就是要尽量减少新分配出来的对象占用内存的大小，尽量使用更加轻量的对象。</p>

<h4>1）使用更加轻量的数据结构</h4>

<p>例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构，下图演示了HashMap的简要工作原理，相比起Android系统专门为移动操作系统编写的ArrayMap容器，在大多数情况下，都显示效率低下，更占内存。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。</p>

<p><img src="http://hukai.me/images/android_perf_3_arraymap_key_value.png" alt="android_perf_3_arraymap_key_value" /></p>

<p>关于更多ArrayMap/SparseArray的讨论，请参考<a href="http://hukai.me/android-performance-patterns-season-3/">http://hukai.me/android-performance-patterns-season-3/</a>的前三个段落</p>

<h4>2）避免在Android里面使用Enum</h4>

<p>Android官方培训课程提到过<strong>&#8220;Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.&#8221;</strong>，具体原理请参考<a href="http://hukai.me/android-performance-patterns-season-3/">http://hukai.me/android-performance-patterns-season-3/</a>，所以请避免在Android里面使用到枚举。</p>

<h4>3）减小Bitmap对象的内存占用</h4>

<p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p>

<ul>
<li>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</li>
<li>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。</li>
</ul>


<h4>4）使用更小的图片</h4>

<p>在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p>

<h3>内存对象的重复利用</h3>

<p>大多数对象的复用，最终实施的方案都是利用对象池技术，要么是在编写代码的时候显式的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。</p>

<p><img src="http://hukai.me/images/android_perf_2_object_pool.png" alt="android_perf_2_object_pool" /></p>

<p>在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，简要操作原理如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_lru_mode.png" alt="android_perf_2_lru_mode" /></p>

<h4>1）复用系统自带的资源</h4>

<p>Android系统本身内置了很多的资源，例如字符串/颜色/图片/动画/样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小APK的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意Android系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p>

<h4>2）注意在ListView/GridView等出现大量重复子组件的视图里面对ConvertView的复用</h4>

<p><img src="http://hukai.me/images/android_perf_oom_listview_recycle.png" alt="android_perf_oom_listview_recycle" /></p>

<h4>3）Bitmap对象的复用</h4>

<ul>
<li>在ListView与GridView等显示大量图片的控件里面需要使用LRU的机制来缓存处理好的Bitmap。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_2_inbitmap_old.png" alt="android_perf_2_inbitmap_old" /></p>

<ul>
<li>利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率上的提升(3.0以及4.4以后存在一些使用限制上的差异)。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_2_inbitmap_new.png" alt="android_perf_2_inbitmap_new" /></p>

<p>使用inBitmap需要注意几个限制条件：</p>

<ul>
<li>在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li>
<li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。
我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_2_inbitmap_pool.png" alt="android_perf_2_inbitmap_pool" /></p>

<p>另外提一点：在2.x的系统上，尽管bitmap是分配在native层，但是还是无法避免被计算到OOM的引用计数器里面。这里提示一下，不少应用会通过反射BitmapFactory.Options里面的inNativeAlloc来达到扩大使用内存的目的，但是如果大家都这么做，对系统整体会造成一定的负面影响，建议谨慎采纳。</p>

<h4>4）避免在onDraw方法里面执行对象的创建</h4>

<p>类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p>

<h4>5）StringBuilder</h4>

<p>在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p>

<h3>避免对象的内存泄露</h3>

<p>内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现OOM。显然，这还使得每级Generation的内存区域可用空间变小，gc就会更容易被触发，容易出现内存抖动，从而引起性能问题。</p>

<p><img src="http://hukai.me/images/android_perf_3_leak.png" alt="android_perf_3_leak" /></p>

<p>最新的LeakCanary开源控件，可以很好的帮助我们发现内存泄露的情况，更多关于LeakCanary的介绍，请看这里<a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a>(中文使用说明<a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/">http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/</a>)。另外也可以使用传统的MAT工具查找内存泄露，请参考这里<a href="http://android-developers.blogspot.pt/2011/03/memory-analysis-for-android.html">http://android-developers.blogspot.pt/2011/03/memory-analysis-for-android.html</a>（便捷的中文资料<a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/</a>）</p>

<h4>1）注意Activity的泄漏</h4>

<p>通常来说，Activity的泄漏是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的Activity泄漏：</p>

<ul>
<li>内部类引用导致Activity的泄漏</li>
</ul>


<p>最典型的场景是Handler导致的Activity泄漏，如果Handler中有延迟的任务或者是等待执行的任务队列过长，都有可能因为Handler继续执行而导致Activity发生泄漏。此时的引用关系链是Looper -> MessageQueue ->  Message -> Handler -> Activity。为了解决这个问题，可以在UI退出之前，执行remove Handler消息队列中的消息与runnable对象。或者是使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。</p>

<ul>
<li>Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。</li>
</ul>


<p>内部类引起的泄漏不仅仅会发生在Activity上，其他任何内部类出现的地方，都需要特别留意！我们可以考虑尽量使用static类型的内部类，同时使用WeakReference的机制来避免因为互相引用而出现的泄露。</p>

<h4>2）考虑使用Application Context而不是Activity Context</h4>

<p>对于大部分非必须使用Activity Context的情况（Dialog的Context就必须是Activity Context），我们都可以考虑使用Application Context而不是Activity的Context，这样可以避免不经意的Activity泄露。</p>

<h4>3）注意临时Bitmap对象的及时回收</h4>

<p>虽然在大多数情况下，我们会对Bitmap增加缓存机制，但是在某些时候，部分Bitmap是需要及时回收的。例如临时创建的某个相对比较大的bitmap对象，在经过变换得到新的bitmap对象之后，应该尽快回收原始的bitmap，这样能够更快释放原始bitmap所占用的空间。</p>

<p>需要特别留意的是Bitmap类里面提供的createBitmap()方法：</p>

<p><img src="http://hukai.me/images/android_perf_oom_create_bitmap.png" alt="android_perf_oom_create_bitmap.png" /></p>

<p>这个函数返回的bitmap有可能和source bitmap是同一个，在回收的时候，需要特别检查source bitmap与return bitmap的引用是否相同，只有在不等的情况下，才能够执行source bitmap的recycle方法。</p>

<h4>4）注意监听器的注销</h4>

<p>在Android程序里面存在很多需要register与unregister的监听器，我们需要确保在合适的时候及时unregister那些监听器。自己手动add的listener，需要记得及时remove这个listener。</p>

<h4>5）注意缓存容器中的对象泄漏</h4>

<p>有时候，我们为了提高对象的复用性把某些对象放到缓存容器中，可是如果这些对象没有及时从容器中清除，也是有可能导致内存泄漏的。例如，针对2.3的系统，如果把drawable添加到缓存容器，因为drawable与View的强应用，很容易导致activity发生泄漏。而从4.0开始，就不存在这个问题。解决这个问题，需要对2.3系统上的缓存drawable做特殊封装，处理引用解绑的问题，避免泄漏的情况。</p>

<h4>6）注意WebView的泄漏</h4>

<p>Android中的WebView存在很大的兼容性问题，不仅仅是Android系统版本的不同对WebView产生很大的差异，另外不同的厂商出货的ROM里面WebView也存在着很大的差异。更严重的是标准的WebView存在内存泄露的问题，看这里<a href="https://code.google.com/p/android/issues/detail?id=5067">WebView causes memory leak - leaks the parent Activity</a>。所以通常根治这个问题的办法是为WebView开启另外一个进程，通过AIDL与主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>

<h4>7）注意Cursor对象是否及时关闭</h4>

<p>在程序中我们经常会进行查询数据库的操作，但时常会存在不小心使用Cursor之后没有及时关闭的情况。这些Cursor的泄露，反复多次出现的话会对内存管理产生很大的负面影响，我们需要谨记对Cursor对象的及时关闭。</p>

<h3>内存使用策略优化</h3>

<h4>1）谨慎使用large heap</h4>

<p>正如前面提到的，Android设备根据硬件与软件的设置差异而存在不同大小的内存空间，他们为应用程序设置了不同大小的Heap限制阈值。你可以通过调用<code>getMemoryClass()</code>来获取应用的可用Heap大小。在一些特殊的情景下，你可以通过在<code>manifest</code>的<code>application</code>标签下添加<code>largeHeap=true</code>的属性来为应用声明一个更大的heap空间。然后，你可以通过<code>getLargeMemoryClass()</code>来获取到这个更大的heap size阈值。然而，声明得到更大Heap阈值的本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用更多的内存而去请求一个大的Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用large heap。因此请谨慎使用large heap属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次gc的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行<code>getMemoryClass()</code>来检查实际获取到的heap大小。</p>

<h4>2）综合考虑设备内存阈值与其他因素设计合适的缓存大小</h4>

<p>例如，在设计ListView或者GridView的Bitmap LRU缓存的时候，需要考虑的点有：</p>

<ul>
<li>应用程序剩下了多少可用的内存空间?</li>
<li>有多少图片会被一次呈现到屏幕上？有多少图片需要事先缓存好以便快速滑动时能够立即显示到屏幕？</li>
<li>设备的屏幕大小与密度是多少? 一个xhdpi的设备会比hdpi需要一个更大的Cache来hold住同样数量的图片。</li>
<li>不同的页面针对Bitmap的设计的尺寸与配置是什么，大概会花费多少内存？</li>
<li>页面图片被访问的频率？是否存在其中的一部分比其他的图片具有更高的访问频繁？如果是，也许你想要保存那些最常访问的到内存中，或者为不同组别的位图(按访问频率分组)设置多个LruCache容器。</li>
</ul>


<h4>3）onLowMemory()与onTrimMemory()</h4>

<p>Android用户可以随意在不同的应用之间进行快速切换。为了让background的应用能够迅速的切换到forground，每一个background的应用都会占用一定的内存。Android系统会根据当前的系统的内存使用情况，决定回收部分background的应用内存。如果background的应用从暂停状态直接被恢复到forground，能够获得较快的恢复体验，如果background应用是从Kill的状态进行恢复，相比之下就显得稍微有点慢。</p>

<p><img src="http://hukai.me/images/android_perf_3_memory_bg_2_for.png" alt="android_perf_3_memory_bg_2_for" /></p>

<ul>
<li><strong>onLowMemory()</strong>：Android系统提供了一些回调来通知当前应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到onLowMemory()的回调。在这种情况下，需要尽快释放当前应用的非必须的内存资源，从而确保系统能够继续稳定运行。</li>
<li><p><strong>onTrimMemory(int)</strong>：Android系统从4.0开始还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，收到onTrimMemory()回调的时候，需要根据传递的参数类型进行判断，合理的选择释放自身的一些内存占用，一方面可以提高系统的整体运行流畅度，另外也可以避免自己被系统判断为优先需要杀掉的应用。下图介绍了各种不同的回调参数：</p></li>
<li><p><strong>TRIM_MEMORY_UI_HIDDEN</strong>：你的应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键退出应用，导致应用的UI界面完全不可见。这个时候应该释放一些不可见的时候非必须的资源</p></li>
</ul>


<p>当程序正在前台运行的时候，可能会接收到从onTrimMemory()中返回的下面的值之一：</p>

<ul>
<li><strong>TRIM_MEMORY_RUNNING_MODERATE</strong>：你的应用正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。</li>
<li><strong>TRIM_MEMORY_RUNNING_LOW</strong>：你的应用正在运行且没有被列为可杀死的。但是设备正运行于更低内存的状态下，你应该释放不用的资源用来提升系统性能。</li>
<li><strong>TRIM_MEMORY_RUNNING_CRITICAL</strong>：你的应用仍在运行，但是系统已经把LRU Cache中的大多数进程都已经杀死，因此你应该立即释放所有非必须的资源。如果系统不能回收到足够的RAM数量，系统将会清除所有的LRU缓存中的进程，并且开始杀死那些之前被认为不应该杀死的进程，例如那个包含了一个运行态Service的进程。</li>
</ul>


<p>当应用进程退到后台正在被Cached的时候，可能会接收到从onTrimMemory()中返回的下面的值之一：</p>

<ul>
<li><strong>TRIM_MEMORY_BACKGROUND</strong>: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的应用进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的应用的时候才能够迅速恢复。</li>
<li><strong>TRIM_MEMORY_MODERATE</strong>: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。</li>
<li><strong>TRIM_MEMORY_COMPLETE</strong>: 系统正运行于低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的应用恢复状态的资源。</li>
</ul>


<p><img src="http://hukai.me/images/android_perf_3_memory_ontrimmemory.png" alt="android_perf_3_memory_ontrimmemory" /></p>

<ul>
<li>因为onTrimMemory()的回调是在API 14才被加进来的，对于老的版本，你可以使用onLowMemory)回调来进行兼容。onLowMemory相当与TRIM_MEMORY_COMPLETE。</li>
<li>请注意：当系统开始清除LRU缓存中的进程时，虽然它首先按照LRU的顺序来执行操作，但是它同样会考虑进程的内存使用量以及其他因素。占用越少的进程越容易被留下来。</li>
</ul>


<h4>4）资源文件需要选择合适的文件夹进行存放</h4>

<p>我们知道<code>hdpi/xhdpi/xxhdpi</code>等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100<em>100的图片，那么根据换算关系，<code>xxhdpi</code>的手机去引用那张图片就会被拉伸到200</em>200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</p>

<h4>5）Try catch某些大内存分配的操作</h4>

<p>在某些情况下，我们需要事先评估那些可能发生OOM的代码，对于这些可能发生OOM的代码，加入catch机制，可以考虑在catch里面尝试一次降级的内存分配操作。例如decode bitmap的时候，catch到OOM，可以尝试把采样比例再增加一倍之后，再次尝试decode。</p>

<h4>6）谨慎使用static对象</h4>

<p>因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象。</p>

<p><img src="http://hukai.me/images/android_perf_3_leak_static.png" alt="android_perf_3_leak_static" /></p>

<h4>7）特别留意单例对象中不合理的持有</h4>

<p>虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。</p>

<h4>8）珍惜Services资源</h4>

<p>如果你的应用需要在后台使用service，除非它被触发并执行一个任务，否则其他时候Service都应该是停止状态。另外需要注意当这个service完成任务之后因为停止service失败而引起的内存泄漏。
当你启动一个Service，系统会倾向为了保留这个Service而一直保留Service所在的进程。这使得进程的运行代价很高，因为系统没有办法把Service所占用的RAM空间腾出来让给其他组件，另外Service还不能被Paged out。这减少了系统能够存放到LRU缓存当中的进程数量，它会影响应用之间的切换效率，甚至会导致系统内存使用不稳定，从而无法继续保持住所有目前正在运行的service。
建议使用<a href="http://developer.android.com/reference/android/app/IntentService.html">IntentService</a>，它会在处理完交代给它的任务之后尽快结束自己。更多信息，请阅读<a href="http://developer.android.com/training/run-background-service/index.html">Running in a Background Service</a>。</p>

<h4>9）优化布局层次，减少内存消耗</h4>

<p>越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的View无法实现足够扁平的时候考虑使用自定义View来达到目的。</p>

<h4>10）谨慎使用“抽象”编程</h4>

<p>很多时候，开发者会使用抽象类作为”好的编程实践”，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的额外内存开销：他们需要同等量的代码用于可执行，那些代码会被mapping到内存中，因此如果你的抽象没有显著的提升效率，应该尽量避免他们。</p>

<h4>11）使用nano protobufs序列化数据</h4>

<p>Protocol buffers是由Google为序列化结构数据而设计的，一种语言无关，平台无关，具有良好的扩展性。类似XML，却比XML更加轻量，快速，简单。如果你需要为你的数据实现序列化与协议化，建议使用nano protobufs。关于更多细节，请参考<a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt">protobuf readme</a>的”Nano version”章节。</p>

<h4>12）谨慎使用依赖注入框架</h4>

<p>使用类似Guice或者RoboGuice等框架注入代码，在某种程度上可以简化你的代码。下面是使用RoboGuice前后的对比图：</p>

<p><img src="http://hukai.me/images/android_perf_oom_roboguice_1.png" alt="android_perf_oom_roboguice_1" />
<img src="http://hukai.me/images/android_perf_oom_roboguice_2.png" alt="android_perf_oom_roboguice_2" /></p>

<p>使用RoboGuice之后，代码是简化了不少。然而，那些注入框架会通过扫描你的代码执行许多初始化的操作，这会导致你的代码需要大量的内存空间来mapping代码，而且mapped pages会长时间的被保留在内存中。除非真的很有必要，建议谨慎使用这种技术。</p>

<h4>13）谨慎使用多进程</h4>

<p>使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p>

<p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的应用可以切分成2个进程：一个用来操作UI，另外一个给后台的Service。</p>

<h4>14）使用ProGuard来剔除不需要的代码</h4>

<p><a href="http://developer.android.com/tools/help/proguard.html">ProGuard</a>能够通过移除不需要的代码，重命名类，域与方法等等对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够减少mapping代码所需要的内存空间。</p>

<h4>15）谨慎使用第三方libraries</h4>

<p>很多开源的library代码都不是为移动网络环境而编写的，如果运用在移动设备上，并不一定适合。即使是针对Android而设计的library，也需要特别谨慎，特别是在你不知道引入的library具体做了什么事情的时候。例如，其中一个library使用的是nano protobufs, 而另外一个使用的是micro protobufs。这样一来，在你的应用里面就有2种protobuf的实现方式。这样类似的冲突还可能发生在输出日志，加载图片，缓存等等模块里面。另外不要为了1个或者2个功能而导入整个library，如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案。</p>

<h4>16）考虑不同的实现方式来优化内存占用</h4>

<p>在某些情况下，设计的某个方案能够快速实现需求，但是这个方案却可能在内存占用上表现的效率不够好。例如：</p>

<p><img src="http://hukai.me/images/android_perf_2_waer_animation.png" alt="android_perf_2_waer_animation" /></p>

<p>对于上面这样一个时钟表盘的实现，最简单的就是使用很多张包含指针的表盘图片，使用帧动画实现指针的旋转。但是如果把指针扣出来，单独进行旋转绘制，显然比载入N多张图片占用的内存要少很多。当然这样做，代码复杂度上会有所增加，这里就需要在优化内存占用与实现简易度之间进行权衡了。</p>

<hr />

<p>写在最后：</p>

<ul>
<li>设计风格很大程度上会影响到程序的内存与性能，相对来说，如果大量使用类似Material Design的风格，不仅安装包可以变小，还可以减少内存的占用，渲染性能与加载性能都会有一定的提升。</li>
<li>内存优化并不就是说程序占用的内存越少就越好，如果因为想要保持更低的内存占用，而频繁触发执行gc操作，在某种程度上反而会导致应用性能整体有所下降，这里需要综合考虑做一定的权衡。</li>
<li>Android的内存优化涉及的知识面还有很多：内存管理的细节，垃圾回收的工作原理，如何查找内存泄漏等等都可以展开讲很多。OOM是内存优化当中比较突出的一点，尽量减少OOM的概率对内存优化有着很大的意义。</li>
</ul>


<hr />

<p>参考资料：</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=_CruQY55HOk">Google I/O 2011: Memory management for Android Apps</a></li>
<li><a href="http://developer.android.com/training/articles/memory.html">Managing Your App&#8217;s Memory</a></li>
<li><a href="http://android-developers.blogspot.com/2009/01/avoiding-memory-leaks.html">Avoiding memory leaks</a></li>
<li><a href="http://hukai.me/android-performance-patterns-season-3/">Android性能优化典范 - 第3季</a></li>
<li><a href="http://hukai.me/android-performance-patterns-season-2/">Android性能优化典范 - 第2季</a></li>
<li><a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a></li>
<li><a href="http://hukai.me/android-performance-memory/">Android性能优化之内存篇</a></li>
<li>其他</li>
</ul>


<p><strong>本文刊登于CSDN《程序员》10月A刊上，如需转载请与CSDN联系</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第3季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-3/"/>
    <updated>2015-08-11T23:53:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-3</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_perf_patterns_season_3.png" alt="android_perf_patterns_season_3" /></p>

<blockquote><p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>的课程最近更新到第三季了，这次一共12个短视频课程，包括的内容大致有：更高效的ArrayMap容器，使用Android系统提供的特殊容器来避免自动装箱，避免使用枚举类型，注意onLowMemory与onTrimMemory的回调，避免内存泄漏，高效的位置更新操作，重复layout操作的性能影响，以及使用Batching，Prefetching优化网络请求，压缩传输数据等等使用技巧。下面是对这些课程的总结摘要，认知有限，理解偏差的地方请多多交流指正！</p></blockquote>

<h2>1)Fun with ArrayMaps</h2>

<p>程序内存的管理是否合理高效对应用的性能有着很大的影响，有的时候对容器的使用不当也会导致内存管理效率低下。Android为移动操作系统特意编写了一些更加高效的容器，例如SparseArray，今天要介绍的是一个新的容器，叫做<strong><a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/core/java/android/util/ArrayMap.java">ArrayMap</a></strong>。</p>

<p>我们经常会使用到HashMap这个容器，它非常好用，但是却很占用内存。下图演示了HashMap的简要工作原理：</p>

<p><img src="http://hukai.me/images/android_perf_3_arraymap_key_value.png" alt="android_perf_3_arraymap_key_value" /></p>

<p>为了解决HashMap更占内存的弊端，Android提供了内存效率更高的<strong>ArrayMap</strong>。它内部使用两个数组进行工作，其中一个数组记录key hash过后的顺序列表，另外一个数组按key的顺序记录Key-Value值，如下图所示：</p>

<!-- More -->


<p><img src="http://hukai.me/images/android_perf_3_arraymap_two_array.png" alt="android_perf_3_arraymap_two_array" /></p>

<p>当你想获取某个value的时候，ArrayMap会计算输入key转换过后的hash值，然后对hash数组使用二分查找法寻找到对应的index，然后我们可以通过这个index在另外一个数组中直接访问到需要的键值对。如果在第二个数组键值对中的key和前面输入的查询key不一致，那么就认为是发生了碰撞冲突。为了解决这个问题，我们会以该key为中心点，分别上下展开，逐个去对比查找，直到找到匹配的值。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_arraymap_binary_search.png" alt="android_perf_3_arraymap_binary_search" /></p>

<p>随着数组中的对象越来越多，查找访问单个对象的花费也会跟着增长，这是在内存占用与访问时间之间做权衡交换。</p>

<p>既然ArrayMap中的内存占用是连续不间断的，那么它是如何处理插入与删除操作的呢？请看下图所示，演示了Array的特性：</p>

<p><img src="http://hukai.me/images/android_perf_3_arraymap_del.png" alt="android_perf_3_arraymap_del" /></p>

<p><img src="http://hukai.me/images/android_perf_3_arraymap_add.png" alt="android_perf_3_arraymap_add" /></p>

<p>很明显，ArrayMap的插入与删除的效率是不够高的，但是如果数组的列表只是在一百这个数量级上，则完全不用担心这些插入与删除的效率问题。HashMap与ArrayMap之间的内存占用效率对比图如下：</p>

<p><img src="http://hukai.me/images/android_perf_3_arraymap_memory_compare.png" alt="android_perf_3_arraymap_memory_compare" /></p>

<p>与HashMap相比，ArrayMap在循环遍历的时候也更加简单高效，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_arraymap_list.png" alt="android_perf_3_arraymap_list" /></p>

<p>前面演示了很多ArrayMap的优点，但并不是所有情况下都适合使用ArrayMap，我们应该在满足下面2个条件的时候才考虑使用ArrayMap：</p>

<ul>
<li>对象个数的数量级最好是千以内</li>
<li>数据组织形式包含Map结构</li>
</ul>


<p>我们需要学会在特定情形下选择相对更加高效的实现方式。</p>

<h2>2)Beware Autoboxing</h2>

<p>有时候性能问题也可能是因为那些不起眼的小细节引起的，例如在代码中不经意的“自动装箱”。我们知道基础数据类型的大小：boolean(8 bits), int(32 bits), float(32 bits)，long(64 bits)，为了能够让这些基础数据类型在大多数Java容器中运作，会需要做一个autoboxing的操作，转换成Boolean，Integer，Float等对象，如下演示了循环操作的时候是否发生autoboxing行为的差异：</p>

<p><img src="http://hukai.me/images/android_perf_3_autoboxing_for.png" alt="android_perf_3_autoboxing_for" /></p>

<p><img src="http://hukai.me/images/android_perf_3_autoboxing_perf.png" alt="android_perf_3_autoboxing_perf" /></p>

<p>Autoboxing的行为还经常发生在类似HashMap这样的容器里面，对HashMap的增删改查操作都会发生了大量的autoboxing的行为。</p>

<p><img src="http://hukai.me/images/android_perf_3_autoboxing_hashmap.png" alt="android_perf_3_autoboxing_hashmap" /></p>

<p>为了避免这些autoboxing带来的效率问题，Android特地提供了一些如下的Map容器用来替代HashMap，不仅避免了autoboxing，还减少了内存占用：</p>

<p><img src="http://hukai.me/images/android_perf_3_autoboxing_sparse.png" alt="android_perf_3_autoboxing_sparse" /></p>

<h2>3)SparseArray Family Ties</h2>

<p>为了避免HashMap的autoboxing行为，Android系统提供了SparseBoolMap，SparseIntMap，SparseLongMap，LongSparseMap等容器。关于这些容器的基本原理请参考前面的ArrayMap的介绍，另外这些容器的使用场景也和ArrayMap一致，需要满足数量级在千以内，数据组织形式需要包含Map结构。</p>

<h2>4)The price of ENUMs</h2>

<p>在StackOverFlow等问答社区常常出现关于在Android系统里面使用枚举类型的性能讨论，关于这一点，Android官方的Training课程里面有下面这样一句话：</p>

<blockquote><p>Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p></blockquote>

<p><img src="http://hukai.me/images/android_perf_3_enum.png" alt="android_perf_3_enum" /></p>

<p>关于enum的效率，请看下面的讨论。假设我们有这样一份代码，编译之后的dex大小是2556 bytes，在此基础之上，添加一些如下代码，这些代码使用普通static常量相关作为判断值：</p>

<p><img src="http://hukai.me/images/android_perf_3_enum_static.png" alt="android_perf_3_enum_static" /></p>

<p>增加上面那段代码之后，编译成dex的大小是2680 bytes，相比起之前的2556 bytes只增加124 bytes。假如换做使用enum，情况如下：</p>

<p><img src="http://hukai.me/images/android_perf_3_enum_enum.png" alt="android_perf_3_enum_enum" /></p>

<p>使用enum之后的dex大小是4188 bytes，相比起2556增加了1632 bytes，增长量是使用static int的13倍。不仅仅如此，使用enum，运行时还会产生额外的内存占用，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_enum_memory.png" alt="android_perf_3_enum_memory" /></p>

<p>Android官方强烈建议不要在Android程序里面使用到enum。</p>

<h2>5)Trimming and Sharing Memory</h2>

<p>Android系统的一大特色是多任务，用户可以随意在不同的app之间进行快速切换。为了确保你的应用在这种复杂的多任务环境中正常运行，我们需要了解下面的知识。</p>

<p>为了让background的应用能够迅速的切换到forground，每一个background的应用都会占用一定的内存。Android系统会根据当前的系统内存使用情况，决定回收部分background的应用内存。如果background的应用从暂停状态直接被恢复到forground，能够获得较快的恢复体验，如果background应用是从Kill的状态进行恢复，就会显得稍微有点慢。</p>

<p><img src="http://hukai.me/images/android_perf_3_memory_bg_2_for.png" alt="android_perf_3_memory_bg_2_for" /></p>

<p>Android系统提供了一些回调来通知应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到<strong>onLowMemory()</strong>的回调。在这种情况下，需要尽快释放当前应用的非必须内存资源，从而确保系统能够稳定继续运行。Android系统还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，下图介绍了各种不同的回调参数：</p>

<p><img src="http://hukai.me/images/android_perf_3_memory_ontrimmemory.png" alt="android_perf_3_memory_ontrimmemory" /></p>

<p>关于每个参数的更多介绍，请参考这里 <a href="http://hukai.me/android-training-managing_your_app_memory/">http://hukai.me/android-training-managing_your_app_memory/</a>，另外onTrimMemory()的回调可以发生在Application，Activity，Fragment，Service，Content Provider。</p>

<p>从Android 4.4开始，ActivityManager提供了<strong>isLowRamDevice()</strong>的API，通常指的是Heap Size低于512M或者屏幕大小&lt;=800*480的设备。</p>

<h2>6)DO NOT LEAK VIEWS</h2>

<p>内存泄漏的概念，下面一张图演示下：</p>

<p><img src="http://hukai.me/images/android_perf_3_leak.png" alt="android_perf_3_leak" /></p>

<p>通常来说，View会保持Activity的引用，Activity同时还和其他内部对象也有可能保持引用关系。当屏幕发生旋转的时候，activity很容易发生泄漏，这样的话，里面的view也会发生泄漏。Activity以及view的泄漏是非常严重的，为了避免出现泄漏，请特别留意以下的规则：</p>

<h3>6.1)避免使用异步回调</h3>

<p>异步回调被执行的时间不确定，很有可能发生在activity已经被销毁之后，这不仅仅很容易引起crash，还很容易发生内存泄露。</p>

<p><img src="http://hukai.me/images/android_perf_3_leak_asyncback.png" alt="android_perf_3_leak_asyncback" /></p>

<h3>6.2)避免使用Static对象</h3>

<p>因为static的生命周期过长，使用不当很可能导致leak，在Android中应该尽量避免使用static对象。</p>

<p><img src="http://hukai.me/images/android_perf_3_leak_static.png" alt="android_perf_3_leak_static" /></p>

<h3>6.3)避免把View添加到没有清除机制的容器里面</h3>

<p>假如把view添加到<a href="http://stackoverflow.com/questions/5511279/what-is-a-weakhashmap-and-when-to-use-it">WeakHashMap</a>，如果没有执行清除操作，很可能会导致泄漏。</p>

<p><img src="http://hukai.me/images/android_perf_3_leak_map.png" alt="android_perf_3_leak_map" /></p>

<h2>7)Location &amp; Battery Drain</h2>

<p>开启定位功能是一个相对来说比较耗电的操作，通常来说，我们会使用类似下面这样的代码来发出定位请求：</p>

<p><img src="http://hukai.me/images/android_perf_3_location_request.png" alt="android_perf_3_location_request" /></p>

<p>上面演示中有一个方法是<strong>setInterval()</strong>指的意思是每隔多长的时间获取一次位置更新，时间相隔越短，自然花费的电量就越多，但是时间相隔太长，又无法及时获取到更新的位置信息。其中存在的一个优化点是，我们可以通过判断返回的位置信息是否相同，从而决定设置下次的更新间隔是否增加一倍，通过这种方式可以减少电量的消耗，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_location_reduce.png" alt="android_perf_3_location_reduce" /></p>

<p>在位置请求的演示代码中还有一个方法是<strong>setFastestInterval()</strong>，因为整个系统中很可能存在其他的应用也在请求位置更新，那些应用很有可能设置的更新间隔时间很短，这种情况下，我们就可以通过setFestestInterval的方法来过滤那些过于频繁的更新。</p>

<p>通过GPS定位服务相比起使用网络进行定位更加的耗电，但是也相对更加精准一些，他们的图示关系如下：</p>

<p><img src="http://hukai.me/images/android_perf_3_location_provider.png" alt="android_perf_3_location_provider" /></p>

<p>为了提供不同精度的定位需求，同时屏蔽实现位置请求的细节，Android提供了下面4种不同精度与耗电量的参数给应用进行设置调用，应用只需要决定在适当的场景下使用对应的参数就好了，通过LocationRequest.setPriority()方法传递下面的参数就好了。</p>

<p><img src="http://hukai.me/images/android_perf_3_location_accuracy.png" alt="android_perf_3_location_accuracy" /></p>

<h2>8)Double Layout Taxation</h2>

<p>布局中的任何一个View一旦发生一些属性变化，都可能引起很大的连锁反应。例如某个button的大小突然增加一倍，有可能会导致兄弟视图的位置变化，也有可能导致父视图的大小发生改变。当大量的layout()操作被频繁调用执行的时候，就很可能引起丢帧的现象。</p>

<p><img src="http://hukai.me/images/android_perf_3_layout_double.png" alt="android_perf_3_layout_double" /></p>

<p>例如，在RelativeLayout中，我们通常会定义一些类似alignTop，alignBelow等等属性，如图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_layout_relative.png" alt="android_perf_3_layout_relative" /></p>

<p>为了获得视图的准确位置，需要经过下面几个阶段。首先子视图会触发计算自身位置的操作，然后RelativeLayout使用前面计算出来的位置信息做边界的调整的操作，如下面两张图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_layout_first_cal.png" alt="android_perf_3_layout_first_cal" /></p>

<p><img src="http://hukai.me/images/android_perf_3_layout_first_adjust.png" alt="android_perf_3_layout_first_adjust" /></p>

<p>经历过上面2个步骤，relativeLayout会立即触发第二次layout()的操作来确定所有子视图的最终位置与大小信息。</p>

<p>除了RelativeLayout会发生两次layout操作之外，LinearLayout也有可能触发两次layout操作，通常情况下LinearLayout只会发生一次layout操作，可是一旦调用了measureWithLargetChild()方法就会导致触发两次layout的操作。另外，通常来说，GridLayout会自动预处理子视图的关系来避免两次layout，可是如果GridLayout里面的某些子视图使用了weight等复杂的属性，还是会导致重复的layout操作。</p>

<p>如果只是少量的重复layout本身并不会引起严重的性能问题，但是如果它们发生在布局的根节点，或者是ListView里面的某个ListItem，这样就会引起比较严重的性能问题。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_layout_hierachy.png" alt="android_perf_3_layout_hierachy" /></p>

<p>我们可以使用Systrace来跟踪特定的某段操作，如果发现了疑似丢帧的现象，可能就是因为重复layout引起的。通常我们无法避免重复layout，在这种情况下，我们应该尽量保持View Hierarchy的层级比较浅，这样即使发生重复layout，也不会因为布局的层级比较深而增大了重复layout的倍数。另外还有一点需要特别注意，在任何时候都请避免调用<strong>requestLayout()</strong>的方法，因为一旦调用了requestLayout，会导致该layout的所有父节点都发生重新layout的操作。</p>

<p><img src="http://hukai.me/images/android_perf_3_layout_request.png" alt="android_perf_3_layout_request" /></p>

<h2>9)Network Performance 101</h2>

<p>在性能优化第一季与第二季的课程里面都介绍过，网络请求的操作是非常耗电的，其中在移动蜂窝网络情况下执行网络数据的请求则尤其比较耗电。关于如何减少移动网络下的网络请求的耗电量，有两个重要的原则需要遵守：第一个是减少移动网络被激活的时间与次数，第二个是压缩传输数据。</p>

<h3>9.1)减少移动网络被激活的时间与次数</h3>

<p>通常来说，发生网络行为可以划分为如下图所示的三种类型，一个是用户主动触发的请求，另外被动接收服务器的返回数据，最后一个是数据上报，行为上报，位置更新等等自定义的后台操作。</p>

<p><img src="http://hukai.me/images/android_perf_3_network_three_type.png" alt="android_perf_3_network_three_type" /></p>

<p>我们绝对坚决肯定不应该使用Polling(轮询)的方式去执行网络请求，这样不仅仅会造成严重的电量消耗，还会浪费许多网络流量，例如：</p>

<p><img src="http://hukai.me/images/android_perf_3_network_polling.png" alt="android_perf_3_network_polling" /></p>

<p>Android官方推荐使用<a href="https://developers.google.com/cloud-messaging/">Google Cloud Messaging</a>(在大陆，然并卵)，这个框架会帮助把更新的数据推送给手机客户端，效率极高！我们应该遵循下面的规则来处理数据同步的问题：</p>

<p>首先，我们应该使用回退机制来避免固定频繁的同步请求，例如，在发现返回数据相同的情况下，推迟下次的请求时间，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_network_backoff.png" alt="android_perf_3_network_backoff" /></p>

<p>其次，我们还可以使用<strong>Batching</strong>(批处理)的方式来集中发出请求，避免频繁的间隔请求，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_network_batching.png" alt="android_perf_3_network_batching" /></p>

<p>最后，我们还可以使用<strong>Prefetching</strong>(预取)的技术提前把一些数据拿到，避免后面频繁再次发起网络请求，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_network_prefetching.png" alt="android_perf_3_network_prefetching" /></p>

<p>Google Play Service中提供了一个叫做<a href="https://developers.google.com/cloud-messaging/network-manager">GCMNetworkManager</a>的类来帮助我们实现上面的那些功能，我们只需要调用对应的API，设置一些简单的参数，其余的工作就都交给Google来帮我们实现了。</p>

<p><img src="http://hukai.me/images/android_perf_3_network_gcm_network_manager.png" alt="android_perf_3_network_gcm_network_manager" /></p>

<h3>9.2)压缩传输数据</h3>

<p>关于压缩传输数据，我们可以学习以下的一些课程(真的够喝好几壶了)：</p>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H">CompressorHead</a>：这系列的课程会介绍压缩的基本概念以及一些常见的压缩算法知识。</li>
<li><a href="http://www.html5rocks.com/en/tutorials/speed/img-compression/">Image Compression</a>：介绍关于图片的压缩知识。</li>
<li><a href="http://www.gdcvault.com/play/1020682/Texture-Wranglin-Getting-your-Android">Texture Wranglin</a>：介绍了游戏开发相关的知识。</li>
<li><a href="https://www.youtube.com/watch?v=P7riQin9Bfo&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_3146342489">Grabby</a>：介绍了游戏开发相关的知识。</li>
<li><a href="https://www.youtube.com/watch?v=whGwm0Lky2s&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_1270272007">Gzip is not enough</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/speed/txt-compression/">Text Compression</a></li>
<li><a href="https://www.youtube.com/watch?v=iQTxMkSJ1dQ&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_632816183">FlatBuffers</a></li>
</ul>


<h2>10)Effective Network Batching</h2>

<p>在性能优化课程的第一季与第二季里面，我们都有提到过下面这样一个网络请求与电量消耗的示意图：</p>

<p><img src="http://hukai.me/images/android_perf_3_batching_networking.png" alt="android_perf_3_batching_networking" /></p>

<p>发起网络请求与接收返回数据都是比较耗电的，在网络硬件模块被激活之后，会继续保持几十秒的电量消耗，直到没有新的网络操作行为之后，才会进入休眠状态。前面一个段落介绍了使用Batching的技术来捆绑网络请求，从而达到减少网络请求的频率。那么如何实现Batching技术呢？通常来说，我们可以会把那些发出的网络请求，先暂存到一个PendingQueue里面，等到条件合适的时候再触发Queue里面的网络请求。</p>

<p><img src="http://hukai.me/images/android_perf_3_batching_queue.png" alt="android_perf_3_batching_queue" /></p>

<p>可是什么时候才算是条件合适了呢？最简单粗暴的，例如我们可以在Queue大小到10的时候触发任务，也可以是当手机开始充电，或者是手机连接到WiFi等情况下才触发队列中的任务。手动编写代码去实现这些功能会比较复杂繁琐，Google为了解决这个问题，为我们提供了GCMNetworkManager来帮助实现那些功能，仅仅只需要调用API，设置触发条件，然后就OK了。</p>

<h2>11)Optimizing Network Request Frequencies</h2>

<p>前面的段落已经提到了应该减少网络请求的频率，这是为了减少电量的消耗。我们可以使用Batching，Prefetching的技术来避免频繁的网络请求。Google提供了GCMNetworkManager来帮助开发者实现那些功能，通过提供的API，我们可以选择在接入WiFi，开始充电，等待移动网络被激活等条件下再次激活网络请求。</p>

<h2>12)Effective Prefetching</h2>

<p>假设我们有这样的一个场景，最开始网络请求了一张图片，隔了10秒需要请求另外一张图片，再隔6秒会请求第三张图片，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_3_prefetching.png" alt="android_perf_3_prefetching" /></p>

<p>类似上面的情况会频繁触发网络请求，但是如果我们能够预先请求后续可能会使用到网络资源，避免频繁的触发网络请求，这样就能够显著的减少电量的消耗。可是预先获取多少数据量是很值得考量的，因为如果预取数据量偏少，就起不到减少频繁请求的作用，可是如果预取数据过多，就会造成资源的浪费。</p>

<p><img src="http://hukai.me/images/android_perf_3_prefetching_over.png" alt="android_perf_3_prefetching_over" /></p>

<p>我们可以参考在WiFi，4G，3G等不同的网络下设计不同大小的预取数据量，也可以是按照图片数量或者操作时间来作为阀值。这需要我们需要根据特定的场景，不同的网络情况设计合适的方案。</p>

<hr />

<p>首发于CSDN：<a href="http://www.csdn.net/article/2015-08-12/2825447-android-performance-patterns-season-3">Android性能优化典范（三）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第2季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-2/"/>
    <updated>2015-04-29T12:32:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-2</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_perf_patterns_season_2.png" alt="android_perf_patterns_season_2" /></p>

<blockquote><p>Google前几天刚发布了<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范第2季</a>的课程，一共20个短视频，包括的内容大致有：电量优化，网络优化，Wear上如何做优化，使用对象池来提高效率，LRU Cache，Bitmap的缩放，缓存，重用，PNG压缩，自定义View的性能，提升设置alpha之后View的渲染性能，以及Lint，StictMode等等工具的使用技巧。
下面是对这些课程的总结摘要，认知有限，理解偏差的地方请多多指教！</p></blockquote>

<h2>1)Battery Drain and Networking</h2>

<p>对于手机程序，网络操作相对来说是比较耗电的行为。优化网络操作能够显著节约电量的消耗。在性能优化第1季里面有提到过，手机硬件的各个模块的耗电量是不一样的，其中移动蜂窝模块对电量消耗是比较大的，另外蜂窝模块在不同工作强度下，对电量的消耗也是有差异的。当程序想要执行某个网络请求之前，需要先唤醒设备，然后发送数据请求，之后等待返回数据，最后才慢慢进入休眠状态。这个流程如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_network_request_mode.png" alt="android_perf_2_network_request_mode" /></p>

<!-- More -->


<p>在上面那个流程中，蜂窝模块的电量消耗差异如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_battery_drain_mode.png" alt="android_perf_2_battery_drain_mode" /></p>

<p>从图示中可以看到，激活瞬间，发送数据的瞬间，接收数据的瞬间都有很大的电量消耗，所以，我们应该从如何传递网络数据以及何时发起网络请求这两个方面来着手优化。</p>

<h4>1.1)何时发起网络请求</h4>

<p>首先我们需要区分哪些网络请求是需要及时返回结果的，哪些是可以延迟执行的。例如，用户主动下拉刷新列表，这种行为需要立即触发网络请求，并等待数据返回。但是对于上传用户操作的数据，同步程序设置等等行为则属于可以延迟的行为。我们可以通过Battery Historian这个工具来查看关于移动蜂窝模块的电量消耗（关于这部分的细节，请点击<a href="http://hukai.me/android-performance-battery/">Android性能优化之电量篇</a>）。在Mobile Radio那一行会显示蜂窝模块的电量消耗情况，红色的部分代表模块正在工作，中间的间隔部分代表模块正在休眠状态，如果看到有一段区间，红色与间隔频繁的出现，那就说明这里有可以优化的行为。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_battery_mobile_radio.png" alt="android_perf_2_battery_mobile_radio" /></p>

<p>对于上面可以优化的部分，我们可以有针对性的把请求行为捆绑起来，延迟到某个时刻统一发起请求。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_battery_batch_delay.png" alt="android_perf_2_battery_batch_delay" /></p>

<p>经过上面的优化之后，我们再回头使用Battery Historian导出电量消耗图，可以看到唤醒状态与休眠状态是连续大块间隔的，这样的话，总体电量的消耗就会变得更少。</p>

<p><img src="http://hukai.me/images/android_perf_2_battery_mobile_radio_2.png" alt="android_perf_2_battery_mobile_radio_2" /></p>

<p>当然，我们甚至可以把请求的任务延迟到手机网络切换到WiFi，手机处于充电状态下再执行。在前面的描述过程中，我们会遇到的一个难题是如何把网络请求延迟，并批量进行执行。还好，Android提供了<a href="http://developer.android.com/intl/zh-cn/reference/android/app/job/JobScheduler.html">JobScheduler</a>来帮助我们达成这个目标。</p>

<h4>1.2)如何传递网络数据</h4>

<p>关于这部分主要会涉及到Prefetch(预取)与Compressed(压缩)这两个技术。对于Prefetch的使用，我们需要预先判断用户在此次操作之后，后续零散的请求是否很有可能会马上被触发，可以把后面5分钟有可能会使用到的零散请求都一次集中执行完毕。对于Compressed的使用，在上传与下载数据之前，使用CPU对数据进行压缩与解压，可以很大程度上减少网络传输的时间。</p>

<p>想要知道我们的应用程序中网络请求发生的时间，每次请求的数据量等等信息，可以通过Android Studio中的<a href="http://developer.android.com/intl/zh-cn/tools/debugging/ddms.html#network">Networking Traffic Tool</a>来查看详细的数据，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_battery_network_tracking.png" alt="android_perf_2_battery_network_tracking" /></p>

<h2>2)Wear &amp; Sensors</h2>

<p>在Android Wear上会大量的使用Sensors来实现某些特殊功能，如何在尽量节约电量的前提下利用好Sensor会是我们需要特别注意的问题。下面会介绍一些在Android Wear上的最佳实践典范。</p>

<p>尽量减少刷新请求，例如我们可以在不需要某些数据的时候尽快注销监听，减小刷新频率，对Sensor的数据做批量处理等等。那么如何做到这些优化呢？</p>

<ul>
<li>首先我们需要尽量使用Android平台提供的既有运动数据，而不是自己去实现监听采集数据，因为大多数Android Watch自身记录Sensor数据的行为是有经过做电量优化的。</li>
<li>其次在Activity不需要监听某些Sensor数据的时候需要尽快释放监听注册。</li>
<li>还有我们需要尽量控制更新的频率，仅仅在需要刷新显示数据的时候才触发获取最新数据的操作。</li>
<li>另外我们可以针对Sensor的数据做批量处理，待数据累积一定次数或者某个程度的时候才更新到UI上。</li>
<li>最后当Watch与Phone连接起来的时候，可以把某些复杂操作的事情交给Phone来执行，Watch只需要等待返回的结果。</li>
</ul>


<p>更对关于Sensors的知识，可以点击<a href="https://www.youtube.com/watch?v=82M8DmFz4P8&amp;index=2&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">这里</a></p>

<h2>3)Smooth Android Wear Animation</h2>

<p>Android Material Design风格的应用采用了大量的动画来进行UI切换，优化动画的性能不仅能够提升用户体验还可以减少电量的消耗，下面会介绍一些简单易行的方法。</p>

<p>在Android里面一个相对操作比较繁重的事情是对Bitmap进行旋转，缩放，裁剪等等。例如在一个圆形的钟表图上，我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图的所形成的帧率要高56%。</p>

<p><img src="http://hukai.me/images/android_perf_2_waer_animation.png" alt="android_perf_2_waer_animation" /></p>

<p>另外尽量减少每次重绘的元素可以极大的提升性能，假如某个钟表界面上有很多需要显示的复杂组件，我们可以把这些组件做拆分处理，例如把背景图片单独拎出来设置为一个独立的View，通过setLayerType()方法使得这个View强制用Hardware来进行渲染。至于界面上哪些元素需要做拆分，他们各自的更新频率是多少，需要有针对性的单独讨论。</p>

<p>如何使用Systrace等工具来查看某些View的渲染性能，在前面的章节里面有提到过，感兴趣的可以点击<a href="http://hukai.me/android-performance-render/">这里</a></p>

<p>对于大多数应用中的动画，我们会使用PropertyAnimation或者ViewAnimation来操作实现，Android系统会自动对这些Animation做一定的优化处理，在Android上面学习到的大多数性能优化的知识同样也适用于Android Wear。</p>

<p>想要获取更多关于Android Wear中动画效果的优化，请点击<a href="http://developer.android.com/samples/WatchFace/index.html">WatchFace</a>这个范例。</p>

<h2>4)Android Wear Data Batching</h2>

<p>在Android Training里面有关于Wear上面如何利用Wearable API与Phone进行沟通协作的课程(详情请点击<a href="http://developer.android.com/training/wearables/data-layer/index.html">这里</a>)。因为Phone的CPU与电量都比Wear要强大，另外Phone还可以直接接入网络，而Wear要接入网络则相对更加困难，所以我们在开发Wear应用的时候需要尽量做到把复杂的操作交给Phone来执行。例如我们可以让Phone来获取天气信息，然后把数据返回Wear进行显示。更进一步，在之前的性能优化课程里面我们有学习过如何使用JobScheduler来延迟批量处理任务，假设Phone收到来自Wear的其中一个任务是每隔5分钟检查一次天气情况，那么Phone使用JobScheduler执行检查天气任务之后，先判断这次返回的结果和之前是否有差异，仅仅当天气发生变化的时候，才有必要把结果通知到Wear，或者仅仅把变化的某一项数据通知给Wear，这样可以更大程度上减少Wear的电量消耗。</p>

<p>下面我们总结一下如何优化Wear的性能与电量：</p>

<ul>
<li>仅仅在真正需要刷新界面的时候才发出请求</li>
<li>尽量把计算复杂操作的任务交给Phone来处理</li>
<li>Phone仅仅在数据发生变化的时候才通知到Wear</li>
<li>把零碎的数据请求捆绑一起再进行操作</li>
</ul>


<h2>5)Object Pools</h2>

<p>在程序里面经常会遇到的一个问题是短时间内创建大量的对象，导致内存紧张，从而触发GC导致性能问题。对于这个问题，我们可以使用对象池技术来解决它。通常对象池中的对象可能是bitmaps，views，paints等等。关于对象池的操作原理，不展开述说了，请看下面的图示：</p>

<p><img src="http://hukai.me/images/android_perf_2_object_pool.png" alt="android_perf_2_object_pool" /></p>

<p>使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池，但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做<strong>预分配</strong>。使用对象池也有不好的一面，程序员需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。</p>

<h2>6)To Index or Iterate?</h2>

<p>遍历容器是编程里面一个经常遇到的场景。在Java语言中，使用Iterate是一个比较常见的方法。可是在Android开发团队中，大家却尽量避免使用Iterator来执行遍历操作。下面我们看下在Android上可能用到的三种不同的遍历方法：</p>

<p><img src="http://hukai.me/images/android_perf_2_iterate_1.png" alt="android_perf_2_iterate_1" /></p>

<p><img src="http://hukai.me/images/android_perf_2_iterate_for_loop.png" alt="android_perf_2_iterate_for_loop" /></p>

<p><img src="http://hukai.me/images/android_perf_2_iterate_simple_loop.png" alt="android_perf_2_iterate_simple_loop" /></p>

<p>使用上面三种方式在同一台手机上，使用相同的数据集做测试，他们的表现性能如下所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_iterate_result.png" alt="android_perf_2_iterate_result" /></p>

<p>从上面可以看到for index的方式有更好的效率，但是因为不同平台编译器优化各有差异，我们最好还是针对实际的方法做一下简单的测量比较好，拿到数据之后，再选择效率最高的那个方式。</p>

<h2>7)The Magic of LRU Cache</h2>

<p>这小节我们要讨论的是缓存算法，在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，关于LRU算法，不展开述说，用下面一张图演示下含义：</p>

<p><img src="http://hukai.me/images/android_perf_2_lru_mode.png" alt="android_perf_2_lru_mode" /></p>

<p>LRU Cache的基础构建用法如下：</p>

<p><img src="http://hukai.me/images/android_perf_2_lru_key_value.png" alt="android_perf_2_lru_key_value" /></p>

<p>为了给LRU Cache设置一个比较合理的缓存大小值，我们通常是用下面的方法来做界定的：</p>

<p><img src="http://hukai.me/images/android_perf_2_lru_size.png" alt="android_perf_2_lru_size" /></p>

<p>使用LRU Cache时为了能够让Cache知道每个加入的Item的具体大小，我们需要Override下面的方法：</p>

<p><img src="http://hukai.me/images/android_perf_2_lru_sizeof.png" alt="android_perf_2_lru_sizeof" /></p>

<p>使用LRU Cache能够显著提升应用的性能，可是也需要注意LRU Cache中被淘汰对象的回收，否者会引起严重的内存泄露。</p>

<h2>8)Using LINT for Performance Tips</h2>

<p>Lint是Android提供的一个静态扫描应用源码并找出其中的潜在问题的一个强大的工具。</p>

<p><img src="http://hukai.me/images/android_perf_2_lint_overview.png" alt="android_perf_2_lint_overview" /></p>

<p>例如，如果我们在onDraw方法里面执行了new对象的操作，Lint就会提示我们这里有性能问题，并提出对应的建议方案。Lint已经集成到Android Studio中了，我们可以手动去触发这个工具，点击工具栏的Analysis -> Inspect Code，触发之后，Lint会开始工作，并把结果输出到底部的工具栏，我们可以逐个查看原因并根据指示做相应的优化修改。</p>

<p>Lint的功能非常强大，他能够扫描各种问题。当然我们可以通过Android Studio设置找到Lint，对Lint做一些定制化扫描的设置，可以选择忽略掉那些不想Lint去扫描的选项，我们还可以针对部分扫描内容修改它的提示优先级。</p>

<p>建议把与内存有关的选项中的严重程度标记为红色的Error，对于Layout的性能问题标记为黄色Warning。</p>

<h2>9)Hidden Cost of Transparency</h2>

<p>这小节会介绍如何减少透明区域对性能的影响。通常来说，对于不透明的View，显示它只需要渲染一次即可，可是如果这个View设置了alpha值，会至少需要渲染两次。原因是包含alpha的view需要事先知道混合View的下一层元素是什么，然后再结合上层的View进行Blend混色处理。</p>

<p>在某些情况下，一个包含alpha的View有可能会触发改View在HierarchyView上的父View都被额外重绘一次。下面我们看一个例子，下图演示的ListView中的图片与二级标题都有设置透明度。</p>

<p><img src="http://hukai.me/images/android_perf_2_trans_listview.png" alt="android_perf_2_trans_listview" /></p>

<p>大多数情况下，屏幕上的元素都是由后向前进行渲染的。在上面的图示中，会先渲染背景图(蓝，绿，红)，然后渲染人物头像图。如果后渲染的元素有设置alpha值，那么这个元素就会和屏幕上已经渲染好的元素做blend处理。很多时候，我们会给整个View设置alpha的来达到fading的动画效果，如果我们图示中的ListView做alpha逐渐减小的处理，我们可以看到ListView上的TextView等等组件会逐渐融合到背景色上。但是在这个过程中，我们无法观察到它其实已经触发了额外的绘制任务，我们的目标是让整个View逐渐透明，可是期间ListView在不停的做Blending的操作，这样会导致不少性能问题。</p>

<p>如何渲染才能够得到我们想要的效果呢？我们可以先按照通常的方式把View上的元素按照从后到前的方式绘制出来，但是不直接显示到屏幕上，而是使用GPU预处理之后，再又GPU渲染到屏幕上，GPU可以对界面上的原始数据直接做旋转，设置透明度等等操作。使用GPU进行渲染，虽然第一次操作相比起直接绘制到屏幕上更加耗时，可是一旦原始纹理数据生成之后，接下去的操作就比较省时省力。</p>

<p><img src="http://hukai.me/images/android_perf_2_trans_hw_layer.png" alt="android_perf_2_trans_hw_layer" /></p>

<p>如何才能够让GPU来渲染某个View呢？我们可以通过setLayerType的方法来指定View应该如何进行渲染，从SDK 16开始，我们还可以使用ViewPropertyAnimator.alpha().withLayer()来指定。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_trans_setlayertype.png" alt="android_perf_2_trans_setlayertype" /></p>

<p>另外一个例子是包含阴影区域的View，这种类型的View并不会出现我们前面提到的问题，因为他们并不存在层叠的关系。</p>

<p><img src="http://hukai.me/images/android_perf_2_trans_overlap.png" alt="android_perf_2_trans_overlap" /></p>

<p>为了能够让渲染器知道这种情况，避免为这种View占用额外的GPU内存空间，我们可以做下面的设置。</p>

<p><img src="http://hukai.me/images/android_perf_2_trans_override_lap.png" alt="android_perf_2_trans_override_lap" /></p>

<p>通过上面的设置以后，性能可以得到显著的提升，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_trans_overlap_compare.png" alt="android_perf_2_trans_overlap_compare" /></p>

<h2>10)Avoiding Allocations in onDraw()</h2>

<p>我们都知道应该避免在onDraw()方法里面执行导致内存分配的操作，下面讲解下为何需要这样做。</p>

<p>首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。</p>

<p><img src="http://hukai.me/images/android_perf_2_ondraw_gc.png" alt="android_perf_2_ondraw_gc" /></p>

<p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。</p>

<p>那么简单解决频繁分配内存的方法就是把分配操作移动到onDraw()方法外面，通常情况下，我们会把onDraw()里面new Paint的操作移动到外面，如下面所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_ondraw_paint.png" alt="android_perf_2_ondraw_paint" /></p>

<h2>11)Tool: Strict Mode</h2>

<p>UI线程被阻塞超过5秒，就会出现ANR，这太糟糕了。防止程序出现ANR是很重要的事情，那么如何找出程序里面潜在的坑，预防ANR呢？很多大部分情况下执行很快的方法，但是他们有可能存在巨大的隐患，这些隐患的爆发就很容易导致ANR。</p>

<p>Android提供了一个叫做Strict Mode的工具，我们可以通过手机设置里面的开发者选项，打开Strict Mode选项，如果程序存在潜在的隐患，屏幕就会闪现红色。我们也可以通过<a href="http://developer.android.com/reference/android/os/StrictMode.html">StrictMode</a> API在代码层面做细化的跟踪，可以设置StrictMode监听那些潜在问题，出现问题时如何提醒开发者，可以对屏幕闪红色，也可以输出错误日志。下面是官方的代码示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">if</span> <span class="o">(</span><span class="n">DEVELOPER_MODE</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>         <span class="n">StrictMode</span><span class="o">.</span><span class="na">setThreadPolicy</span><span class="o">(</span><span class="k">new</span> <span class="n">StrictMode</span><span class="o">.</span><span class="na">ThreadPolicy</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">detectDiskReads</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">detectDiskWrites</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">detectNetwork</span><span class="o">()</span>   <span class="c1">// or .detectAll() for all detectable problems</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">penaltyLog</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">build</span><span class="o">());</span>
</span><span class='line'>         <span class="n">StrictMode</span><span class="o">.</span><span class="na">setVmPolicy</span><span class="o">(</span><span class="k">new</span> <span class="n">StrictMode</span><span class="o">.</span><span class="na">VmPolicy</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">detectLeakedSqlLiteObjects</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">detectLeakedClosableObjects</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">penaltyLog</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">penaltyDeath</span><span class="o">()</span>
</span><span class='line'>                 <span class="o">.</span><span class="na">build</span><span class="o">());</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'>     <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>12)Custom Views and Performance</h2>

<p>Android系统有提供超过70多种标准的View，例如TextView，ImageView，Button等等。在某些时候，这些标准的View无法满足我们的需要，那么就需要我们自己来实现一个View，这节会介绍如何优化自定义View的性能。</p>

<p>通常来说，针对自定义View，我们可能犯下面三个错误：</p>

<ul>
<li><strong>Useless calls to onDraw()：</strong>我们知道调用View.invalidate()会触发View的重绘，有两个原则需要遵守，第1个是仅仅在View的内容发生改变的时候才去触发invalidate方法，第2个是尽量使用ClipRect等方法来提高绘制的性能。</li>
<li><strong>Useless pixels：</strong>减少绘制时不必要的绘制元素，对于那些不可见的元素，我们需要尽量避免重绘。</li>
<li><strong>Wasted CPU cycles：</strong>对于不在屏幕上的元素，可以使用Canvas.quickReject把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。</li>
</ul>


<p>最后请时刻牢记，尽量提高View的绘制性能，这样才能保证界面的刷新帧率尽量的高。更多关于这部分的内容，可以看<a href="http://hukai.me/android-performance-patterns/">这里</a></p>

<h2>13)Batching Background Work Until Later</h2>

<p>优化性能时大多数时候讨论的都是如何减少不必要的操作，但是选择何时去执行某些操作同样也很重要。在<a href="http://hukai.me/android-performance-patterns/">第1季</a>以及上一期的<a href="http://hukai.me/android-performance-battery/">性能优化之电量篇</a>里面，我们有提到过移动蜂窝模块的电量消耗模型。为了避免我们的应用程序过多的频繁消耗电量，我们需要学习如何把后台任务打包批量，并选择一个合适的时机进行触发执行。下图是每个应用程序各自执行后台任务导致的电量消耗示意图：</p>

<p><img src="http://hukai.me/images/android_perf_2_batching_bg_1.png" alt="android_perf_2_batching_bg_1" /></p>

<p>因为像上面那样做会导致浪费很多电量，我们需要做的是把部分应用的任务延迟处理，等到一定时机，这些任务一并进行处理。结果如下面的示意图：</p>

<p><img src="http://hukai.me/images/android_perf_2_batching_bg_2.png" alt="android_perf_2_batching_bg_2" /></p>

<p>执行延迟任务，通常有下面三种方式：</p>

<h4>1)AlarmManager</h4>

<p>使用AlarmManager设置定时任务，可以选择精确的间隔时间，也可以选择非精确时间作为参数。除非程序有很强烈的需要使用精确的定时唤醒，否者一定要避免使用他，我们应该尽量使用非精确的方式。</p>

<h4>2)SyncAdapter</h4>

<p>我们可以使用SyncAdapter为应用添加设置账户，这样在手机设置的账户列表里面可以找到我们的应用。这种方式功能更多，但是实现起来比较复杂。我们可以从这里看到官方的培训课程：<a href="http://developer.android.com/training/sync-adapters/index.html">http://developer.android.com/training/sync-adapters/index.html</a></p>

<h4>3)JobSchedulor</h4>

<p>这是最简单高效的方法，我们可以设置任务延迟的间隔，执行条件，还可以增加重试机制。</p>

<h2>14)Smaller Pixel Formats</h2>

<p>常见的png,jpeg,webp等格式的图片在设置到UI上之前需要经过解码的过程，而解压时可以选择不同的解码率，不同的解码率对内存的占用是有很大差别的。在不影响到画质的前提下尽量减少内存的占用，这能够显著提升应用程序的性能。</p>

<p>Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理，那么当一个更大的图片需要放到heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_pixel_heap_free.png" alt="android_perf_2_pixel_heap_free" /></p>

<p>所以为了避免加载一张超大的图片，需要尽量减少这张图片所占用的内存大小，Android为图片提供了4种解码格式，他们分别占用的内存大小如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_pixel_format.png" alt="android_perf_2_pixel_format" /></p>

<p>随着解码占用内存大小的降低，清晰度也会有损失。我们需要针对不同的应用场景做不同的处理，大图和小图可以采用不同的解码率。在Android里面可以通过下面的代码来设置解码率：</p>

<p><img src="http://hukai.me/images/android_perf_2_pixel_decode.png" alt="android_perf_2_pixel_decode" /></p>

<h2>15)Smaller PNG Files</h2>

<p>尽量减少PNG图片的大小是Android里面很重要的一条规范。相比起JPEG，PNG能够提供更加清晰无损的图片，但是PNG格式的图片会更大，占用更多的磁盘空间。到底是使用PNG还是JPEG，需要设计师仔细衡量，对于那些使用JPEG就可以达到视觉效果的，可以考虑采用JPEG即可。我们可以通过Google搜索到很多关于PNG压缩的工具，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_png_tools.png" alt="android_perf_2_png_tools" /></p>

<p>这里要介绍一种新的图片格式：Webp，它是由Google推出的一种既保留png格式的优点，又能够减少图片大小的一种新型图片格式。关于Webp的更多细节，请点击<a href="https://developers.google.com/speed/webp/?csw=1">这里</a></p>

<h2>16)Pre-scaling Bitmaps</h2>

<p>对bitmap做缩放，这也是Android里面最遇到的问题。对bitmap做缩放的意义很明显，提示显示性能，避免分配不必要的内存。Android提供了现成的bitmap缩放的API，叫做createScaledBitmap()，使用这个方法可以获取到一张经过缩放的图片。</p>

<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_created.png" alt="android_perf_2_sacle_bitmap_created" /></p>

<p>上面的方法能够快速的得到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM。下面介绍其他几种缩放图片的方式。</p>

<p>inSampleSize能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点。我们会使用类似像下面一样的方法来缩放bitmap：</p>

<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_code.png" alt="android_perf_2_sacle_bitmap_code" /></p>

<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_insamplesize.png" alt="android_perf_2_sacle_bitmap_insamplesize" /></p>

<p>另外，我们还可以使用inScaled，inDensity，inTargetDensity的属性来对解码图片做处理，源码如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_inscale.png" alt="android_perf_2_sacle_bitmap_inscale" /></p>

<p>还有一个经常使用到的技巧是inJustDecodeBounds，使用这个属性去尝试解码图片，可以事先获取到图片的大小而不至于占用什么内存。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_injust.png" alt="android_perf_2_sacle_bitmap_injust" /></p>

<h2>17)Re-using Bitmaps</h2>

<p>我们知道bitmap会占用大量的内存空间，这节会讲解什么是inBitmap属性，如何利用这个属性来提升bitmap的循环效率。前面我们介绍过使用对象池的技术来解决对象频繁创建再回收的效率问题，使用这种方法，bitmap占用的内存空间会差不多是恒定的数值，每次新创建出来的bitmap都会需要占用一块单独的内存区域，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_inbitmap_old.png" alt="android_perf_2_inbitmap_old" /></p>

<p>为了解决上图所示的效率问题，Android在解码图片的时候引进了<strong>inBitmap</strong>属性，使用这个属性可以得到下图所示的效果：</p>

<p><img src="http://hukai.me/images/android_perf_2_inbitmap_new.png" alt="android_perf_2_inbitmap_new" /></p>

<p>使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。下面是如何使用inBitmap的代码示例：</p>

<p><img src="http://hukai.me/images/android_perf_2_inbitmap_code.png" alt="android_perf_2_inbitmap_code" /></p>

<p>使用inBitmap需要注意几个限制条件：</p>

<ul>
<li>在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li>
<li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。</li>
</ul>


<p>我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_2_inbitmap_pool.png" alt="android_perf_2_inbitmap_pool" /></p>

<p>Google介绍了一个开源的加载bitmap的库：<a href="https://github.com/bumptech/glide">Glide</a>，这里面包含了各种对bitmap的优化技巧。</p>

<h2>18)The Performance Lifecycle</h2>

<p>大多数开发者在没有发现严重性能问题之前是不会特别花精力去关注性能优化的，通常大家关注的都是功能是否实现。当性能问题真的出现的时候，请不要慌乱。我们通常采用下面三个步骤来解决性能问题。</p>

<h4>Gather：收集数据</h4>

<p>我们可以通过Android SDK里面提供的诸多工具来收集CPU，GPU，内存，电量等等性能数据，</p>

<h4>Insight：分析数据</h4>

<p>通过上面的步骤，我们获取到了大量的数据，下一步就是分析这些数据。工具帮我们生成了很多可读性强的表格，我们需要事先了解如何查看表格的数据，每一项代表的含义，这样才能够快速定位问题。如果分析数据之后还是没有找到问题，那么就只能不停的重新收集数据，再进行分析，如此循环。</p>

<h4>Action：解决问题</h4>

<p>定位到问题之后，我们需要采取行动来解决问题。解决问题之前一定要先有个计划，评估这个解决方案是否可行，是否能够及时的解决问题。</p>

<h2>19)Tools not Rules</h2>

<p>虽然前面介绍了很多调试的方法，处理技巧，规范建议等等，可是这并不意味着所有的情况都适用，我们还是需要根据当时的情景做特定灵活的处理。</p>

<h2>20)Memory Profiling 101</h2>

<p>围绕Android生态系统，不仅仅有Phone，还有Wear，TV，Auto等等。对这些不同形态的程序进行性能优化，都离不开内存调试这个步骤。这节中介绍的内容大部分和<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>与<a href="http://hukai.me/android-performance-memory/">Android性能优化之内存篇</a>重合，不展开了。</p>

<p>首发于CSDN：<a href="http://www.csdn.net/article/2015-04-29/2824583-android-performance-patterns-season-2">Android性能优化典范（二）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化之电量篇]]></title>
    <link href="http://hukai.me/android-performance-battery/"/>
    <updated>2015-04-12T16:49:00+08:00</updated>
    <id>http://hukai.me/android-performance-battery</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_performance_course_udacity.jpg" alt="android_performance_course_udacity" /></p>

<blockquote><p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p></blockquote>

<p>下面是电量篇章的学习笔记，部分内容与前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Understanding Battery Drain</h3>

<p>手机各个硬件模块的耗电量是不一样的，有些模块非常耗电，而有些模块则相对显得耗电量小很多。</p>

<p><img src="http://hukai.me/images/android_perf_battery_drain.png" alt="android_perf_battery_drain" /></p>

<p>电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗。</p>

<p>当设备处于待机状态时消耗的电量是极少的，以N5为例，打开飞行模式，可以待机接近1个月。可是点亮屏幕，硬件各个模块就需要开始工作，这会需要消耗很多电量。</p>

<p>使用WakeLock或者JobScheduler唤醒设备处理定时的任务之后，一定要及时让设备回到初始状态。每次唤醒蜂窝信号进行数据传递，都会消耗很多电量，它比WiFi等操作更加的耗电。</p>

<!-- More -->


<p><img src="http://hukai.me/images/battery_drain_radio.png" alt="battery_drain_radio" /></p>

<h3>2)Battery Historian</h3>

<p><a href="https://developer.android.com/about/versions/android-5.0.html#Power">Battery Historian</a>是Android 5.0开始引入的新API。通过下面的指令，可以得到设备上的电量消耗信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>adb shell dumpsys batterystats &gt; xxx.txt  //得到整个设备的电量消耗信息
</span><span class='line'><span class="nv">$ </span>adb shell dumpsys batterystats &gt; com.package.name &gt; xxx.txt //得到指定app相关的电量消耗信息
</span></code></pre></td></tr></table></div></figure>


<p>得到了原始的电量消耗数据之后，我们需要通过Google编写的一个<a href="https://github.com/google/battery-historian">python脚本</a>把数据信息转换成可读性更好的html文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>python historian.py xxx.txt &gt; xxx.html
</span></code></pre></td></tr></table></div></figure>


<p>打开这个转换过后的html文件，可以看到类似TraceView生成的列表数据，这里的数据信息量很大，这里就不展开了。</p>

<p><img src="http://hukai.me/images/android_perf_battery_historian.png" alt="android_perf_battery_historian" /></p>

<h3>3)Track Battery Status &amp; Battery Manager</h3>

<p>我们可以通过下面的代码来获取手机的当前充电状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// It is very easy to subscribe to changes to the battery state, but you can get the current</span>
</span><span class='line'><span class="c1">// state by simply passing null in as your receiver.  Nifty, isn&#39;t that?</span>
</span><span class='line'><span class="n">IntentFilter</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntentFilter</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">ACTION_BATTERY_CHANGED</span><span class="o">);</span>
</span><span class='line'><span class="n">Intent</span> <span class="n">batteryStatus</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">registerReceiver</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">filter</span><span class="o">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">chargePlug</span> <span class="o">=</span> <span class="n">batteryStatus</span><span class="o">.</span><span class="na">getIntExtra</span><span class="o">(</span><span class="n">BatteryManager</span><span class="o">.</span><span class="na">EXTRA_PLUGGED</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'><span class="kt">boolean</span> <span class="n">acCharge</span> <span class="o">=</span> <span class="o">(</span><span class="n">chargePlug</span> <span class="o">==</span> <span class="n">BatteryManager</span><span class="o">.</span><span class="na">BATTERY_PLUGGED_AC</span><span class="o">);</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">acCharge</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span><span class="err">“</span><span class="n">The</span> <span class="n">phone</span> <span class="n">is</span> <span class="n">charging</span><span class="o">!</span><span class="err">”</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的例子演示了如何立即获取到手机的充电状态，得到充电状态信息之后，我们可以有针对性的对部分代码做优化。比如我们可以判断只有当前手机为AC充电状态时
才去执行一些非常耗电的操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * This method checks for power by comparing the current battery state against all possible</span>
</span><span class='line'><span class="cm"> * plugged in states. In this case, a device may be considered plugged in either by USB, AC, or</span>
</span><span class='line'><span class="cm"> * wireless charge. (Wireless charge was introduced in API Level 17.)</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">checkForPower</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// It is very easy to subscribe to changes to the battery state, but you can get the current</span>
</span><span class='line'>    <span class="c1">// state by simply passing null in as your receiver.  Nifty, isn&#39;t that?</span>
</span><span class='line'>    <span class="n">IntentFilter</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntentFilter</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">ACTION_BATTERY_CHANGED</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Intent</span> <span class="n">batteryStatus</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">registerReceiver</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">filter</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// There are currently three ways a device can be plugged in. We should check them all.</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">chargePlug</span> <span class="o">=</span> <span class="n">batteryStatus</span><span class="o">.</span><span class="na">getIntExtra</span><span class="o">(</span><span class="n">BatteryManager</span><span class="o">.</span><span class="na">EXTRA_PLUGGED</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">boolean</span> <span class="n">usbCharge</span> <span class="o">=</span> <span class="o">(</span><span class="n">chargePlug</span> <span class="o">==</span> <span class="n">BatteryManager</span><span class="o">.</span><span class="na">BATTERY_PLUGGED_USB</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">boolean</span> <span class="n">acCharge</span> <span class="o">=</span> <span class="o">(</span><span class="n">chargePlug</span> <span class="o">==</span> <span class="n">BatteryManager</span><span class="o">.</span><span class="na">BATTERY_PLUGGED_AC</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">boolean</span> <span class="n">wirelessCharge</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">Build</span><span class="o">.</span><span class="na">VERSION</span><span class="o">.</span><span class="na">SDK_INT</span> <span class="o">&gt;=</span> <span class="n">Build</span><span class="o">.</span><span class="na">VERSION_CODES</span><span class="o">.</span><span class="na">JELLY_BEAN_MR1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">wirelessCharge</span> <span class="o">=</span> <span class="o">(</span><span class="n">chargePlug</span> <span class="o">==</span> <span class="n">BatteryManager</span><span class="o">.</span><span class="na">BATTERY_PLUGGED_WIRELESS</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">(</span><span class="n">usbCharge</span> <span class="o">||</span> <span class="n">acCharge</span> <span class="o">||</span> <span class="n">wirelessCharge</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4)Wakelock and Battery Drain</h3>

<p>高效的保留更多的电量与不断促使用户使用你的App会消耗电量，这是矛盾的选择题。不过我们可以使用一些更好的办法来平衡两者。</p>

<p>假设你的手机里面装了大量的社交类应用，即使手机处于待机状态，也会经常被这些应用唤醒用来检查同步新的数据信息。Android会不断关闭各种硬件来延长手机的待机时间，首先屏幕会逐渐变暗直至关闭，然后CPU进入睡眠，这一切操作都是为了节约宝贵的电量资源。但是即使在这种睡眠状态下，大多数应用还是会尝试进行工作，他们将不断的唤醒手机。一个最简单的唤醒手机的方法是使用PowerManager.WakeLock的API来保持CPU工作并防止屏幕变暗关闭。这使得手机可以被唤醒，执行工作，然后回到睡眠状态。知道如何获取WakeLock是简单的，可是及时释放WakeLock也是非常重要的，不恰当的使用WakeLock会导致严重错误。例如网络请求的数据返回时间不确定，导致本来只需要10s的事情一直等待了1个小时，这样会使得电量白白浪费了。这也是为何使用带超时参数的wakelock.acquice()方法是很关键的。</p>

<p>但是仅仅设置超时并不足够解决问题，例如设置多长的超时比较合适？什么时候进行重试等等？解决上面的问题，正确的方式可能是使用非精准定时器。通常情况下，我们会设定一个时间进行某个操作，但是动态修改这个时间也许会更好。例如，如果有另外一个程序需要比你设定的时间晚5分钟唤醒，最好能够等到那个时候，两个任务捆绑一起同时进行，这就是非精确定时器的核心工作原理。我们可以定制计划的任务，可是系统如果检测到一个更好的时间，它可以推迟你的任务，以节省电量消耗。</p>

<p><img src="http://hukai.me/images/alarmmanager_inexact_wakelock.png" alt="alarmmanager_inexact_wakelock" /></p>

<p>这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。</p>

<h3>5)Network and Battery Drain</h3>

<p>下面内容来自官方Training文档中<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html">高效下载</a>章节关于手机(Radio)蜂窝信号对电量消耗的介绍。</p>

<p>通常情况下，使用3G移动网络传输数据，电量的消耗有三种状态：</p>

<ul>
<li><strong>Full power</strong>: 能量最高的状态，移动网络连接被激活，允许设备以最大的传输速率进行操作。</li>
<li><strong>Low power</strong>: 一种中间状态，对电量的消耗差不多是Full power状态下的50%。</li>
<li><strong>Standby</strong>: 最低的状态，没有数据连接需要传输，电量消耗最少。</li>
</ul>


<p>下图是一个典型的3G Radio State Machine的图示(来自AT&amp;T，详情请点击<a href="http://www.research.att.com/articles/featured_stories/2011_03/201102_Energy_efficient?fbid=SYuI20FzBum">这里</a>):</p>

<p><img src="http://hukai.me/images/mobile_radio_state_machine.png" title="Figure 1. Typical 3G wireless radio state machine." alt="mobile_radio_state_machine.png" /></p>

<p><strong>总之，为了减少电量的消耗，在蜂窝移动网络下，最好做到批量执行网络请求，尽量避免频繁的间隔网络请求。</strong></p>

<p>通过前面学习到的Battery Historian我们可以得到设备的电量消耗数据，如果数据中的移动蜂窝网络(Mobile Radio)电量消耗呈现下面的情况，间隔很小，又频繁断断续续的出现，说明电量消耗性能很不好：</p>

<p><img src="http://hukai.me/images/android_perf_battery_bad.png" alt="android_perf_battery_bad.png" /></p>

<p>经过优化之后，如果呈现下面的图示，说明电量消耗的性能是良好的：</p>

<p><img src="http://hukai.me/images/android_perf_battery_good.png" alt="android_perf_battery_good" /></p>

<p>另外WiFi连接下，网络传输的电量消耗要比移动网络少很多，应该尽量减少移动网络下的数据传输，多在WiFi环境下传输数据。</p>

<p><img src="http://hukai.me/images/android_perf_battery_wifi.png" alt="android_perf_battery_wifi" /></p>

<p>那么如何才能够把任务缓存起来，做到批量化执行呢？下面就轮到Job Scheduler出场了。</p>

<h3>6)Using Job Scheduler</h3>

<p>使用<a href="https://developer.android.com/reference/android/app/job/JobScheduler.html">Job Scheduler</a>，应用需要做的事情就是判断哪些任务是不紧急的，可以交给Job Scheduler来处理，Job Scheduler集中处理收到的任务，选择合适的时间，合适的网络，再一起进行执行。</p>

<p>下面是使用Job Scheduler的一段简要示例，需要先有一个JobService：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyJobService</span> <span class="kd">extends</span> <span class="n">JobService</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">LOG_TAG</span> <span class="o">=</span> <span class="s">&quot;MyJobService&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">();</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;MyJobService created&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;MyJobService destroyed&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onStartJob</span><span class="o">(</span><span class="n">JobParameters</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// This is where you would implement all of the logic for your job. Note that this runs</span>
</span><span class='line'>        <span class="c1">// on the main thread, so you will want to use a separate thread for asynchronous work</span>
</span><span class='line'>        <span class="c1">// (as we demonstrate below to establish a network connection).</span>
</span><span class='line'>        <span class="c1">// If you use a separate thread, return true to indicate that you need a &quot;reschedule&quot; to</span>
</span><span class='line'>        <span class="c1">// return to the job at some point in the future to finish processing the work. Otherwise,</span>
</span><span class='line'>        <span class="c1">// return false when finished.</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;Totally and completely working on job &quot;</span> <span class="o">+</span> <span class="n">params</span><span class="o">.</span><span class="na">getJobId</span><span class="o">());</span>
</span><span class='line'>        <span class="c1">// First, check the network, and then attempt to connect.</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">isNetworkConnected</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">new</span> <span class="nf">SimpleDownloadTask</span><span class="o">()</span> <span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">params</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;No connection on job &quot;</span> <span class="o">+</span> <span class="n">params</span><span class="o">.</span><span class="na">getJobId</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;; sad face&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onStopJob</span><span class="o">(</span><span class="n">JobParameters</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// Called if the job must be stopped before jobFinished() has been called. This may</span>
</span><span class='line'>        <span class="c1">// happen if the requirements are no longer being met, such as the user no longer</span>
</span><span class='line'>        <span class="c1">// connecting to WiFi, or the device no longer being idle. Use this callback to resolve</span>
</span><span class='line'>        <span class="c1">// anything that may cause your application to misbehave from the job being halted.</span>
</span><span class='line'>        <span class="c1">// Return true if the job should be rescheduled based on the retry criteria specified</span>
</span><span class='line'>        <span class="c1">// when the job was created or return false to drop the job. Regardless of the value</span>
</span><span class='line'>        <span class="c1">// returned, your job must stop executing.</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;Whelp, something changed, so I&#39;m calling it on job &quot;</span> <span class="o">+</span> <span class="n">params</span><span class="o">.</span><span class="na">getJobId</span><span class="o">());</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Determines if the device is currently online.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isNetworkConnected</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ConnectivityManager</span> <span class="n">connectivityManager</span> <span class="o">=</span>
</span><span class='line'>                <span class="o">(</span><span class="n">ConnectivityManager</span><span class="o">)</span> <span class="n">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">CONNECTIVITY_SERVICE</span><span class="o">);</span>
</span><span class='line'>        <span class="n">NetworkInfo</span> <span class="n">networkInfo</span> <span class="o">=</span> <span class="n">connectivityManager</span><span class="o">.</span><span class="na">getActiveNetworkInfo</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">(</span><span class="n">networkInfo</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">networkInfo</span><span class="o">.</span><span class="na">isConnected</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     *  Uses AsyncTask to create a task away from the main UI thread. This task creates a</span>
</span><span class='line'><span class="cm">     *  HTTPUrlConnection, and then downloads the contents of the webpage as an InputStream.</span>
</span><span class='line'><span class="cm">     *  The InputStream is then converted to a String, which is logged by the</span>
</span><span class='line'><span class="cm">     *  onPostExecute() method.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">SimpleDownloadTask</span> <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">JobParameters</span><span class="o">,</span> <span class="n">Void</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">protected</span> <span class="n">JobParameters</span> <span class="n">mJobParam</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nd">@Override</span>
</span><span class='line'>        <span class="kd">protected</span> <span class="n">String</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">JobParameters</span><span class="o">...</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// cache system provided job requirements</span>
</span><span class='line'>            <span class="n">mJobParam</span> <span class="o">=</span> <span class="n">params</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>            <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>                <span class="c1">// Only display the first 50 characters of the retrieved web page content.</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="n">URL</span><span class="o">(</span><span class="s">&quot;https://www.google.com&quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="n">HttpURLConnection</span> <span class="n">conn</span> <span class="o">=</span> <span class="o">(</span><span class="n">HttpURLConnection</span><span class="o">)</span> <span class="n">url</span><span class="o">.</span><span class="na">openConnection</span><span class="o">();</span>
</span><span class='line'>                <span class="n">conn</span><span class="o">.</span><span class="na">setReadTimeout</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="c1">//10sec</span>
</span><span class='line'>                <span class="n">conn</span><span class="o">.</span><span class="na">setConnectTimeout</span><span class="o">(</span><span class="mi">15000</span><span class="o">);</span> <span class="c1">//15sec</span>
</span><span class='line'>                <span class="n">conn</span><span class="o">.</span><span class="na">setRequestMethod</span><span class="o">(</span><span class="s">&quot;GET&quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="c1">//Starts the query</span>
</span><span class='line'>                <span class="n">conn</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">response</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">getResponseCode</span><span class="o">();</span>
</span><span class='line'>                <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;The response is: &quot;</span> <span class="o">+</span> <span class="n">response</span><span class="o">);</span>
</span><span class='line'>                <span class="n">is</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>                <span class="c1">// Convert the input stream to a string</span>
</span><span class='line'>                <span class="n">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>                <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">is</span><span class="o">,</span> <span class="s">&quot;UTF-8&quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="kt">char</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>
</span><span class='line'>                <span class="n">reader</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;Unable to retrieve web page.&quot;</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nd">@Override</span>
</span><span class='line'>        <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">(</span><span class="n">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">jobFinished</span><span class="o">(</span><span class="n">mJobParam</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'>            <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后模拟通过点击Button触发N个任务，交给JobService来处理</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FreeTheWakelockActivity</span> <span class="kd">extends</span> <span class="n">ActionBarActivity</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">LOG_TAG</span> <span class="o">=</span> <span class="s">&quot;FreeTheWakelockActivity&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">TextView</span> <span class="n">mWakeLockMsg</span><span class="o">;</span>
</span><span class='line'>    <span class="n">ComponentName</span> <span class="n">mServiceComponent</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_wakelock</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">mWakeLockMsg</span> <span class="o">=</span> <span class="o">(</span><span class="n">TextView</span><span class="o">)</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">wakelock_txt</span><span class="o">);</span>
</span><span class='line'>        <span class="n">mServiceComponent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ComponentName</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">MyJobService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Intent</span> <span class="n">startServiceIntent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">MyJobService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">startService</span><span class="o">(</span><span class="n">startServiceIntent</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Button</span> <span class="n">theButtonThatWakelocks</span> <span class="o">=</span> <span class="o">(</span><span class="n">Button</span><span class="o">)</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">wakelock_poll</span><span class="o">);</span>
</span><span class='line'>        <span class="n">theButtonThatWakelocks</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">string</span><span class="o">.</span><span class="na">poll_server_button</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">theButtonThatWakelocks</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">View</span><span class="o">.</span><span class="na">OnClickListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="nd">@Override</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">pollServer</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">});</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * This method polls the server via the JobScheduler API. By scheduling the job with this API,</span>
</span><span class='line'><span class="cm">     * your app can be confident it will execute, but without the need for a wake lock. Rather, the</span>
</span><span class='line'><span class="cm">     * API will take your network jobs and execute them in batch to best take advantage of the</span>
</span><span class='line'><span class="cm">     * initial network connection cost.</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * The JobScheduler API works through a background service. In this sample, we have</span>
</span><span class='line'><span class="cm">     * a simple service in MyJobService to get you started. The job is scheduled here in</span>
</span><span class='line'><span class="cm">     * the activity, but the job itself is executed in MyJobService in the startJob() method. For</span>
</span><span class='line'><span class="cm">     * example, to poll your server, you would create the network connection, send your GET</span>
</span><span class='line'><span class="cm">     * request, and then process the response all in MyJobService. This allows the JobScheduler API</span>
</span><span class='line'><span class="cm">     * to invoke your logic without needed to restart your activity.</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * For brevity in the sample, we are scheduling the same job several times in quick succession,</span>
</span><span class='line'><span class="cm">     * but again, try to consider similar tasks occurring over time in your application that can</span>
</span><span class='line'><span class="cm">     * afford to wait and may benefit from batching.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pollServer</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">JobScheduler</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="o">(</span><span class="n">JobScheduler</span><span class="o">)</span> <span class="n">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">JOB_SCHEDULER_SERVICE</span><span class="o">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">JobInfo</span> <span class="n">jobInfo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JobInfo</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">mServiceComponent</span><span class="o">)</span>
</span><span class='line'>                    <span class="o">.</span><span class="na">setMinimumLatency</span><span class="o">(</span><span class="mi">5000</span><span class="o">)</span> <span class="c1">// 5 seconds</span>
</span><span class='line'>                    <span class="o">.</span><span class="na">setOverrideDeadline</span><span class="o">(</span><span class="mi">60000</span><span class="o">)</span> <span class="c1">// 60 seconds (for brevity in the sample)</span>
</span><span class='line'>                    <span class="o">.</span><span class="na">setRequiredNetworkType</span><span class="o">(</span><span class="n">JobInfo</span><span class="o">.</span><span class="na">NETWORK_TYPE_ANY</span><span class="o">)</span> <span class="c1">// WiFi or data connections</span>
</span><span class='line'>                    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">mWakeLockMsg</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;Scheduling job &quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;!\n&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">scheduler</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="n">jobInfo</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Notes:</strong>关于更多电量优化，还有一篇文章，请点击<a href="http://developer.android.com/training/efficient-downloads/index.html">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化之内存篇]]></title>
    <link href="http://hukai.me/android-performance-memory/"/>
    <updated>2015-04-12T14:51:00+08:00</updated>
    <id>http://hukai.me/android-performance-memory</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_performance_course_udacity.jpg" alt="" /></p>

<blockquote><p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p></blockquote>

<p>下面是内存篇章的学习笔记，部分内容与前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Memory, GC, and Performance</h3>

<p>众所周知，与C/C++需要通过手动编码来申请以及释放内存有所不同，Java拥有GC的机制。Android系统里面有一个<strong>Generational Heap Memory</strong>的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</p>

<p><img src="http://hukai.me/images/memory_mode_generation.png" alt="" /></p>

<p>除了速度差异之外，执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。</p>

<!-- More -->


<p><img src="http://hukai.me/images/gc_event_thread_stop.png" alt="" /></p>

<p>通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。</p>

<h3>2)Memory Monitor Walkthrough</h3>

<p>Android Studio中的Memory Monitor可以很好的帮助我们查看程序的内存使用情况。</p>

<p><img src="http://hukai.me/images/memory_monitor_overview.png" alt="" /></p>

<p><img src="http://hukai.me/images/memory_monitor_free_allocation.png" alt="" /></p>

<p><img src="http://hukai.me/images/memory_monitor_gc_event.png" alt="" /></p>

<h3>3)Memory Leaks</h3>

<p>内存泄漏表示的是不再用到的对象因为被错误引用而无法进行回收。</p>

<p><img src="http://hukai.me/images/android_perf_memory_leak.png" alt="" /></p>

<p>发生内存泄漏会导致Memory Generation中的剩余可用Heap Size越来越小，这样会导致频繁触发GC，更进一步引起性能问题。</p>

<p>举例内存泄漏，下面<code>init()</code>方法来自某个自定义View：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'><span class="n">ListenerCollector</span> <span class="n">collector</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListenerCollector</span><span class="o">();</span>
</span><span class='line'><span class="n">collector</span><span class="o">.</span><span class="na">setListener</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">mListener</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子容易存在内存泄漏，如果activity因为设备翻转而重新创建，自定义的View会自动重新把新创建出来的mListener给绑定到ListenerCollector中，但是当activity被销毁的时候，mListener却无法被回收了。</p>

<h3>4)Heap Viewer Walkthrough</h3>

<p>下图演示了Android Tools里面的Heap Viewer的功能，我们可以看到当前进程中的Heap Size的情况，分别有哪些类型的数据，占比是多少。</p>

<p><img src="http://hukai.me/images/android_perf_memory_heap_viewer.png" alt="" /></p>

<h3>5)Understanding Memory Churn</h3>

<p><strong>Memory Churn内存抖动</strong>，内存抖动是因为在短时间内大量的对象被创建又马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，会触发GC从而导致刚产生的对象又很快被回收。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</p>

<p><img src="http://hukai.me/images/gc_overtime.png" alt="" /></p>

<p>解决上面的问题有简洁直观方法，如果你在<strong>Memory Monitor</strong>里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。</p>

<p><img src="http://hukai.me/images/memory_monitor_gc.png" alt="" /></p>

<p>同时我们还可以通过<strong>Allocation Tracker</strong>来查看在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一。</p>

<p>当你大致定位问题之后，接下去的问题修复也就显得相对直接简单了。例如，你需要避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外，自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。</p>

<h3>6)Allocation Tracker</h3>

<p>关于Allocation Tracker工具的使用，不展开了，参考下面的链接：</p>

<ul>
<li><a href="http://developer.android.com/tools/debugging/ddms.html#alloc">http://developer.android.com/tools/debugging/ddms.html#alloc</a></li>
<li><a href="http://android-developers.blogspot.com/2009/02/track-memory-allocations.html">http://android-developers.blogspot.com/2009/02/track-memory-allocations.html</a></li>
</ul>


<h3>7)Improve Your Code To Reduce Churn</h3>

<p>下面演示一个例子，如何通过修改代码来避免内存抖动。优化之前的内存检测图：</p>

<p><img src="http://hukai.me/images/android_perf_memory_churn_1.png" alt="" /></p>

<p>定位代码之后，修复了String拼接的问题：</p>

<p><img src="http://hukai.me/images/android_perf_memory_churn_code.png" alt="" /></p>

<p>优化之后的内存监测图：</p>

<p><img src="http://hukai.me/images/android_perf_memory_churn_2.png" alt="" /></p>

<h3>8)Recap</h3>

<p>上面提到了三种测量内存的工具，下面再简要概括一下他们各自的特点：</p>

<ul>
<li><strong>Memory Monitor：</strong>跟踪整个app的内存变化情况。</li>
<li><strong>Heap Viewer：</strong>查看当前内存快照，便于对比分析哪些对象有可能发生了泄漏。</li>
<li><strong>Allocation Tracker：</strong>追踪内存对象的来源。</li>
</ul>


<p><strong>Notes:</strong>关于更多内存优化，这里还有一篇文章，请点击<a href="http://hukai.me/android-training-managing_your_app_memory/">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化之运算篇]]></title>
    <link href="http://hukai.me/android-performance-compute/"/>
    <updated>2015-04-12T13:50:00+08:00</updated>
    <id>http://hukai.me/android-performance-compute</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_performance_course_udacity.jpg" alt="" /></p>

<blockquote><p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p></blockquote>

<p>下面是运算篇章的学习笔记，部分内容与前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Intro to Compute and Memory Problems</h3>

<p>Android中的Java代码会需要经过编译优化再执行的过程。代码的不同写法会影响到Java编译器的优化效率。例如for循环的不同写法就会对编译器优化这段代码产生不同的效率，当程序中包含大量这种可优化的代码的时候，运算性能就会出现问题。想要知道如何优化代码的运算性能就需要知道代码在硬件层的执行差异。</p>

<h3>2)Slow Function Performance</h3>

<p>如果你写了一段代码，它的执行效率比想象中的要差很多。我们需要知道有哪些因素有可能影响到这段代码的执行效率。例如：比较两个float数值大小的执行时间是int数值的4倍左右。这是因为CPU的运算架构导致的，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_compute_float_int.png" alt="" /></p>

<p>虽然现代的CPU架构得到了很大的提升，也许并不存在上面所示的那么大的差异，但是这个例子说明了代码写法上的差异会对运算性能产生很大的影响。</p>

<!-- More -->


<p>通常来说有两类运行效率差的情况：第1种是相对执行时间长的方法，我们可以很轻松的找到这些方法并做一定的优化。第2种是执行时间短，但是执行频次很高的方法，因为执行次数多，累积效应下就会对性能产生很大的影响。</p>

<p>修复这些细节效率问题，需要使用Android SDK提供的工具，进行仔细的测量，然后再进行微调修复。</p>

<h3>3)Traceview Walkthrough</h3>

<p>通过Android Studio打开里面的Android Device Monitor，切换到DDMS窗口，点击左边栏上面想要跟踪的进程，再点击上面的Start Method Tracing的按钮，如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_compute_traceview.png" alt="" /></p>

<p>启动跟踪之后，再操控app，做一些你想要跟踪的事件，例如滑动listview，点击某些视图进入另外一个页面等等。操作完之后，回到Android Device Monitor，再次点击Method Tracing的按钮停止跟踪。此时工具会为刚才的操作生成TraceView的详细视图。</p>

<p><img src="http://hukai.me/images/android_perf_compute_traceview_2.png" alt="" /></p>

<p>关于TraceView中详细数据如何查看，这里不展开了，有很多文章介绍过。</p>

<h3>4)Batching and Caching</h3>

<p>为了提升运算性能，这里介绍2个非常重要的技术，Batching与Caching。</p>

<p><strong>Batching</strong>是在真正执行运算操作之前对数据进行批量预处理，例如你需要有这样一个方法，它的作用是查找某个值是否存在与于一堆数据中。假设一个前提，我们会先对数据做排序，然后使用二分查找法来判断值是否存在。我们先看第一种情况，下图中存在着多次重复的排序操作。</p>

<p><img src="http://hukai.me/images/android_perf_compute_batching_1.png" alt="" /></p>

<p>在上面的那种写法下，如果数据的量级并不大的话，应该还可以接受，可是如果数据集非常大，就会有严重的效率问题。那么我们看下改进的写法，把排序的操作打包绑定只执行一次：</p>

<p><img src="http://hukai.me/images/android_perf_compute_batching_2.png" alt="" /></p>

<p>上面就是Batching的一种示例：把重复的操作拎出来，打包只执行一次。</p>

<p><strong>Caching</strong>的理念很容易理解，在很多方面都有体现，下面举一个for循环的例子：</p>

<p><img src="http://hukai.me/images/android_perf_compute_caching.png" alt="" /></p>

<p>上面这2种基础技巧非常实用，积极恰当的使用能够显著提升运算性能。</p>

<h3>5)Blocking the UI Thread</h3>

<p>提升代码的运算效率是改善性能的一方面，让代码执行在哪个线程也同样很重要。我们都知道Android的Main Thread也是UI Thread，它需要承担用户的触摸事件的反馈，界面视图的渲染等操作。这就意味着，我们不能在Main Thread里面做任何非轻量级的操作，类似I/O操作会花费大量时间，这很有可能会导致界面渲染发生丢帧的现象，甚至有可能导致ANR。防止这些问题的解决办法就是把那些可能有性能问题的代码移到非UI线程进行操作。</p>

<h3>6)Container Performance</h3>

<p>另外一个我们需要注意的运算性能问题是基础算法的合理选择，例如冒泡排序与快速排序的性能差异：</p>

<p><img src="http://hukai.me/images/android_perf_compute_container.png" alt="" /></p>

<p>避免我们重复造轮子，Java提供了很多现成的容器，例如Vector，ArrayList，LinkedList，HashMap等等，在Android里面还有新增加的SparseArray等，我们需要了解这些基础容器的性能差异以及适用场景。这样才能够选择合适的容器，达到最佳的性能。</p>

<p><img src="http://hukai.me/images/android_perf_compute_container_2.png" alt="" /></p>

<p><strong>Notes:</strong>关于更多代码优化的小技巧，请点击<a href="http://hukai.me/android-training-performance-tips/">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化之渲染篇]]></title>
    <link href="http://hukai.me/android-performance-render/"/>
    <updated>2015-04-11T22:16:00+08:00</updated>
    <id>http://hukai.me/android-performance-render</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_performance_course_udacity.jpg" alt="" /></p>

<blockquote><p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p></blockquote>

<p>下面是渲染篇章的学习笔记，部分内容和前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Why Rendering Performance Matters</h3>

<p>现在有不少App为了达到很华丽的视觉效果，会需要在界面上层叠很多的视图组件，但是这会很容易引起性能问题。如何平衡Design与Performance就很需要智慧了。</p>

<h3>2)Defining &#8216;Jank&#8217;</h3>

<p>大多数手机的屏幕刷新频率是60hz，如果在1000/60=16.67ms内没有办法把这一帧的任务执行完毕，就会发生丢帧的现象。丢帧越多，用户感受到的卡顿情况就越严重。</p>

<p><img src="http://hukai.me/images/android_performance_course_drop_frame.png" alt="" /></p>

<h3>3)Rendering Pipeline: Common Problems</h3>

<p>渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。</p>

<!-- More -->


<p><img src="http://hukai.me/images/android_performance_course_render_problems.jpg" alt="" /></p>

<h3>4)Android UI and the GPU</h3>

<p>了解Android是如何利用GPU进行画面渲染有助于我们更好的理解性能问题。一个很直接的问题是：activity的画面是如何绘制到屏幕上的？那些复杂的XML布局文件又是如何能够被识别并绘制出来的？</p>

<p><img src="http://hukai.me/images/gpu_rasterization.png" alt="" /></p>

<p><strong>Resterization栅格化</strong>是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>

<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。</p>

<p><img src="http://hukai.me/images/gpu_cpu_rasterization.png" alt="" /></p>

<p>然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。</p>

<p>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示比较复杂，需要先经过CPU换算成纹理，然后交给GPU进行渲染，返回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则存在一个更加复杂的操作流程。</p>

<p>为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。</p>

<h3>5)GPU Problem: Overdraw</h3>

<p>Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次。这样就会浪费大量的CPU以及GPU资源。</p>

<p><img src="http://hukai.me/images/overdraw_hidden_view.png" alt="" /></p>

<p>当设计上追求更华丽的视觉效果的时候，我们就容易陷入采用复杂的多层次重叠视图来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳的性能，我们必须尽量减少Overdraw的情况发生。</p>

<p>幸运的是，我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，观察UI上的Overdraw情况。</p>

<p><img src="http://hukai.me/images/overdraw_options_view.png" alt="" /></p>

<p>蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。</p>

<h3>6)Visualize and Fix Overdraw - Quiz &amp; Solution</h3>

<p>这里举了一个例子，通过XML文件可以看到有好几处非必需的background。通过把XML中非必需的background移除之后，可以显著减少布局的过度绘制。其中一个比较有意思的地方是：针对ListView中的Avatar ImageView的设置，在getView的代码里面，判断是否获取到对应的Bitmap，在获取到Avatar的图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到的时候才设置对应的Background占位图片，这样可以避免因为给Avatar设置背景图而导致的过度渲染。</p>

<p><img src="http://hukai.me/images/android_perf_course_overdraw_compare.png" alt="" /></p>

<p>总结一下，优化步骤如下：</p>

<ul>
<li>移除Window默认的Background</li>
<li>移除XML布局文件中非必需的Background</li>
<li>按需显示占位背景图片</li>
</ul>


<h3>7)ClipRect &amp; QuickReject</h3>

<p>前面有提到过，对不可见的UI组件进行绘制更新会导致Overdraw。例如Nav Drawer从前置可见的Activity滑出之后，如果还继续绘制那些在Nav Drawer里面不可见的UI组件，这就导致了Overdraw。为了解决这个问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少Overdraw。那些Nav Drawer里面不可见的View就不会被执行浪费资源。</p>

<p><img src="http://hukai.me/images/overdraw_invisible.png" alt="" /></p>

<p>但是不幸的是，对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过<a href="http://developer.android.com/reference/android/graphics/Canvas.html">canvas.clipRect()</a>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p>

<p><img src="http://hukai.me/images/overdraw_reduce_cpu_gpu.png" alt="" /></p>

<p>除了clipRect方法之外，我们还可以使用<a href="http://developer.android.com/reference/android/graphics/Canvas.html">canvas.quickreject()</a>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p>

<h3>8)Apply clipRect and quickReject - Quiz &amp; Solution</h3>

<p><img src="http://hukai.me/images/android_perf_course_clip_1.png" alt="" /></p>

<p>上面的示例图中显示了一个自定义的View，主要效果是呈现多张重叠的卡片。这个View的onDraw方法如下图所示：</p>

<p><img src="http://hukai.me/images/android_perf_course_clip_3.png" alt="" /></p>

<p>打开开发者选项中的显示过度渲染，可以看到我们这个自定义的View部分区域存在着过度绘制。那么是什么原因导致过度绘制的呢？</p>

<p><img src="http://hukai.me/images/android_perf_course_clip_2.png" alt="" /></p>

<h3>9)Fixing Overdraw with Canvas API</h3>

<p>下面的代码显示了如何通过clipRect来解决自定义View的过度绘制，提高自定义View的绘制性能：</p>

<p><img src="http://hukai.me/images/android_perf_course_clip_code_compare.png" alt="" /></p>

<p>下面是优化过后的效果：</p>

<p><img src="http://hukai.me/images/android_perf_course_clip_result.png" alt="" /></p>

<h3>10)Layouts, Invalidations and Perf</h3>

<p>Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在<strong>DisplayList</strong>的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。</p>

<p>在某个View第一次需要被渲染时，Display List会因此被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。</p>

<p>如果View的Property属性发生了改变（例如移动位置），我们就仅仅需要Execute Display List就够了。</p>

<p><img src="http://hukai.me/images/android_perf_course_displaylist_execute.png" alt="" /></p>

<p>然而如果你修改了View中的某些可见组件的内容，那么之前的DisplayList就无法继续使用了，我们需要重新创建一个DisplayList并重新执行渲染指令更新到屏幕上。</p>

<p><img src="http://hukai.me/images/android_perf_course_displaylist_invalidation.png" alt="" /></p>

<p>请注意：任何时候View中的绘制内容发生变化时，都会需要重新创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。</p>

<p><img src="http://hukai.me/images/android_perf_course_displaylist_kick_off.png" alt="" /></p>

<h3>11)Hierarchy Viewer: Walkthrough</h3>

<p>Hierarchy Viewer可以很直接的呈现布局的层次关系，视图组件的各种属性。
我们可以通过红，黄，绿三种不同的颜色来区分布局的Measure，Layout，Executive的相对性能表现如何。</p>

<h3>12)Nested Hierarchies and Performance</h3>

<p>提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。例如下面的例子，有2行显示相同内容的视图，分别用两种不同的写法来实现，他们有着不同的层级。</p>

<p><img src="http://hukai.me/images/android_perf_course_hierarchy_1.png" alt="" /></p>

<p><img src="http://hukai.me/images/android_perf_course_hierarchy_2.png" alt="" /></p>

<p>下图显示了使用2种不同的写法，在Hierarchy Viewer上呈现出来的性能测试差异：</p>

<p><img src="http://hukai.me/images/android_perf_course_hierarchy_3.png" alt="" /></p>

<h3>13)Optimizing Your Layout</h3>

<p>下图举例演示了如何优化ListItem的布局，通过RelativeLayout替代旧方案中的嵌套LinearLayout来优化布局。</p>

<p><img src="http://hukai.me/images/android_perf_course_hierarchy_4.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第1季]]></title>
    <link href="http://hukai.me/android-performance-patterns/"/>
    <updated>2015-01-17T19:42:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns</id>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_perf_patterns.png" alt="" /></p>

<blockquote><p>2015新年伊始，Google发布了关于<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范的专题</a>，一共16个短视频，每个3-5分钟，帮助开发者创建更快更优秀的Android App。课程专题不仅仅介绍了Android系统中有关性能问题的底层工作原理，同时也介绍了如何通过工具来找出性能问题以及提升性能的建议。主要从三个方面展开，Android的渲染机制，内存与GC，电量优化。下面是对这些问题和建议的总结梳理。</p></blockquote>

<h2>0)Render Performance</h2>

<p>大多数用户感知到的卡顿等性能问题的最主要根源都是因为渲染性能。从设计师的角度，他们希望App能够有更多的动画，图片等时尚元素来实现流畅的用户体验。但是Android系统很有可能无法及时完成那些复杂的界面渲染操作。Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。</p>

<p><img src="http://hukai.me/images/draw_per_16ms.png" alt="" /></p>

<!-- More -->


<p>如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在32ms内看到的会是同一帧画面。</p>

<p><img src="http://hukai.me/images/vsync_over_draw.png" alt="" /></p>

<p>用户容易在UI执行动画或者滑动ListView的时候感知到卡顿不流畅，是因为这里的操作相对复杂，容易发生丢帧的现象，从而感觉卡顿。有很多原因可以导致丢帧，也许是因为你的layout太过复杂，无法在16ms内完成渲染，有可能是因为你的UI上有层叠太多的绘制单元，还有可能是因为动画执行的次数过多。这些都会导致CPU或者GPU负载过重。</p>

<p>我们可以通过一些工具来定位问题，比如可以使用HierarchyViewer来查找Activity中的布局是否过于复杂，也可以使用手机设置里面的开发者选项，打开Show GPU Overdraw等选项进行观察。你还可以使用TraceView来观察CPU的执行情况，更加快捷的找到性能瓶颈。</p>

<h2>1)Understanding Overdraw</h2>

<p>Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。</p>

<p><img src="http://hukai.me/images/overdraw_hidden_view.png" alt="" /></p>

<p>当设计上追求更华丽的视觉效果的时候，我们就容易陷入采用越来越多的层叠组件来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳的性能，我们必须尽量减少Overdraw的情况发生。</p>

<p>幸运的是，我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，可以观察UI上的Overdraw情况。</p>

<p><img src="http://hukai.me/images/overdraw_options_view.png" alt="" /></p>

<p>蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。</p>

<p>Overdraw有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。例如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色Overdraw区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。</p>

<h2>2)Understanding VSYNC</h2>

<p>为了理解App是如何进行渲染的，我们必须了解手机硬件是如何工作，那么就必须理解什么是<em>VSYNC</em>。</p>

<p>在讲解VSYNC之前，我们需要了解两个相关的概念：</p>

<ul>
<li>Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的固定参数，例如60Hz。</li>
<li>Frame Rate：代表了GPU在一秒内绘制操作的帧数，例如30fps，60fps。</li>
</ul>


<p>GPU会获取图形数据进行渲染，然后硬件负责把渲染后的内容呈现到屏幕上，他们两者不停的进行协作。</p>

<p><img src="http://hukai.me/images/vsync_gpu_hardware.png" alt="" /></p>

<p>不幸的是，刷新频率和帧率并不是总能够保持相同的节奏。如果发生帧率与刷新频率不一致的情况，就会容易出现<strong>Tearing</strong>的现象(画面上下两部分显示内容发生断裂，来自不同的两帧数据发生重叠)。</p>

<p><img src="http://hukai.me/images/vsync_gpu_hardware_not_sync.png" alt="" /></p>

<p><img src="http://hukai.me/images/vsync_buffer.png" alt="" /></p>

<p>理解图像渲染里面的双重与三重缓存机制，这个概念比较复杂，请移步查看这里：<a href="http://source.android.com/devices/graphics/index.html">http://source.android.com/devices/graphics/index.html</a>，还有这里<a href="http://article.yeeyan.org/view/37503/304664">http://article.yeeyan.org/view/37503/304664</a>。</p>

<p>通常来说，帧率超过刷新频率只是一种理想的状况，在超过60fps的情况下，GPU所产生的帧数据会因为等待VSYNC的刷新信息而被Hold住，这样能够保持每次刷新都有实际的新的数据可以显示。但是我们遇到更多的情况是帧率小于刷新频率。</p>

<p><img src="http://hukai.me/images/vsync_gpu_hardware_not_sync2.png" alt="" /></p>

<p>在这种情况下，某些帧显示的画面内容就会与上一帧的画面相同。糟糕的事情是，帧率从超过60fps突然掉到60fps以下，这样就会发生<strong>LAG</strong>，<strong>JANK</strong>，<strong>HITCHING</strong>等卡顿掉帧的不顺滑的情况。这也是用户感受不好的原因所在。</p>

<h2>3)Tool:Profile GPU Rendering</h2>

<p>性能问题如此的麻烦，幸好我们可以有工具来进行调试。打开手机里面的开发者选项，选择Profile GPU Rendering，选中On screen as bars的选项。</p>

<p><img src="http://hukai.me/images/tools_gpu_profile_rendering.png" alt="" /></p>

<p>选择了这样以后，我们可以在手机画面上看到丰富的GPU绘制图形信息，分别关于StatusBar，NavBar，激活的程序Activity区域的GPU Rending信息。</p>

<p><img src="http://hukai.me/images/tools_gpu_profile_rendering_graphic_activity.png" alt="" /></p>

<p>随着界面的刷新，界面上会滚动显示垂直的柱状图来表示每帧画面所需要渲染的时间，柱状图越高表示花费的渲染时间越长。</p>

<p><img src="http://hukai.me/images/tools_gpu_rendering_bar.png" alt="" /></p>

<p>中间有一根绿色的横线，代表16ms，我们需要确保每一帧花费的总时间都低于这条横线，这样才能够避免出现卡顿的问题。</p>

<p><img src="http://hukai.me/images/tools_gpu_profile_three_color.png" alt="" /></p>

<p>每一条柱状线都包含三部分，蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间。</p>

<h2>4)Why 60fps?</h2>

<p>我们通常都会提到60fps与16ms，可是知道为何会是以程序是否达到60fps来作为App性能的衡量标准吗？这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新。</p>

<p>12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。但是低于30fps是无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果，当然超过60fps是没有必要的。</p>

<p>开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。</p>

<h2>5)Android, UI and the GPU</h2>

<p>了解Android是如何利用GPU进行画面渲染有助于我们更好的理解性能问题。那么一个最实际的问题是：activity的画面是如何绘制到屏幕上的？那些复杂的XML布局文件又是如何能够被识别并绘制出来的？</p>

<p><img src="http://hukai.me/images/gpu_rasterization.png" alt="" /></p>

<p><strong>Resterization栅格化</strong>是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>

<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。</p>

<p><img src="http://hukai.me/images/gpu_cpu_rasterization.png" alt="" /></p>

<p>然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。</p>

<p>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示更加复杂，需要先经过CPU换算成纹理，然后再交给GPU进行渲染，回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则是一个更加复杂的操作流程。</p>

<p>为了能够使得App流畅，我们需要在每一帧16ms以内处理完所有的CPU与GPU计算，绘制，渲染等等操作。</p>

<h2>6)Invalidations, Layouts, and Performance</h2>

<p>顺滑精妙的动画是app设计里面最重要的元素之一，这些动画能够显著提升用户体验。下面会讲解Android系统是如何处理UI组件的更新操作的。</p>

<p>通常来说，Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在<strong>DisplayList</strong>的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。</p>

<p>在某个View第一次需要被渲染时，DisplayList会因此而被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。如果你在后续有执行类似移动这个View的位置等操作而需要再次渲染这个View时，我们就仅仅需要额外操作一次渲染指令就够了。然而如果你修改了View中的某些可见组件，那么之前的DisplayList就无法继续使用了，我们需要回头重新创建一个DisplayList并且重新执行渲染指令并更新到屏幕上。</p>

<p>需要注意的是：任何时候View中的绘制内容发生变化时，都会重新执行创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。我们需要尽量减少Overdraw。</p>

<p><img src="http://hukai.me/images/layout_three_steps.png" alt="" /></p>

<p>我们可以通过前面介绍的Monitor GPU Rendering来查看渲染的表现性能如何，另外也可以通过开发者选项里面的Show GPU view updates来查看视图更新的操作，最后我们还可以通过HierarchyViewer这个工具来查看布局，使得布局尽量扁平化，移除非必需的UI组件，这些操作能够减少Measure，Layout的计算时间。</p>

<h2>7)Overdraw, Cliprect, QuickReject</h2>

<p>引起性能问题的一个很重要的方面是因为过多复杂的绘制操作。我们可以通过工具来检测并修复标准UI组件的Overdraw问题，但是针对高度自定义的UI组件则显得有些力不从心。</p>

<p>有一个窍门是我们可以通过执行几个APIs方法来显著提升绘制操作的性能。前面有提到过，非可见的UI组件进行绘制更新会导致Overdraw。例如Nav Drawer从前置可见的Activity滑出之后，如果还继续绘制那些在Nav Drawer里面不可见的UI组件，这就导致了Overdraw。为了解决这个问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少Overdraw。那些Nav Drawer里面不可见的View就不会被执行浪费资源。</p>

<p><img src="http://hukai.me/images/overdraw_invisible.png" alt="" /></p>

<p>但是不幸的是，对于那些过于复杂的自定义的View(重写了onDraw方法)，Android系统无法检测具体在onDraw里面会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过<a href="http://developer.android.com/reference/android/graphics/Canvas.html">canvas.clipRect()</a>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p>

<p><img src="http://hukai.me/images/overdraw_reduce_cpu_gpu.png" alt="" /></p>

<p>除了clipRect方法之外，我们还可以使用<a href="http://developer.android.com/reference/android/graphics/Canvas.html">canvas.quickreject()</a>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。做了那些优化之后，我们可以通过上面介绍的Show GPU Overdraw来查看效果。</p>

<h2>8)Memory Churn and performance</h2>

<p>虽然Android有自动管理内存的机制，但是对内存的不恰当使用仍然容易引起严重的性能问题。在同一帧里面创建过多的对象是件需要特别引起注意的事情。</p>

<p>Android系统里面有一个<strong>Generational Heap Memory</strong>的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</p>

<p><img src="http://hukai.me/images/memory_mode_generation.png" alt="" /></p>

<p>除了速度差异之外，执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。</p>

<p><img src="http://hukai.me/images/gc_event_thread_stop.png" alt="" /></p>

<p>通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。</p>

<p>导致GC频繁执行有两个原因：</p>

<ul>
<li><strong>Memory Churn内存抖动</strong>，内存抖动是因为大量的对象被创建又在短时间内马上被释放。</li>
<li>瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</li>
</ul>


<p><img src="http://hukai.me/images/gc_overtime.png" alt="" /></p>

<p>解决上面的问题有简洁直观方法，如果你在<strong>Memory Monitor</strong>里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。</p>

<p><img src="http://hukai.me/images/memory_monitor_gc.png" alt="" /></p>

<p>同时我们还可以通过<strong>Allocation Tracker</strong>来查看在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一。</p>

<p>当你大致定位问题之后，接下去的问题修复也就显得相对直接简单了。例如，你需要避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外，自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。</p>

<h2>9)Garbage Collection in Android</h2>

<p>JVM的回收机制给开发人员带来很大的好处，不用时刻处理对象的分配与回收，可以更加专注于更加高级的代码实现。相比起Java，C与C++等语言具备更高的执行效率，他们需要开发人员自己关注对象的分配与回收，但是在一个庞大的系统当中，还是免不了经常发生部分对象忘记回收的情况，这就是内存泄漏。</p>

<p>原始JVM中的GC机制在Android中得到了很大程度上的优化。Android里面是一个三级Generation的内存模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。</p>

<p><img src="http://hukai.me/images/android_memory_gc_mode.png" alt="" /></p>

<p>每一个级别的内存区域都有固定的大小，此后不断有新的对象被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发GC的操作，以便腾出空间来存放其他新的对象。</p>

<p><img src="http://hukai.me/images/gc_threshold.png" alt="" /></p>

<p>前面提到过每次GC发生的时候，所有的线程都是暂停状态的。GC所占用的时间和它是哪一个Generation也有关系，Young Generation的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。执行时间的长短也和当前Generation中的对象数量有关，遍历查找20000个对象比起遍历50个对象自然是要慢很多的。</p>

<p>虽然Google的工程师在尽量缩短每次GC所花费的时间，但是特别注意GC引起的性能问题还是很有必要。如果不小心在最小的for循环单元里面执行了创建对象的操作，这将很容易引起GC并导致性能问题。通过Memory Monitor我们可以查看到内存的占用情况，每一次瞬间的内存降低都是因为此时发生了GC操作，如果在短时间内发生大量的内存上涨与降低的事件，这说明很有可能这里有性能问题。我们还可以通过<strong>Heap and Allocation Tracker</strong>工具来查看此时内存中分配的到底有哪些对象。</p>

<h2>10)Performance Cost of Memory Leaks</h2>

<p>虽然Java有自动回收的机制，可是这不意味着Java中不存在内存泄漏的问题，而内存泄漏会很容易导致严重的性能问题。</p>

<p>内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。</p>

<p>寻找内存泄漏并修复这个漏洞是件很棘手的事情，你需要对执行的代码很熟悉，清楚的知道在特定环境下是如何运行的，然后仔细排查。例如，你想知道程序中的某个activity退出的时候，它之前所占用的内存是否有完整的释放干净了？首先你需要在activity处于前台的时候使用Heap Tool获取一份当前状态的内存快照，然后你需要创建一个几乎不这么占用内存的空白activity用来给前一个Activity进行跳转，其次在跳转到这个空白的activity的时候主动调用System.gc()方法来确保触发一个GC操作。最后，如果前面这个activity的内存都有全部正确释放，那么在空白activity被启动之后的内存快照中应该不会有前面那个activity中的任何对象了。</p>

<p><img src="http://hukai.me/images/memory_leak_profile_method.png" alt="" /></p>

<p>如果你发现在空白activity的内存快照中有一些可疑的没有被释放的对象存在，那么接下去就应该使用<strong>Alocation Track Tool</strong>来仔细查找具体的可疑对象。我们可以从空白activity开始监听，启动到观察activity，然后再回到空白activity结束监听。这样操作以后，我们可以仔细观察那些对象，找出内存泄漏的真凶。</p>

<p><img src="http://hukai.me/images/memory_leak_track_method.png" alt="" /></p>

<h2>11)Memory Performance</h2>

<p>通常来说，Android对GC做了大量的优化操作，虽然执行GC操作的时候会暂停其他任务，可是大多数情况下，GC操作还是相对很安静并且高效的。但是如果我们对内存的使用不恰当，导致GC频繁执行，这样就会引起不小的性能问题。</p>

<p>为了寻找内存的性能问题，Android Studio提供了工具来帮助开发者。</p>

<ul>
<li><strong>Memory Monitor：</strong>查看整个app所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号。</li>
<li><strong>Allocation Tracker：</strong>使用此工具来追踪内存的分配，前面有提到过。</li>
<li><strong>Heap Tool：</strong>查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的，请参考前面的Case。</li>
</ul>


<h2>12)Tool - Memory Monitor</h2>

<p>Android Studio中的Memory Monitor可以很好的帮助我们查看程序的内存使用情况。</p>

<p><img src="http://hukai.me/images/memory_monitor_overview.png" alt="" /></p>

<p><img src="http://hukai.me/images/memory_monitor_free_allocation.png" alt="" /></p>

<p><img src="http://hukai.me/images/memory_monitor_gc_event.png" alt="" /></p>

<h2>13)Battery Performance</h2>

<p>电量其实是目前手持设备最宝贵的资源之一，大多数设备都需要不断的充电来维持继续使用。不幸的是，对于开发者来说，电量优化是他们最后才会考虑的的事情。但是可以确定的是，千万不能让你的应用成为消耗电量的大户。</p>

<p>Purdue University研究了最受欢迎的一些应用的电量消耗，平均只有30%左右的电量是被程序最核心的方法例如绘制图片，摆放布局等等所使用掉的，剩下的70%左右的电量是被上报数据，检查位置信息，定时检索后台广告信息所使用掉的。如何平衡这两者的电量消耗，就显得非常重要了。</p>

<p>有下面一些措施能够显著减少电量的消耗：</p>

<ul>
<li>我们应该尽量减少唤醒屏幕的次数与持续的时间，使用WakeLock来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态。</li>
<li>某些非必须马上执行的操作，例如上传歌曲，图片处理等，可以等到设备处于充电状态或者电量充足的时候才进行。</li>
<li>触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗。关于网络请求引起无线信号的电量消耗，还可以参考这里<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html">http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html</a></li>
</ul>


<p>我们可以通过手机设置选项找到对应App的电量消耗统计数据。我们还可以通过<strong>Battery Historian Tool</strong>来查看详细的电量消耗。</p>

<p><img src="http://hukai.me/images/battery_usages_settings.png" alt="" /></p>

<p>如果发现我们的App有电量消耗过多的问题，我们可以使用JobScheduler API来对一些任务进行定时处理，例如我们可以把那些任务重的操作等到手机处于充电状态，或者是连接到WiFi的时候来处理。
关于JobScheduler的更多知识可以参考<a href="http://hukai.me/android-training-course-in-chinese/background-jobs/scheduling/index.html">http://hukai.me/android-training-course-in-chinese/background-jobs/scheduling/index.html</a></p>

<h2>14)Understanding Battery Drain on Android</h2>

<p>电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗。</p>

<p>当设备处于待机状态时消耗的电量是极少的，以N5为例，打开飞行模式，可以待机接近1个月。可是点亮屏幕，硬件各个模块就需要开始工作，这会需要消耗很多电量。</p>

<p>使用WakeLock或者JobScheduler唤醒设备处理定时的任务之后，一定要及时让设备回到初始状态。每次唤醒无线信号进行数据传递，都会消耗很多电量，它比WiFi等操作更加的耗电，详情请关注<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html">http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html</a></p>

<p><img src="http://hukai.me/images/battery_drain_radio.png" alt="" /></p>

<p>修复电量的消耗是另外一个很大的课题，这里就不展开继续了。</p>

<h2>15)Battery Drain and WakeLocks</h2>

<p>高效的保留更多的电量与不断促使用户使用你的App会消耗电量，这是矛盾的选择题。不过我们可以使用一些更好的办法来平衡两者。</p>

<p>假设你的手机里面装了大量的社交类应用，即使手机处于待机状态，也会经常被这些应用唤醒用来检查同步新的数据信息。Android会不断关闭各种硬件来延长手机的待机时间，首先屏幕会逐渐变暗直至关闭，然后CPU进入睡眠，这一切操作都是为了节约宝贵的电量资源。但是即使在这种睡眠状态下，大多数应用还是会尝试进行工作，他们将不断的唤醒手机。一个最简单的唤醒手机的方法是使用PowerManager.WakeLock的API来保持CPU工作并防止屏幕变暗关闭。这使得手机可以被唤醒，执行工作，然后回到睡眠状态。知道如何获取WakeLock是简单的，可是及时释放WakeLock也是非常重要的，不恰当的使用WakeLock会导致严重错误。例如网络请求的数据返回时间不确定，导致本来只需要10s的事情一直等待了1个小时，这样会使得电量白白浪费了。这也是为何使用带超时参数的wakelock.acquice()方法是很关键的。但是仅仅设置超时并不足够解决问题，例如设置多长的超时比较合适？什么时候进行重试等等？</p>

<p>解决上面的问题，正确的方式可能是使用非精准定时器。通常情况下，我们会设定一个时间进行某个操作，但是动态修改这个时间也许会更好。例如，如果有另外一个程序需要比你设定的时间晚5分钟唤醒，最好能够等到那个时候，两个任务捆绑一起同时进行，这就是非精确定时器的核心工作原理。我们可以定制计划的任务，可是系统如果检测到一个更好的时间，它可以推迟你的任务，以节省电量消耗。</p>

<p><img src="http://hukai.me/images/alarmmanager_inexact_wakelock.png" alt="" /></p>

<p>这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。</p>

<p>从Android 5.0开始发布了Battery History Tool，它可以查看程序被唤醒的频率，又谁唤醒的，持续了多长的时间，这些信息都可以获取到。</p>

<p>请关注程序的电量消耗，用户可以通过手机的设置选项观察到那些耗电量大户，并可能决定卸载他们。所以尽量减少程序的电量消耗是非常有必要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android APK安装包瘦身]]></title>
    <link href="http://hukai.me/android-tips-for-reduce-apk-size/"/>
    <updated>2014-09-13T20:24:00+08:00</updated>
    <id>http://hukai.me/android-tips-for-reduce-apk-size</id>
    <content type="html"><![CDATA[<p>很显然，APK安装包越小越好。下面从代码，资源文件，使用策略几个方面简要介绍下：</p>

<h3>代码</h3>

<ul>
<li>保持良好的编程习惯，不要重复或者不用的代码，谨慎添加libs，移除使用不到的libs。</li>
<li>使用proguard混淆代码，它会对不用的代码做优化，并且混淆后也能够减少安装包的大小。</li>
<li>native code的部分，大多数情况下只需要支持armabi与x86的架构即可。如果非必须，可以考虑拿掉x86的部分。</li>
</ul>


<h3>资源</h3>

<ul>
<li>使用Lint工具查找没有使用到的资源。去除不使用的图片，String，XML等等。</li>
<li>assets目录下的资源请确保没有用不上的文件。</li>
<li>生成APK的时候，aapt工具本身会对png做优化，但是在此之前还可以使用其他工具如tinypng对图片进行进一步的压缩预处理。</li>
<li>jpeg还是png，根据需要做选择，在某些时候jpeg可以减少图片的体积。</li>
<li>对于9.png的图片，可拉伸区域尽量切小，另外可以通过使用9.png拉伸达到大图效果的时候尽量不要使用整张大图。</li>
</ul>


<!-- More -->


<h3>策略</h3>

<ul>
<li>有选择性的提供hdpi，xhdpi，xxhdpi的图片资源。建议优先提供xhdpi的图片，对于mdpi，ldpi与xxxhdpi根据需要提供有差异的部分即可。</li>
<li>尽可能的重用已有的图片资源。例如对称的图片，只需要提供一张，另外一张图片可以通过代码旋转的方式实现。</li>
<li>能用代码绘制实现的功能，尽量不要使用大量的图片。例如减少使用多张图片组成animate-list的AnimationDrawable，这种方式提供了多张图片很占空间。</li>
</ul>


<h3>总结</h3>

<p>一个好的应用，需要具备很多优点，尽可能提供小的安装包是其中一个重要的方面。以上的小技巧，需要综合考虑，结合实际情况进行取舍。当然我们还可以采取一些按需加载的策略来减少安装包的体积，最好提一点，砍掉不必要的功能才是安装包瘦身的终极奥秘。O(∩_∩)O哈！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes - Activity生命周期中的onSaveInstanceState]]></title>
    <link href="http://hukai.me/android-activitylifecycle-onsaveinstancestate/"/>
    <updated>2014-08-31T17:01:00+08:00</updated>
    <id>http://hukai.me/android-activitylifecycle-onsaveinstancestate</id>
    <content type="html"><![CDATA[<p>记录下Activity生命周期中的<a href="http://developer.android.com/reference/android/app/Activity.html">onSaveInstanceState(Bundle outState)</a></p>

<h2>onSaveInstanceState与onRestoreInstanceState的作用：</h2>

<p>在资源紧张的情况下，系统会选择杀死一些处于非栈顶的Activity来回收资源。
为了能够让这些可能被杀死的Activity能够在恢复显示的时候状态不丢失，所以需要在Activity从栈顶往下压的时候提供onSaveInstanceState的回调用来提前保存状态信息。</p>

<p>而onRestoreInstanceState则是在这个Activity真的回收掉之后的恢复显示阶段用来恢复之前保存的数据。</p>

<h2>onSaveInstanceState与onRestoreInstanceState的调用时机：</h2>

<p>只要某个Activity是做入栈并且非栈顶时（启动跳转其他Activity或者点击Home按钮），此Activity是需要调用onSaveInstanceState的，
如果Activity是做出栈的动作（点击back或者执行finish），是不会调用onSaveInstanceState的。</p>

<p>只有在Activity真的被系统非正常杀死过，恢复显示Activity的时候，就会调用onRestoreInstanceState。</p>

<h2><a href="https://github.com/kesenhoo/ActivityLifeCycle">Sample Code</a></h2>

<ul>
<li>从ActivityA启动ActivityB执行顺序是：A：onCreate -> A：onStart -> A：onResume -> B：onCreate -> B：onStart -> B：onResume -> A：onSaveInstanceState –> A：onStop。</li>
<li>正常流程从ActivityB点击Back按钮或者是触发finish方法回退到ActivityA，执行顺序是：B：finish –> B：onPause –> A： onRestart –> A：onStart  -> A：onResume -> B： onStop –> B：onDestroy。</li>
<li>若启动ActivityB之后，选择点击Home按钮，程序退到后台，那么执行顺序是：B：onPause -> B：onSaveInstanceState -> B：onStop。</li>
<li>程序在后台的时候，选择主动杀死程序进程，然后再从桌面点击应用启动，会显示之前的ActivityB，执行顺序是：B：onCreate -> B：onStart –> B：onRestoreInstanceState - > B：onResume。</li>
<li>点击Back按钮或者是执行Activity B里面提供的finish方法：B：finish –> B：onPause –> A：onCreate  -> A：onStart -> A：onRestoreInstanceState -> A：onResume -> B：onStop -> B：onDestory。</li>
<li>最后再点击Back按钮或是执行Activity A里面的finish方法退出程序：A：finish -> A：onPause –> A：onStop -> A：onDestory。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training - 创建可穿戴应用(5 - 通过蓝牙进行调试)]]></title>
    <link href="http://hukai.me/android-training-wearable-app-bt-debug/"/>
    <updated>2014-07-15T00:23:00+08:00</updated>
    <id>http://hukai.me/android-training-wearable-app-bt-debug</id>
    <content type="html"><![CDATA[<p>你可以通过蓝牙来调试你的可穿戴应用，通过蓝牙把调试数据输出到手持设备上，手持设备是有连接到开发电脑上的。</p>

<h2>搭建好设备用来调试</h2>

<ul>
<li>开启手持设备的USB调试：

<ul>
<li>打开设置应用并滑动到底部。</li>
<li>如果在设置里面没有开发者选项，点击关于手机，滑动到底部，点击build number 7次。</li>
<li>返回并点击开发者选项。</li>
<li>开启USB调试。</li>
</ul>
</li>
<li>开启可穿戴设备的蓝牙调试：

<ul>
<li>点击主界面2次，来到Wear菜单界面。</li>
<li>滑动到底部，点击设置。</li>
<li>滑动到底部，如果没有开发者选项，点击Build Number 7次。</li>
<li>点击开发者选项。</li>
<li>开启蓝牙调试。</li>
</ul>
</li>
</ul>


<!-- More -->


<h2>建立调试会话</h2>

<ol>
<li>在手持设备上，打开<code>Android Wear</code>这个伴侣应用。</li>
<li>点击右上角的菜单，选择设置。</li>
<li>开启蓝牙调试。你将会在选项下面看到一个小的状态信息：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>Host: disconnected
</span><span class='line'>Target: connected
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>通过USB连接手持设备到你的电脑上，并执行下面的命令：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>adb forward tcp:4444 localabstract:/adb-hub; adb connect localhost:4444
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>Note:</strong> 你可以使用任何可用的端口。</p></blockquote>

<p>在<code>Android Wear</code>伴侣应用上，你将会看到状态变为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>Host: connected
</span><span class='line'>Target: connected
</span></code></pre></td></tr></table></div></figure>


<h2>调试你的应用</h2>

<p>当运行abd devices的命令时，你的可穿戴设备是作为localhost:4444的。执行任何的adb命令，需要使用下面的格式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>adb -s localhost:4444 <span class="nt">&lt;command&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果没有任何其他的设备通过TCP/IP连接到手持设备，你可以使用下面的简短命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>adb -e <span class="nt">&lt;command&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>adb -e logcat
</span><span class='line'>adb -e shell
</span><span class='line'>adb -e bugreport
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training - 创建可穿戴应用(4 - 打包可穿戴应用)]]></title>
    <link href="http://hukai.me/android-training-wearable-app-packaging/"/>
    <updated>2014-07-14T23:32:00+08:00</updated>
    <id>http://hukai.me/android-training-wearable-app-packaging</id>
    <content type="html"><![CDATA[<p>当发布应用给用户之前，你必须把可穿戴应用打包到手持应用内。因为不能直接在可穿戴设备上浏览并安装应用。如果打包正确，当用户下载手持应用时，系统会自动下发可穿戴应用到匹对的可穿戴设备上。</p>

<blockquote><p><strong>Note:</strong> 如果开发时签名用的是debug key，这个特性是无法正常工作的。在开发时，需要使用<code>adb install</code>的命令或者Android Studio来安装可穿戴应用。</p></blockquote>

<h2>使用Android Studio打包</h2>

<p>在Android Studio中打包可穿戴应用有下面几个步骤：</p>

<ol>
<li>在手持应用的buidl.gradle文件中把可穿戴应用声明为依赖：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>dependencies {
</span><span class='line'>   compile &#39;com.google.android.gms:play-services:5.0.+@aar&#39;
</span><span class='line'>   compile &#39;com.android.support:support-v4:20.0.+&#39;&#39;
</span><span class='line'>   wearApp project(&#39;:wearable&#39;)
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>




<!-- More -->


<ol>
<li>点击<strong>Build</strong> > <strong>Generate Signed APK</strong>&#8230; 安装屏幕上的指示来制定你的release key并为你的app进行签名。Android Studio导出签名好的手持应用，他内置了可穿戴应用。
或者，你可以在可穿戴应用与手持应用的build.gradle文件里面建立一个签名规则。为了能够正常自动推送可穿戴应用，这两个应用都必须签名。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>android {
</span><span class='line'>  ...
</span><span class='line'>  signingConfigs {
</span><span class='line'>    release {
</span><span class='line'>      keyAlias &#39;myAlias&#39;
</span><span class='line'>      keyPassword &#39;myPw&#39;
</span><span class='line'>      storeFile file(&#39;path/to/release.keystore&#39;)
</span><span class='line'>      storePassword &#39;myPw&#39;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  buildTypes {
</span><span class='line'>    release {
</span><span class='line'>      ...
</span><span class='line'>      signingConfig signingConfigs.release
</span><span class='line'>    }d
</span><span class='line'>  }
</span><span class='line'>  ...
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>通过点击Android Studio右边的Gradle按钮来建立手持应用，并执行<strong>assembleRelease</strong>任务。这个任务放在<strong>Project name</strong> > <strong>Handheld module name</strong> > <strong>assembleRelease.</strong></p>

<blockquote><p><strong>Note:</strong>这个例子中把密码写在了Gradle文件中，这应该不是期待的写法。请参考<a href="http://developer.android.com/sdk/installing/studio-build.html#configureSigning">Configure signing settings</a>学习如何为密码创建环境变量。</p></blockquote>

<h3>分别为可穿戴应用与手持应用进行签名</h3>

<p>如果你的Build任务需要为可穿戴应用与手持应用签不同的Key，你可以像下面一样在手持应用的build.gradle文件中声明规则。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>dependencies {
</span><span class='line'>  ...
</span><span class='line'>  wearApp files(&#39;/path/to/wearable_app.apk&#39;)
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>你可以为手持应用手动进行签任何形式的Key (可以是Android Studio Build > Generate Signed APK&#8230;的方式，也可以是Gradle signingConfig规则的方式)</p>

<h2>手动打包</h2>

<p>如果你使用的是其他IDE，你仍然可以把可穿戴应用打包到手持应用中。</p>

<ol>
<li>把签好名的可穿戴应用放到手持应用的<code>res/raw</code>目录下。 我们把这个应用作为<code>wearable_app.apk</code>。</li>
<li>创建<code>res/xml/wearable_app_desc.xml</code>文件，里面包含可穿戴设备的版本信息与路径。例如:</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;wearableApp</span> <span class="na">package=</span><span class="s">&quot;wearable.app.package.name&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;versionCode&gt;</span>1<span class="nt">&lt;/versionCode&gt;</span>
</span><span class='line'>  <span class="nt">&lt;versionName&gt;</span>1.0<span class="nt">&lt;/versionName&gt;</span>
</span><span class='line'>  <span class="nt">&lt;rawPathResId&gt;</span>wearable_app<span class="nt">&lt;/rawPathResId&gt;</span>
</span><span class='line'><span class="nt">&lt;/wearableApp&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>package, versionCode, 与 versionName需要和可穿戴应用的AndroidManifest.xml里面的信息一致。<code>rawPathResId</code>是一个static的变量表示APK的名称。。
3. 添加<code>meta-data</code>标签到你的手持应用的<code>&lt;application&gt;</code>标签下，指明引用wearable_app_desc.xml文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;meta-data</span> <span class="na">android:name=</span><span class="s">&quot;com.google.android.wearable.beta.app&quot;</span>
</span><span class='line'>                 <span class="na">android:resource=</span><span class="s">&quot;@xml/wearable_app_desc&quot;</span><span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>构建并签名手持应用。</li>
</ol>


<h2>关闭资源压缩</h2>

<p>许多构建工具会自动压缩放在res/raw目录下的文件。因为可穿戴APK已经被压缩过了，那些压缩工作再次压缩会导致应用无法正常安装。</p>

<p>这样的话，安装失败。在手持应用上，<code>PackageUpdateService</code>会输出如下的错误日志：&#8221;this file cannot be opened as a file descriptor; it is probably compressed.&#8221;</p>

<p>Android Studio 默认不会压缩你的APK，如果你使用另外一个构建流程，需要确保不会发生重复压缩可穿戴应用的事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training - 创建可穿戴应用(3 - 添加语音能力)]]></title>
    <link href="http://hukai.me/android-training-wearable-app-voice-input/"/>
    <updated>2014-07-14T21:43:00+08:00</updated>
    <id>http://hukai.me/android-training-wearable-app-voice-input</id>
    <content type="html"><![CDATA[<p>语音指令是可穿戴体验的一个重要的部分。这使得用户可以释放双手，快速发出指令。穿戴提供了2种类型的语音操作：</p>

<ul>
<li><p><strong>系统提供的</strong></p>

<p>这些语音指令都是基于任务的，并且内置在Wear的平台内。你在activity中过滤你想要接收的指令。例如包含&#8221;Take a note&#8221; 或者 &#8220;Set an alarm&#8221;的指令。</p></li>
<li><p><strong>应用提供的</strong></p>

<p>这些语音指令都是基于应用的，你需要像声明一个Launcher Icon一样定义这些指令。用户通过说&#8221;Start XXX&#8221;来使用那些语音指令，然后会启动你指定启动的activity。</p></li>
</ul>


<h2>声明系统提供的语音指令</h2>

<p>Android Wear平台基于用户的操作提供了一些语音指令，例如&#8221;Take a note&#8221; 或者 &#8220;Set an alarm&#8221;。用户发出想要做的操作指令，让系统寻找应该启动最合适的activity。</p>

<p>当用户说出语音指令时，你的应用能够被过滤出来启动一个activity。如果你想要启动一个service在后台执行任务，需要显示一个activity呈现作为线索。当你想要废弃这个可见的线索时，需要确保执行了finish()。</p>

<!-- More -->


<p>例如，对于&#8221;Take a note&#8221;的指令，定义一个MyNoteActivity来接收这个指令:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;</span><span class="n">activity</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;MyNoteActivity&quot;</span><span class="o">&gt;</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="n">intent</span><span class="o">-</span><span class="n">filter</span><span class="o">&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="n">action</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;android.intent.action.SEND&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="n">category</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;com.google.android.voicesearch.SELF_NOTE&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'>      <span class="o">&lt;/</span><span class="n">intent</span><span class="o">-</span><span class="n">filter</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;/</span><span class="n">activity</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面列出了Wear平台支持的语音指令：</p>

<p><img src="http://hukai.me/images/voice_intent_1.png" alt="voice_intent_1" />
<img src="http://hukai.me/images/voice_intent_2.png" alt="voice_intent_2" />
<img src="http://hukai.me/images/voice_intent_3.png" alt="voice_intent_3" /></p>

<p>关于注册intent与获取intent extra的信息，请参考<a href="http://developer.android.com/guide/components/intents-common.html">Common intents</a>.</p>

<h2>声明应用提供的语音指令</h2>

<p>如果系统提供的语音指令无法满足你的需求，你可以使用&#8221;Start MyActivityName&#8221;的指令来直接启动你的应用。</p>

<p>注册一个&#8221;Start&#8221;指令和注册手持应用上得Launcher是一样的。</p>

<p>在&#8221;Start&#8221;指令的后面需要指定的文字, 这个文字需要注册在activity的label属性上。例如，下面的设置能够识别&#8221;Start MyRunningApp&#8221;的语音指令并启动StartRunActivity.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;application&gt;</span>
</span><span class='line'>  <span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">&quot;StartRunActivity&quot;</span> <span class="na">android:label=</span><span class="s">&quot;MyRunningApp&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;intent-filter&gt;</span>
</span><span class='line'>          <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.action.MAIN&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>          <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.category.LAUNCHER&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/activity&gt;</span>
</span><span class='line'><span class="nt">&lt;/application&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>获取输入的自由语音</h2>

<p>除了使用语音指令来启动activity之外，你也可以执行系统内置的语言识别activity来获取用户的语音输入。这对于获取用户的输入信息非常有帮助，例如执行搜索或者发送一个消息。</p>

<p>在你的应用中，startActivityForResult()使用<code>ACTION_RECOGNIZE_SPEECH</code>启动系统语音识别应用。在onActivityResult()中处理返回的结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SPEECH_REQUEST_CODE</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Create an intent that can start the Speech Recognizer activity</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">displaySpeechRecognizer</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">(</span><span class="n">RecognizerIntent</span><span class="o">.</span><span class="na">ACTION_RECOGNIZE_SPEECH</span><span class="o">);</span>
</span><span class='line'>    <span class="n">intent</span><span class="o">.</span><span class="na">putExtra</span><span class="o">(</span><span class="n">RecognizerIntent</span><span class="o">.</span><span class="na">EXTRA_LANGUAGE_MODEL</span><span class="o">,</span>
</span><span class='line'>            <span class="n">RecognizerIntent</span><span class="o">.</span><span class="na">LANGUAGE_MODEL_FREE_FORM</span><span class="o">);</span>
</span><span class='line'><span class="c1">// Start the activity, the intent will be populated with the speech text</span>
</span><span class='line'>    <span class="n">startActivityForResult</span><span class="o">(</span><span class="n">intent</span><span class="o">,</span> <span class="n">SPEECH_REQUEST_CODE</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// This callback is invoked when the Speech Recognizer returns.</span>
</span><span class='line'><span class="c1">// This is where you process the intent and extract the speech text from the intent.</span>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onActivityResult</span><span class="o">(</span><span class="kt">int</span> <span class="n">requestCode</span><span class="o">,</span> <span class="kt">int</span> <span class="n">resultCode</span><span class="o">,</span>
</span><span class='line'>        <span class="n">Intent</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">requestCode</span> <span class="o">==</span> <span class="n">SPEECH_REQUEST</span> <span class="o">&amp;&amp;</span> <span class="n">resultCode</span> <span class="o">==</span> <span class="n">RESULT_OK</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">getStringArrayListExtra</span><span class="o">(</span>
</span><span class='line'>                <span class="n">RecognizerIntent</span><span class="o">.</span><span class="na">EXTRA_RESULTS</span><span class="o">);</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">spokenText</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">// Do something with spokenText</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">super</span><span class="o">.</span><span class="na">onActivityResult</span><span class="o">(</span><span class="n">requestCode</span><span class="o">,</span> <span class="n">resultCode</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
